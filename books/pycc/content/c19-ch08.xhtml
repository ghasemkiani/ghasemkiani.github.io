<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="fa" dir="rtl"><head><meta charset="utf-8"/><title>تابع</title><meta name="description" content="وب‌سایت قاسم کیانی مقدم"/><meta name="keywords" content="قاسم کیانی مقدم, وب‌سایت, وب‌سایت قاسم کیانی مقدم, کتاب, فارسی, کتاب فارسی, ترجمه, برنامه‌نویسی, جاوا, جاوا اسکریپت, پزشکی, طب اطفال"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="stylesheet" crossorigin="anonymous" href="https://cdn.rtlcss.com/bootstrap/v4.0.0/css/bootstrap.min.css" integrity="sha384-P4uhUIGk/q1gaD/NdgkBIl3a6QywJjlsFJFk7SPRdruoGddvRVSwv5qFnvZ73cpz"/><link rel="stylesheet" crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.7.1/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr"/><link rel="icon" href="../../../favicon.ico"/><style>@import url(https://fonts.googleapis.com/css?family=Droid+Sans);
@import url(https://fonts.googleapis.com/css?family=Droid+Serif);
@import url(https://fonts.googleapis.com/css?family=Droid+Arabic+Kufi);
@import url(https://fonts.googleapis.com/css?family=Droid+Arabic+Naskh);
html,body,input,textarea,select,option,h1,h2,h3,h4,h5,h6{font-family:Droid Arabic Naskh,Droid Serif;}
nav,.nav{font-family:Droid Arabic Kufi,Droid Sans;}
h1,h2,h3,h4,h5,h6{font-family:Droid Arabic Naskh,Droid Serif;}
#footer{margin-top:0.5rem;padding-top:0.5rem;border-top:#eeeeee solid thick;}</style><style>@import url(https://fonts.googleapis.com/css?family=Courier+Prime);
div.row.pager{margin-top:0.5em;padding:0.5em 0;border-top:solid #cccccc 2px;background-color:#dddddd;}
div.pager-prev{}
div.pager-title{}
div.pager-next{}</style><link rel="stylesheet" type="text/css" href="styles.css"/></head><body style="min-height: 75rem;"><nav class="navbar navbar-expand-md navbar-dark bg-dark mb-4"><div class="container"><a class="navbar-brand" href="../../../">وب‌سایت قاسم کیانی مقدم</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#divNavBarToggle" aria-controls="divNavBarToggle" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div id="divNavBarToggle" class="collapse navbar-collapse"><ul class="navbar-nav mr-auto"><li class="nav-item active"><a class="nav-link" href="../../">کتاب‌ها<span class="sr-only"> (current)</span></a></li><li class="nav-item"><a class="nav-link" href="../../../essays/">مقالات</a></li><li class="nav-item"><a class="nav-link" href="../../../translation/">ترجمه</a></li><li class="nav-item"><a class="nav-link" href="../../../about/">درباره</a></li><li class="nav-item"><a class="nav-link" href="../../../contact/">تماس</a></li></ul></div></div></nav><div class="container"><div class="row"><main class="col-md-10 order-md-last">
					<article class="ch" id="ch008"><h2 class="ch-title"><a class="rtoc" href="c06-toc.xhtml"><span class="ch-title-num">۸</span><br/><span class="ch-title-text">تابع</span></a></h2><img style="float: right; margin-left: 0.5em; margin-bottom: 0.25em;" alt="تصویر ابتدای فصل" src="images/ch.svg"/>
<a id="p129"></a><p class="noindent">در این فصل، نوشتن <span class="emphasis">توابع</span> را یاد می‌گیرید. تابع یک بلوک کد نام‌گذاری شده است که برای انجام کار خاصی طراحی شده است. وقتی که می‌خواهید کار خاصی را که در تابع تعریف شده است، انجام دهید، تابع مربوط به آن را <span class="emphasis">فراخوانی</span> می‌کنید. اگر در طول برنامه لازم باشد که آن کار را چندین بار انجام دهید، نایزی نیست که تمام کد مربوط به آن را بارها و بارها تکرار کنید؛ کافی است که تابع مربوط به آن کار را فراخوانی کنید، و این فراخوانی به پایتون می‌گوید که کد داخل تابع را اجرا کند. خواهید دید که استفاده از توابع سبب می‌شود که نوشتن، خواندن، آزمایش کردن، و اصلاح کردن برنامه‌های شما آسان‌تر شود.</p><p>در این فصل، روش‌های دادن اطلاعات به توابع را یاد خواهید گرفت. خواهید دید که چگونه توابعی بنویسید که کار اصلی آن‌ها نمایش اطلاعات است، و توابع دیگری که داده‌ها را پردازش می‌کنند و یک مقدار یا مجموعه‌ای از مقادیر را برمی‌گردانند. و بالاخره، نحوه‌ی ذخیره کردن توابع را در فایل‌های جداگانه‌ای که به آن‌ها <span class="emphasis">مدول</span> گفته می‌شود، یاد خواهید گرفت، تا بتوانید فایل‌های برنامه‌ی اصلی خود را سازمان‌دهی کنید.</p><div class="sect" id="ch08lev1sec1"><h3>تعریف کردن تابع</h3>
<a id="p130"></a><p class="noindent">در اینجا تابع ساده‌ای به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">greet_user()</span><span class="rlm">‏</span> داریم که یک پیام خوشامدگویی را نمایش می‌دهد:</p><div class="snippet-title" dir="ltr">greeter.py</div><pre class="snippet" dir="ltr"><span class="n" dir="ltr">1</span>def greet_user():
<span class="n" dir="ltr">2</span>    """Display a simple greeting."""
<span class="n" dir="ltr">3</span>    print("Hello!")

<span class="n" dir="ltr">4</span>greet_user()</pre><p>این مثال ساده‌ترین ساختار یک تابع را نشان می‌دهد. سطر <span class="n" dir="ltr">1</span> با استفاده از کلیدواژه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">def</span><span class="rlm">‏</span> به پایتون اطلاع می‌دهد که دارید یک تابع را تعریف می‌کنید. این <span class="emphasis">تعریف تابع</span> است، که در آن نام تابع و در صورت لزوم نوع اطلاعاتی که تابع برای انجام کار خود به آن نیاز دارد، مشخص می‌شود. این اطلاعات در داخل پرانتز تعیین می‌شود. در این مورد، نام تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">greet_user()</span><span class="rlm">‏</span> است، و برای انجام کار خود نیاز به هیچ اطلاعاتی ندارد، بنابراین، پرانتزها خالی است. (البته باز هم وجود پرانتزها ضروری است.) و سرانجام، تعریف تابع با دونقطه تمام می‌شود.</p><p>تمام سطرهای دارای تورفتگی بعد از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">def greet_user():</span><span class="rlm">‏</span>، <span class="emphasis">بدنه</span>ی تابع را تشکیل می‌دهند. متن سطر <span class="n" dir="ltr">2</span>، یک توضیح است و <span class="emphasis">docstring</span> (رشته‌ی مستندسازی) نامیده می‌شود، که مشخص می‌کند تابع چه کاری انجام می‌دهد. رشته‌های مستندسازی درون سه علامت نقل‌قول قرار می‌گیرند، و پایتون هنگام ایجاد مستندات برای توابع برنامه‌ی شما، از آن‌ها استفاده می‌کند.</p><p>دستور <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">print("Hello!")</span><span class="rlm">‏</span> در سطر <span class="n" dir="ltr">3</span> تنها سطر کدی است که درون بدنه‌ی تابع است، بنابراین، تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">greet_user()</span><span class="rlm">‏</span> فقط یک کار دارد: <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">print("Hello!")</span><span class="rlm">‏</span>.</p><p>وقتی که می‌خواهید از این تابع استفاده کنید، آن را فراخوانی می‌کنید. <span class="emphasis">فراخوانی تابع</span> به پایتون می‌گوید که کد درون تابع را اجرا کند. برای <span class="emphasis">فراخوانی</span> یک تابع، باید نام تابع را بنویسید، و به دنبال آن اطلاعات لازم را داخل پرانتز به آن بدهید، که نمونه‌ی آن در <span class="n" dir="ltr">4</span> دیده می‌شود. از آنجا که در این مورد هیچ‌گونه اطلاعاتی لازم نیست، لذا فراخوانی تابع به سادگی به‌صورت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">greet_user()</span><span class="rlm">‏</span> است. همان گونه که انتظار می‌رود، این تابع پرینت می‌کند <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Hello!</span><span class="rlm">‏</span>.</p><pre class="snippet" dir="ltr">Hello!</pre><div class="sect" id="ch08lev2sec1"><h4>دادن اطلاعات به تابع</h4>
<p class="noindent">با کمی تغییر، تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">greet_user()</span><span class="rlm">‏</span> می‌تواند نه تنها به کاربر بگوید <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Hello!</span><span class="rlm">‏</span>، بلکه نام او را نیز ذکر کند. برای این منظور، عبارت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">username</span><span class="rlm">‏</span> را در داخل پرانتز در تعریف تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">def greet_user()</span><span class="rlm">‏</span> وارد می‌کنید. با افزودن <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">username</span><span class="rlm">‏</span> در اینجا، تابع برای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">username</span><span class="rlm">‏</span> هرگونه مقداری را که به آن بدهید، قبول می‌کند. اکنون تابع انتظار دارد که هنگام فراخوانی، مقداری برای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">username</span><span class="rlm">‏</span> به آن بدهید. وقتی که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">greet_user()</span><span class="rlm">‏</span> را فراخوانی می‌کنید، می‌توانید یک نام، مانند <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'jesse'</span><span class="rlm">‏</span>، در داخل پرانتز به آن بدهید:</p><pre class="snippet" dir="ltr">def greet_user(username):
    <span class="ash">"""Display a simple greeting."""</span>
    print(f"Hello, {username.title()}!")

greet_user('jesse')</pre><a id="p131"></a><p>دستور <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">greet_user('jesse')</span><span class="rlm">‏</span>، تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">greet_user()</span><span class="rlm">‏</span> را فراخوانی می‌کند و اطلاعاتی را که برای اجرای دستور <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">print()</span><span class="rlm">‏</span> لازم دارد، به آن می‌دهد. تابع نامی را که به نام می‌دهید، قبول می‌کند، و پیام خوشامدگویی را برای آن نام نمایش می‌دهد:</p><pre class="snippet" dir="ltr">Hello, Jesse!</pre><p>به همین ترتیب، دستور <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">greet_user('sarah')</span><span class="rlm">‏</span> تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">greet_user()</span><span class="rlm">‏</span> را اجرا می‌کند، مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'sarah'</span><span class="rlm">‏</span> به آن می‌دهد، و نمایش می‌دهد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Hello, Sarah!</span><span class="rlm">‏</span>. می‌توانید هر چند بار که خواستید، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">greet_user()</span><span class="rlm">‏</span> را فراخوانی کنید، و هر نامی می‌خواهید به آن بدهید، تا خروجی مورد انتظار را برای آن نمایش دهد.</p></div><div class="sect" id="ch08lev2sec2"><h4>آرگومان‌ها و پارامترها</h4>
<p class="noindent">در تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">greet_user()</span><span class="rlm">‏</span> قبل، ما <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">greet_user()</span><span class="rlm">‏</span> را به‌گونه‌ای تعریف کردیم که نیاز به متغیر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">username</span><span class="rlm">‏</span> دارد. وقتی که تابع را فراخوانی می‌کنیم و این اطلاعات (نام فرد) را به آن می‌دهیم، پیام مناسب را نمایش می‌دهد.</p><p>متغیر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">username</span><span class="rlm">‏</span> در تعریفغ تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">greet_user()</span><span class="rlm">‏</span> نمونه‌ای از یک <span class="emphasis">پارامتر</span> است، یعنی اطلاعاتی که تابع برای جارای خود به آن نیاز دارد. مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'jesse'</span><span class="rlm">‏</span> در دستور <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">greet_user('jesse')</span><span class="rlm">‏</span>، نمونه‌ای از یک <span class="emphasis">آرگومان</span> است. آرگومان اطلاعاتی است که در فراخوانی تابع به تابع داده می‌شود. وقتی که تابعی را فراخوانی می‌کنیم، مقداری را که می‌خواهیم تابع با آن کار کند، داخل پرانتز قرار می‌دهیم. در این مورد، آرگومان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'jesse'</span><span class="rlm">‏</span> به تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">greet_user()</span><span class="rlm">‏</span> داده می‌شود، و این مقدار به پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">username</span><span class="rlm">‏</span> اختصاص می‌یابد.</p><div class="note"><h6 class="note-title">توجه</h6>
<p class="noindent">بعضی وقت‌ها کلمات آرگومان و پارامتر به جای هم به کار برده می‌شود. مثلاً به متغیرهای به کار رفته در تعریف تابع، آرگومان گفته می‌شود، یا اینکه به متغیرها در فراخوانی تابع پارامتر گفته می‌شود.</p></div><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<p class="tiy1"><span class="tiy" id="ch008_tiy001"><span class="tiy-num">۸-۱</span>. <span class="tiy-title">پیام</span>: </span>  تابعی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">display_message()</span><span class="rlm">‏</span> بنویسید که جمله‌ای را نمایش می‌دهد که در آن به همه می‌گویید که در این درس چه چیزی یاد می‌گیرید. این تابع را فراخوانی کنید و دقت کنید که پیام به درستی نمایش داده شود.</p><p class="tiy1"><span class="tiy" id="ch008_tiy002"><span class="tiy-num">۸-۲</span>. <span class="tiy-title">کتاب مورد علاقه</span>: </span>  تابعی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">favorite_book()</span><span class="rlm">‏</span> بنویسید که یک پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">title</span><span class="rlm">‏</span> می‌گیرد. این تابع باید پیامی نمایش دهد، مثلاً <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">One of my favorite books is Alice in Wonderland</span><span class="rlm">‏</span>. تابع را فراخوانی کنید و یادتان باشد که عنوان یک کتاب را به‌عنوان آرگومان در فراخوانی تابع به آن بدهید.</p></div></div></div><div class="sect" id="ch08lev1sec2"><h3>دادن آرگومان‌ها</h3>
<p class="noindent">از آنجا که تعریف تابع می‌تواند شامل پارامترهای متعددی باشد، لذا در فراخوانی تابع ممکن است آرگومان‌های متعددی مورد نیاز باشد.به چند طریق می‌توانید آرگومان‌ها را به تابع خود بدهید. می‌توانید از <span class="emphasis">آرگومان‌های موقعیتی</span> استفاده کنید، که باید به <a id="p132"></a>همان ترتیب پارامترها باشند؛ یا اینکه می‌توانید از <span class="emphasis">آرگومان‌های کلیدواژه‌ای</span> استفاده کنید که در آن هر آرگومان شامل نام متغیر و مقدار آن است؛ و نیز می‌توانید از لیست‌ها یا دیکشنری‌هایی از مقادیر استفاده کنید.هر کدام از این‌ها را به نوبت بررسی می‌کنیم.</p><div class="sect" id="ch08lev2sec3"><h4>آرگومان‌های موقعیتی</h4>
<p class="noindent">وقتی که تابعی را فراخوانی می‌کنید، پایتون باید هر کدام از آرگومان‌های داده شده در فراخوانی تابع را با یک پئد در تعریف تابع انطباق بدهد. ساده‌ترین راه برای انجام این کار بر اساس ترتیب آرگومان‌های داده‌شده است. وقتی که مقادیر به این طریق انطباق داده می‌شود، به آن‌ها <span class="emphasis">آرگومان‌های موقعیتی</span> گفته می‌شود.</p><p>برای اینکه چگونگی انجام این کار را بفهمید، تابعی را در نظر بگیرید که اطلاعات مربوط به حیوانات خانگی را نمایش می‌دهد. این تابع نوع حیوان خانگی و نام آن را به ما می‌گوید، همان طور که در زیر نمایش داده شده است:</p><div class="snippet-title" dir="ltr">pets.py</div><pre class="snippet" dir="ltr"><span class="n" dir="ltr">1</span>def describe_pet(animal_type, pet_name):
    """Display information about a pet."""
    print(f"\nI have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name.title()}.")

<span class="n" dir="ltr">2</span>describe_pet('hamster', 'harry')</pre><p>این تعریف نشان می‌دهد که تابع نیاز به نوع حیوان و نام حیوان دارد <span class="n" dir="ltr">1</span>. وقتی که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">describe_pet()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم، باید نوع حیوان و نام حیوان را به ترتیب به آن بدهیم. به‌عنوان مثال، در فراخوانی تابع، آرگومان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'hamster'</span><span class="rlm">‏</span> به پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">animal_type</span><span class="rlm">‏</span> و آرگومان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'harry'</span><span class="rlm">‏</span>به پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">pet_name</span><span class="rlm">‏</span> اختصاص داده می‌شود <span class="n" dir="ltr">2</span>. در بدنه‌ی تابع، با استفاده از این دو پارامتر، اطلاعات مربوط به حیوان خانگی نمایش داده می‌شود.</p><p>خروجی برنامه همستری به نام هری را توصیف می‌کند.</p><pre class="snippet" dir="ltr">I have a hamster.
My hamster's name is Harry.</pre><div class="sect" id="ch08lev3sec1"><h5>فراخوانی‌های متعدد تابع</h5>
<p class="noindent">شما می‌توانید یک تابع را هر چند بار که لازم باشد، فراخوانی کنید. برای توصیف کردن یک حیوان خانگی دیگر، کافی است که یک بار دیگر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">describe_pet()</span><span class="rlm">‏</span> را فراخوانی کنید:</p><pre class="snippet" dir="ltr"><span class="ash">def describe_pet(animal_type, pet_name):</span>
    <span class="ash">"""Display information about a pet."""</span>
    <span class="ash">print(f"\nI have a {animal_type}.")</span>
    <span class="ash">print(f"My {animal_type}'s name is {pet_name.title()}.")</span>

<span class="ash">describe_pet('hamster', 'harry')</span>
describe_pet('dog', 'willie')</pre><p>در دومین فراخوانی تابع، به تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">describe_pet()</span><span class="rlm">‏</span>، آرگومان‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'dog'</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'willie'</span><span class="rlm">‏</span> می‌دهیم. در اینجا هم مانند مورد قبلی، پایتون مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'dog'</span><span class="rlm">‏</span> را با پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">animal_type</span><span class="rlm">‏</span> و مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'willie'</span><span class="rlm">‏</span> را با پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">pet_name</span><span class="rlm">‏</span> انطباق می‌دهد. <a id="p133"></a>مانند قبل، تابع کارش را انجام میدهد، ولی این بار مقادیر مربوط به سگی به نام ویلی را نمایش می‌دهد. اکنون همستری به نام هری و سگی به نام ویلی داریم:</p><pre class="snippet" dir="ltr">I have a hamster.
My hamster's name is Harry.

I have a dog.
My dog's name is Willie.</pre><p>فراخواندن یک تابع به دفعات متعدد روشی بسیار کارآمد است. کدی که یک حیوان خانگی را توصیف می‌کند، فقط یک بار در داخل تابع نوشته می‌شود. سپس هرگاه می‌خواهید حیوان خانگی جدیدی را توصیف کنید، تابع را با اطلاعات مربوط به حیوان خانگی جدید فراخوانی می‌کنید. حتی اگر کد توصیف‌کننده‌ی حیوان خانگی به ده سطر افزایش یابد، باز هم تنها با یک سطر از طریق فراخوانی مجدد تابع خواهید توانست حیوان خانگی جدیدی را توصیف کنید.</p><p>می توانید از هر تعداد آرگومان موقعیتی که لازم باشد در توابع خود استفاده کنید. پایتون آرگومان‌هایی را که هنگام فراخوانی تابع ارائه کرده‌اید، در نظر می‌گیرد و هر کدام از آنها را با پارامتر متناظر در تعریف تابع انطباق می‌دهد.</p></div><div class="sect" id="ch08lev3sec2"><h5> ترتیب در آرگومان‌های موقعیتی اهمیت دارد</h5>
<p class="noindent">اگر هنگام استفاده از آرگومان‌های موقعیتی، ترتیب آرگومان‌ها در فراخوانی تابع به هم بخورد، ممکن است نتایج غیرمنتظره‌ای حاصل شود:</p><pre class="snippet" dir="ltr"><span class="ash">def describe_pet(animal_type, pet_name):</span>
    <span class="ash">"""Display information about a pet."""</span>
    <span class="ash">print(f"\nI have a {animal_type}.")</span>
    <span class="ash">print(f"My {animal_type}'s name is {pet_name.title()}.")</span>

describe_pet('harry', 'hamster')</pre><p>در این فراخوانی تابع، نام حیوان را اول نوشته‌ایم و نوع حیوان را بعد از آن. از آنجا که ابتدا آرگومان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'harry'</span><span class="rlm">‏</span> داده شده است، لذا آن مقدار به پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">animal_type</span><span class="rlm">‏</span> اختصاص داده می‌شود. به همین ترتیب، مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'hamster'</span><span class="rlm">‏</span> به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">pet_name</span><span class="rlm">‏</span> اختصاص داده می‌شود. اکنون یک «هری» به نام «همستر» داریم:</p><pre class="snippet" dir="ltr">I have a harry.
My harry's name is Hamster.</pre><p>شما هم اگر چنین نتایج مضحکی به دست آوردید، وارسی کنید که ترتیب آرگومان‌ها در فراخوانی تابع شما با ترتیب پارامترها در تعریف تابع انطباق داشته باشد.</p></div></div><div class="sect" id="ch08lev2sec4"><h4>آرگومان‌های کلیدواژه‌ای</h4>
<p class="noindent"><span class="emphasis">آرگومان کلیدواژه‌ای</span> یک زوج نام-مقدار است که به تابع می‌دهید. در داخل آرگومان، نام و مقدار را مستقیماً با هم مرتبط می‌کنید، لذا وقتی که آرگومان را به تابع می‌دهید، دیگر ابهامی وجود ندارد (و جوری نمی‌شود که <a id="p134"></a> مثلاً یک هری به نام همستر داشته باشید). با به‌کارگیری آرگومان‌های کلیدواژه‌ای دیگر لازم نیست نگران ترتیب آرگومان‌ها در فراخوانی تابع باشید، و نقش هر مقدار داده‌شده در فراخوانی تابع مشخص می‌شود.</p><p>اکنون <span class="rlm">‏</span><span class="ident" dir="ltr">pets.py</span><span class="rlm">‏</span> را بازنویسی می‌کنیم و از آرگومان‌های کلیدواژه‌ای برای فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">describe_pet()</span><span class="rlm">‏</span> استفاده می‌کنیم:</p><pre class="snippet" dir="ltr"><span class="ash">def describe_pet(animal_type, pet_name):</span>
    <span class="ash">"""Display information about a pet."""</span>
    <span class="ash">print(f"\nI have a {animal_type}.")</span>
    <span class="ash">print(f"My {animal_type}'s name is {pet_name.title()}.")</span>

describe_pet(animal_type='hamster', pet_name='harry')</pre><p>تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">describe_pet()</span><span class="rlm">‏</span> تغییری نکرده است. ولی وقتی که تابع را فراخوانی می‌کنیم، به صراحت به پایتون می‌گوییم که هر آرگومان با کدام پارامتر باید انطباق داده شود. وقتی که پایتون فراخوانی تابع را می‌خواند، می‌داند که باید آرگومان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'hamster'</span><span class="rlm">‏</span> را به پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">animal_type</span><span class="rlm">‏</span> و آرگومان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'harry'</span><span class="rlm">‏</span> را به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">pet_name</span><span class="rlm">‏</span> اختصاص دهد. در خروجی هم معلوم می‌شود که همستری به نام هری داریم.</p><p>ترتیب در آرگومان‌های کلیدواژه‌ای اهمیتی ندارد، زیرا پایتون می‌داند که هر مقدار مربوط به چیست. دو فراخوانی تابع زیر معادل یکدیگر است:</p><pre class="snippet" dir="ltr">describe_pet(animal_type='hamster', pet_name='harry')
describe_pet(pet_name='harry', animal_type='hamster')</pre><div class="note"><h6 class="note-title">توجه</h6>
<p class="noindent">وقتی که از آرگومان‌های کلیدواژه‌ای استفاده می‌کنید، دقت کنید که دقیقاً از همان نام پارامترهای داده شده، در تعریف تابع استفاده کنید.</p></div></div><div class="sect" id="ch08lev2sec5"><h4>مقادیر پیش‌فرض</h4>
<p class="noindent">هنگام نوشتن یک تابع، می‌توانید برای هر پارامتر یک <span class="emphasis">مقدار پیش‌فرض</span> تعریف کنید. اگر آرگومانی برای یک پارامتر در فراخوانی تابع داده شده باشد، پایتون از مقدار آرگومان استفاده می‌کند. در غیر این صورت، از مقدار پیش‌فرض آن پارامتر استفاده می‌کند. بنابراین، وقتی که یک مقدار پیش‌فرض برای یک پارامتر تعیین کرده باشید، می‌توانید آرگومان مربوط به آن را از موارد معمول فراخوانی تابع حذف کنید. استفاده از مقادیر پیش‌فرض، فراخوانی تابع را ساده‌تر کرده و کاربردهای معمول تابع را واضح‌تر می‌کند.</p><p>به‌عنوان مثال، اگر مشاهده کنید که اکثر فراخوانی‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">describe_pet()</span><span class="rlm">‏</span> برای توصیف سگ‌ها انجام می‌شود، می‌توانید مقدار پیش‌فرض <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">animal_type</span><span class="rlm">‏</span> را <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'dog'</span><span class="rlm">‏</span> قرار دهید. اکنون کسی که بخواهد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">describe_pet()</span><span class="rlm">‏</span> را برای یک سگ فراخوانی کند، می‌تواند آن اطلاعات را حذف کند:</p><pre class="snippet" dir="ltr">def describe_pet(pet_name, animal_type='dog'):
    <span class="ash">"""Display information about a pet."""</span>
    <span class="ash">print(f"\nI have a {animal_type}.")</span>
    <span class="ash">print(f"My {animal_type}'s name is {pet_name.title()}.")</span>

describe_pet(pet_name='willie')</pre><a id="p135"></a><p>تعریف <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">describe_pet()</span><span class="rlm">‏</span> را تغییر دادیم و مقدار پیش‌فرض <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'dog'</span><span class="rlm">‏</span> را برای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">animal_type</span><span class="rlm">‏</span> تعیین کردیم. حال وقتی تابع فراخوانی شود و مقداری برای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">animal_type</span><span class="rlm">‏</span> تعیین نشود، پایتون می‌داند که باید از مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'dog'</span><span class="rlm">‏</span> برای این پارامتر استفاده کند:</p><pre class="snippet" dir="ltr">I have a dog.
My dog's name is Willie.</pre><p>دقت کنید که مجبور شدیم ترتیب پارامترها را در تعریف تابع تغییر دهیم. از آنجا که به علت داشت مقدار پیش‌فرض، ضروری نیست که نوع حیوان را به‌صورت آرگومان مشخص کنیم، لذا تنها آرگومانی که در فراخوانی تابع باقی می‌ماند، نام حیوان است. پایتون این را به‌عنوان یک آرگومان موقعیتی در نظر می‌گیرد، لذا اگر تابع فقط با نام حیوان خانگی فراخوانی شود، آن آرگومان با اولین پارامتر داده‌شده در تعریف تابع انطباق خواهد یافت. به این علت است که اولین پارامتر باید <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">pet_name</span><span class="rlm">‏</span> باشد.</p><p>اکنون ساده‌ترین راه برای استفاده از این تابع این است که فقط نام یک سگ را در فراخوانی تابع ارائه کنیم:</p><pre class="snippet" dir="ltr">describe_pet('willie')</pre><p>این فراخوانی تابع همان خروجی مثال قبلی را خواهد داشت. تنها آرگومان ارائه‌شده <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'willie'</span><span class="rlm">‏</span> است، لذا با پارامتر اول در تعریف تابع، یعنی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">pet_name</span><span class="rlm">‏</span>، انطباق حاصل می‌کند. از آنجا که آرگومان دیگری برای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">animal_type</span><span class="rlm">‏</span> داده نشده است، لذا پایتون از مقدار پیش‌فرض <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'dog'</span><span class="rlm">‏</span> استفاده می‌کند.</p><p>برای اینکه حیوانی غیر از سگ را توصیف کنید، می‌توانید فراخوانی تابع را به‌صورت زیر انجام دهید:</p><pre class="snippet" dir="ltr">describe_pet(pet_name='harry', animal_type='hamster')</pre><p>از آنجا که با صراحت آرگومانی برای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">animal_type</span><span class="rlm">‏</span> داده شده است، لذا پایتون توجهی به مقدار پیش‌فرض این پارامتر نخواهد کرد.</p><div class="note"><h6 class="note-title">توجه</h6>
<p class="noindent">وقتی که از مقادیر پیش‌فرض استفاده می‌کنید، هر پارامتری که مقدار پیش‌فرض دارد، باید پس از تمام پارامترهایی که فاقد مقادیر پیش‌فرض هستند، نوشته شود. بر این اساس، پایتون می‌تواند آرگومان‌های موقعیتی را به درستی تشخیص دهد.</p></div></div><div class="sect" id="ch08lev2sec6"><h4>انواع مختلف فراخوانی تابع</h4>
<p class="noindent">از آنجا که از آرگومان‌های موقعیتی، آرگومان‌های کلیدواژه‌ای، و مقادیر پیش‌فرض می‌توان بال هم استفاده کرد، لذا فراخوانی یک تابع را می‌توان به چندین روش انجام داد که همه‌ی آن‌ها معادل یکدیگر است. مثلاً تعریف زیرا را برای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">describe_pet()</span><span class="rlm">‏</span> با یک مقدار پیش‌فرض در نظر بگیرید:</p><pre class="snippet" dir="ltr">def describe_pet(pet_name, animal_type='dog'):</pre><p>با این تعریف، یک آرگومان باید حتماً برای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">pet_name</span><span class="rlm">‏</span> داده شود، و این مقدار را می‌توان با <a id="p136"></a>فرمت آرگومان موقعیتی یا کلیدواژه‌ای ارائه کرد. اگر حیوانی که توصیف می‌شود، سگ نباشد، باید یک آرگومان برای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">animal_type</span><span class="rlm">‏</span> نیز در فراخوانی داده شود، و این آرگومان را نیز می‌توان با فرمت آرگومان موقعیتی یا کلیدواژه‌ای ارائه کرد.</p><p>تمام فراخوانی‌های زیر برای این تابع قابل استفاده است:</p><pre class="snippet" dir="ltr"># A dog named Willie.
describe_pet('willie')
describe_pet(pet_name='willie')

# A hamster named Harry.
describe_pet('harry', 'hamster')
describe_pet(pet_name='harry', animal_type='hamster')
describe_pet(animal_type='hamster', pet_name='harry')</pre><p>هر کدام از این فراخوانی‌های تابع خروجی یکسانی مانند مثال قبل خواهد داشت.</p><div class="note"><h6 class="note-title">توجه</h6>
<p class="noindent">واقعاً تفاوتی نمی‌کند که از کدام شیوه‌ی فراخوانی استفاده کنید. مادام که فراخوانی تابع همان خروجی مورد نظر شما را ایجاد کند، می‌توانید از هر شیوه‌ای که فهمیدن آن آسان‌تر است، استفاده کنید.</p></div></div><div class="sect" id="ch08lev2sec7"><h4>اجتناب از خطاهای مربوط به آرگومان‌ها</h4>
<p class="noindent">وقتی که شروع به استفاده از تابع‌ها کنید، بعید نیست با خطاهایی در ارتباط با عدم انطباق آرگومان‌ها مواجه شوید. عدم انطباق آرگومان‌ها زمانی رخ می‌دهد که آرگومان‌هایی که داده‌اید، کمتر یا بیشتر از چیزی باشد که تابع برای عملکرد خود به آن نیاز دارد. به‌عنوان مثال، ببینیم اگر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">describe_pet()</span><span class="rlm">‏</span> را بدون آرگومان فراخوانی کنید، چه اتفاقی می‌افتد:</p><pre class="snippet" dir="ltr"><span class="ash">def describe_pet(animal_type, pet_name):</span>
    <span class="ash">"""Display information about a pet."""</span>
    <span class="ash">print(f"\nI have a {animal_type}.")</span>
    <span class="ash">print(f"My {animal_type}'s name is {pet_name.title()}.")</span>

describe_pet()</pre><p>پایتون متوجه می‌شود که اطلاعات لازم در فراخوانی تابع ارائه نشده است و این موضوع را در گزارش خطا به ما اطلاع می‌دهد:</p><pre class="snippet" dir="ltr">Traceback (most recent call last):
<span class="n" dir="ltr">1</span>  File "pets.py", line 6, in &lt;module&gt;
<span class="n" dir="ltr">2</span>    describe_pet()
<span class="n" dir="ltr">3</span>TypeError: describe_pet() missing 2 required positional arguments: 'animal_
   type' and 'pet_name'</pre><p>در <span class="n" dir="ltr">1</span>، گزارش خطا محل مشکل را به ما می‌گوید، به‌طوری که می‌توانیم نگاه کنیم و ببینیم که مشکلی در فراخوانی تابع ما رخ داده است. در <span class="n" dir="ltr">2</span>، فراخوانی تابع مورد نظر برای ما نوشته شده است. در <span class="n" dir="ltr">3</span>، گزارش خطا <a id="p137"></a>می‌گوید که فراخوانی دو آرگومان مورد نیاز را ندارد و نام آرگومان‌های مذکور را مشخص کرده است. اگر این تابع در فایل جداگانه‌ای می‌بود، احتمالاً می‌توانستیم بدون باز کردن آن فایل و خواندن کد تابع، فراخوانی را به‌صورت صحیح بازنویسی کنیم.</p><p>پایتون از این جهت مفید است که کد تابع را برای ما می‌خواند و نام آرگومان‌هایی را که لازم است به آن بدهیم، مشخص می‌کند. این یکی دیگر از دلایلی است که بهتر است نام مناسبی به متغیرها و توابع خود بدهید. اگر این کار را بکنید، پیغام‌های خطای پایتون برای شما و سایر افرادی که از کد شما استفاده می‌کنند، سودمندتر خواهد بود.</p><p>اگر آرگومان اضافی نیز به تابع بدهید، گزارش خطای مشابهی دریافت خواهید کرد که می‌تواند به شما کمک کند تا فراخوانی تابع را مطابق با تعریف تابع اصلاح کنید.</p><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<p class="tiy1"><span class="tiy" id="ch008_tiy003"><span class="tiy-num">۸-۳</span>. <span class="tiy-title">پیراهن</span>: </span> تابعی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">make_shirt()</span><span class="rlm">‏</span> بنویسید که سایز پیراهن و متن پیامی را از شما می‌گیرد که باید روی پیراهن چاپ شود. سپس این تابع جمله‌ای را نمایش می‌دهد که مشخص کننده‌ی سایز پیراهن و پیامی است که روی آن چاپ شده است.</p><p>تابع را یک بار با آرگومان‌های موقعیتی برای آماده‌سازی یک پیراهن فراخوانی کنید. بار دوم، تابع را با آرگومان‌های کلیدواژه‌ای فراخوانی کنید.</p><p class="tiy1"><span class="tiy" id="ch008_tiy004"><span class="tiy-num">۸-۴</span>. <span class="tiy-title">پیراهن‌های بزرگ</span>: </span> تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">make_shirt()</span><span class="rlm">‏</span> را تغییر دهید، به‌طوری که اندازه‌ی پیش‌فرض پیراهن لارج باشد و پیام پیش‌فرض روی آن، <span class="emphasis"><span class="rlm">‏</span><span class="lr" dir="ltr">I love Python</span><span class="rlm">‏</span></span> باشد. یک پیراهن لارج و یک پیراهن مدیوم با پیام پیش‌فرض تهیه کنید، و سپس پیراهنی با سایز دیگر با پیامی متفاوت ایجاد نمایید.</p><p class="tiy1"><span class="tiy" id="ch008_tiy005"><span class="tiy-num">۸-۵</span>. <span class="tiy-title">شهرها</span>: </span> تابعی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">describe_city()</span><span class="rlm">‏</span> بنویسید که نام یک شهر و کشور آن را می‌گیرد. این تابع باید جمله‌ی ساده‌ای را نمایش دهد، مثلاً <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;"><span class="rlm">‏</span><span class="lr" dir="ltr">Reykjavik is in Iceland</span><span class="rlm">‏</span></span><span class="rlm">‏</span>. به پارامتر مربوط به کشور، یک مقدار پیش‌فرض بدهید. تابع را سه بار برای شهرهای مختلف فراخوانی کنید، که لااقل یکی از این شهرها در کشور پیش‌فرض نباشد.</p></div></div></div><div class="sect" id="ch08lev1sec3"><h3>مقادیر برگشتی</h3>
<p class="noindent">همیشه لازم نیست که یک تابع خروجی خود را به‌طور مستقیم نمایش دهد. بلکه می‌تواند داده‌ها را پردازش کند و سپس یک مقدار یا مجموعه‌ای از مقادیر را برگرداند. مقداری که تابع برمی‌گرداند، <span class="emphasis">مقدار برگشتی</span> نامیده می‌شود. دستورالعمل <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">return</span><span class="rlm">‏</span> مقداری را در داخل تابع می‌گیرد و آن را به سطری که تابع در آن فراخوانی شده است، برمی‌گرداند. مقادیر برگشتی به شما امکان می‌دهند که مقدار زیادی از کارهای تکراری برنامه را به داخل توابع انتقال دهید، که این موجب ساده‌تر شدن برنامه‌ی شما می‌شود.</p><div class="sect" id="ch08lev2sec8"><h4>برگرداندن یک مقدار ساده</h4>
<a id="p138"></a><p class="noindent">تابعی را در نظر می‌گیریم که نام و نام خانوادگی را می‌گیرد، و نام کامل را با فرمتی مرتب برمی‌گرداند:</p><div class="snippet-title" dir="ltr">formatted_name.py</div><pre class="snippet" dir="ltr"><span class="n" dir="ltr">1</span>def get_formatted_name(first_name, last_name):
    """Return a full name, neatly formatted."""
<span class="n" dir="ltr">2</span>    full_name = f"{first_name} {last_name}"
<span class="n" dir="ltr">3</span>    return full_name.title()

<span class="n" dir="ltr">4</span>musician = get_formatted_name('jimi', 'hendrix')
print(musician)</pre><p>تعریف <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">get_formatted_name()</span><span class="rlm">‏</span> به‌عنوان پارامتر نام و نام خانوادگی را می‌گیرد <span class="n" dir="ltr">1</span>. این تابع دو نام را کنار هم قرار می‌دهد، بین آن‌ها یک اسپیس می‌گذارد، و آن‌ها را به متغیر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">full_name</span><span class="rlm">‏</span> اختصاص می‌دهد <span class="n" dir="ltr">2</span>. مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">full_name</span><span class="rlm">‏</span> از نظر حروف کوچک و بزرگ
 به حالت عنوان تبدیل می‌شود، و سپس در <span class="n" dir="ltr">3</span> به سطر فراخوانی‌کننده برگردانده می‌شود.</p><p>وقتی که تابعی را فراخوانی می‌کنید که مقداری را برمی‌گرداند، باید متغیری ارائه کنید که بتوان مقدار برگشتی را به آن ختصاص داد. در این مورد، مقدار برگشتی در سطر <span class="n" dir="ltr">4</span> به متغیر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">musician</span><span class="rlm">‏</span> اختصاص داده می‌شود. خروجی، نام فرمت شده‌ی مرتب را نشان می‌دهد که از نام و نام خانوادگی فرد تشکیل شده است:</p><pre class="snippet" dir="ltr">Jimi Hendrix</pre><p>شاید فکر کنید که این همه زحمت برای فرمت کردن مرتب نام و نام خانوادگی خیلی زیاد است، چرا که به راحتی می‌توانستیم بنویسیم:</p><pre class="snippet" dir="ltr">print("Jimi Hendrix")</pre><p>ولی وقتی بخواهید با برنامه‌ی بزرگی کار کنید که در آن باید تعداد زیادی نام و نام خانوادگی به‌صورت جداگانه ذخیره شود، توابعی مانند <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">get_formatted_name()</span><span class="rlm">‏</span> بسیار مفید واقع می‌شوند. شما نام و نام خانوادگی را جداگانه ذخیره می‌کنید و سپس هر گاه می‌خواهید نام کامل را نمایش دهید، این تابع را فراخوانی می‌کنید.</p></div><div class="sect" id="ch08lev2sec9"><h4>اختیاری کردن یک آرگومان</h4>
<p class="noindent">بعضی وقت‌ها مناسب است که یک آرگومان اختیاری باشد، به‌طوری که افرادی که از تابع استفاده می‌کنند، بتوانند اطلاعات اضافی را فقط در صورت میاز به تابع بدهند. می‌توانید از مقادیر پیش‌فرض برای اختیاری کردن یک آرگومان استفاده کنید.</p><p>به‌عنوان مثال، فرض کنید می‌خواهیم تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">get_formatted_name()</span><span class="rlm">‏</span> را توسعه دهیم تا نام میانی را نیز در نظر بگیرد. در اولین تلاش، تابع را به‌صورت زیر می‌نویسیم:</p><pre class="snippet" dir="ltr">def get_formatted_name(first_name, middle_name, last_name):
    """Return a full name, neatly formatted."""
    full_name = f"{first_name} {middle_name} {last_name}"
    return full_name.title()

musician = get_formatted_name('john', 'lee', 'hooker')
print(musician)</pre><a id="p139"></a><p>این تابع وقتی به آن نام، نام میانی، و نام خانوادگی داده شود، کار خود را انجام می‌دهد. تابع هر سه بخش نام را می‌گیرد و رشته‌ای از آن‌ها می‌سازد. در محل‌های مناسب اسپیس اضافه می‌کند و نام کامل را از نظر حروف کوچک و بزرگ به حالت عنوان تبدیل می‌کند:</p><pre class="snippet" dir="ltr">John Lee Hooker</pre><p>ولی نام میانی همیشه لازم نیست، و تابع به‌صورت فعلی اگر فقط با نام و نام خانوادگی فراخوانی شود، درست کار نمی‌کند. برای اینکه نام میانی اختیاری باشد، می‌توانیم یک مقدار خالی پیش‌فرض را به متغیر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">middle_name</span><span class="rlm">‏</span> اختصاص دهیم، و از این متغیر صرف‌نظر کنیم، مگر زمانی که کاربر به آن مقداری داده باشد. برای اینکه تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">get_formatted_name()</span><span class="rlm">‏</span> بدون نام میانی هم کار کند، باید مقدار پیش‌فرض <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">middle_name</span><span class="rlm">‏</span> را یک رشته‌ی خالی در نظر بگیریم، و آن را به انتهای پارامترها ببریم:</p><pre class="snippet" dir="ltr"><span class="n" dir="ltr">1</span>def get_formatted_name(first_name, last_name, middle_name=''):
    <span class="ash">"""Return a full name, neatly formatted."""</span>
<span class="n" dir="ltr">2</span>    if middle_name:
        full_name = f"{first_name} {middle_name} {last_name}"
<span class="n" dir="ltr">3</span>    else:
        full_name = f"{first_name} {last_name}"
    <span class="ash">return full_name.title()</span>

musician = get_formatted_name('jimi', 'hendrix')
print(musician)

<span class="n" dir="ltr">4</span>musician = get_formatted_name('john', 'hooker', 'lee')
<span class="ash">print(musician)</span></pre><p>در این مثال، نام شامل سه بخش ممکن است. از آنجا که نام و نام خانوادگی همیشه هست، لذا این پارامترها در تعریف تابع، اول درج شده‌اند. نام میانی اختیاری است، لذا در تعریف در پایان آمده است، و مقدار پیش‌فرض آن رشته‌ی خالی است <span class="n" dir="ltr">1</span>.</p><p>در بدنه‌ی تابع، اول وارسی می‌کنیم ببینیم نام میانی داده شده است یه نه. پایتون رشته‌های غیرخالی را به‌عنوان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">True</span><span class="rlm">‏</span> تفسیر می‌کند، بنابراین، در صورتی که آرگومان نام میانی در فراخوانی تابع داده شده باشد، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">if middle_name</span><span class="rlm">‏</span> به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">True</span><span class="rlm">‏</span> ارزیابی خواهد شد <span class="n" dir="ltr">2</span>. اگر نام میانی داده شده باشد، در آن صورت نام، نام میانی، و نام خانوادگی با هم ترکیب خواهند شد تا نام کامل به دست آید. سپس این نام از نظر حروف کوچک و بزرگ به حالت عنوان درآورده می‌شود و به سطر فراخوانی تابع برگردانده می‌شود، که در آنجا به متغیر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">musician</span><span class="rlm">‏</span> اختصاص داده شده و نمایش داده می‌شود. اگر نام میانی داده نشود، رشته‌ی خالی در ارزیابی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">if</span><span class="rlm">‏</span> تأیید نمی‌شود و بلئوک <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">else</span><span class="rlm">‏</span> در <span class="n" dir="ltr">3</span> اجرا می‌شود. در این حالت، نام کامل فقط از ترکیب نام و نام خانوادگی ساخته می‌شود، و نام فرمت شده به سطر فراخوانی کننده بازگردانده می‌شود و در آنجا به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">musician</span><span class="rlm">‏</span> اختصاص می‌یابد و نمایش داده می‌شود.</p><p>فراخوانی تابع با نام و نام خانوادگی به راحتی میسر است. ولی اگر بخواهیم نام میانی را هم در نظر بگیریم، باید حتماً آن را به‌عنوان آخرین آرگومان بدهیم، تا پایتون آرگومان‌های موقعیتی را درست انطباق بدهد <span class="n" dir="ltr">4</span>.</p><a id="p140"></a><p>نسخه‌ی تغییر یافته‌ی تابع ما هم برای افرادی که فقط نام و نام خانوادگی دارند، قابل استفاده است، و هم برای افرادی که نام میانی نیز دارند:</p><pre class="snippet" dir="ltr">Jimi Hendrix
John Lee Hooker</pre><p>مقادیر اختیاری امکان آن را فراهم می‌کند که تابع برای موارد وسیعی قابل استفاده باشد، و در عین حال، فراخوانی تابع تا حد امکان ساده بماند.</p></div><div class="sect" id="ch08lev2sec10"><h4>برگرداندن یک دیکشنری</h4>
<p class="noindent">تابع هر نوع مقداری که خواستید، می‌تواند برگرداند، از جمله ساختمان‌های داده‌ای پیچیده‌تری مانند لیست و دیکشنری. مثلاً تابع زیر یک نام را می‌گیرد و یک دیکشنری را که معرف یک شخص است، برمی‌گرداند:</p><div class="snippet-title" dir="ltr">person.py</div><pre class="snippet" dir="ltr">def build_person(first_name, last_name):
    """Return a dictionary of information about a person."""
<span class="n" dir="ltr">1</span>    person = {'first': first_name, 'last': last_name}
<span class="n" dir="ltr">2</span>    return person

musician = build_person('jimi', 'hendrix')
<span class="n" dir="ltr">3</span>print(musician)</pre><p>تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">build_person()</span><span class="rlm">‏</span> نام و نام خانوادگی را می‌گیرد، و در سطر <span class="n" dir="ltr">1</span>، این مقادیر را در یک دیکشنری قرار می‌دهد. مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">first_name</span><span class="rlm">‏</span> با کلید <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'first'</span><span class="rlm">‏</span> ذخیره می‌شود، و مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">last_name</span><span class="rlm">‏</span> با کلید <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'last'</span><span class="rlm">‏</span>. کل دیکشنری معرف شخص در <span class="n" dir="ltr">2</span> برگردانده می‌شود. مقدار برگشتی در <span class="n" dir="ltr">3</span> نمایش داده می‌شود، که در آن می‌بینیم که دو مقدار اولیه، اکنون در دیکشنری ذخیره شده است:</p><pre class="snippet" dir="ltr">{'first': 'jimi', 'last': 'hendrix'}</pre><p>این تابع اطلاعات متنی ساده را می‌گیرد و آن را به ساختار داده‌ای معنادارتری تبدیل می‌کند که با استفاده از آن می‌توانید فراتر از صرف نمایش دادن، با آن کار کنید. رشته‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'jimi'</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'hendrix'</span><span class="rlm">‏</span> حالا برچسب «نام» و «نام خانوادگی» دارند. به آسانی می‌توانید این تابع را گسترش دهید تا مقادیری اختیاری، مانند نام میانی، سن، شغل، یا هر اطلاعات دلخواه دیگری را درباره‌ی شخص بپذیرد. به‌عنوان مثال، تغییر زیر به شما امکان می‌دهد که سن شخص را نیز ذخیره کنید:</p><pre class="snippet" dir="ltr">def build_person(first_name, last_name, age=None):
    <span class="ash">"""Return a dictionary of information about a person."""</span>
    <span class="ash">person = {'first': first_name, 'last': last_name}</span>
    if age:
        person['age'] = age
    <span class="ash">return person</span>

musician = build_person('jimi', 'hendrix', age=27)
<span class="ash">print(musician)</span></pre><a id="p141"></a><p>یک پارامتر اختیاری دیگر به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">age</span><span class="rlm">‏</span> را به تعریف تابع اضافه می‌کنیم، و به این پارامتر، مقدار ویژه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">None</span><span class="rlm">‏</span> را اختصاص می‌دهیم، که زمانی استفاده می‌شود که هیچ مقدار خاصی به یک متغیر اختصاص داده نشده است. می‌توانید <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">None</span><span class="rlm">‏</span> را به‌عنوان یک جانگهدار در ذهنتان تصور کنید. در سنجش شرط، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">None</span><span class="rlm">‏</span> به‌عنوان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">False</span><span class="rlm">‏</span> ارزیابی می‌شود. اگر فراخوانی تابع حاوی مقداری برای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">age</span><span class="rlm">‏</span> باشد، آن مقدار در دیکشنری ذخیره می‌شود. این تابع نام شخص را همیشه ذخیره می‌کند، ولی می‌توان آن را تغییر داد که هر اطلاعات دیگری را نیز ذخیره کند.</p></div><div class="sect" id="ch08lev2sec11"><h4>استفاده از یک تابع با حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">while</span><span class="rlm">‏</span></h4>
<p class="noindent">می‌توانید از تابع در تمام ساختارهای پایتون که تا کنون یاد گرفته‌اید، استفاده کنید. برای نمونه، از تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">get_formatted_name()</span><span class="rlm">‏</span> در یک حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">while</span><span class="rlm">‏</span> استفاده می‌کنیم، تا به‌طور رسمی‌تری به کاربران خوشامد بگوییم. اولین تلاش ما برای خوشامدگویی به افراد با نام و نام خانوادگی آن‌ها به‌صورت زیر است:</p><div class="snippet-title" dir="ltr">greeter.py</div><pre class="snippet" dir="ltr"><span class="ash">def get_formatted_name(first_name, last_name):</span>
    <span class="ash">"""Return a full name, neatly formatted."""</span>
    <span class="ash">full_name = f"{first_name} {last_name}"</span>
    <span class="ash">return full_name.title()</span>

# This is an infinite loop!
while True:
<span class="n" dir="ltr">1</span>    print("\nPlease tell me your name:")
    f_name = input("First name: ")
    l_name = input("Last name: ")

    formatted_name = get_formatted_name(f_name, l_name)
    print(f"\nHello, {formatted_name}!")</pre><p>برای این مثال، از شکل ساده‌ای از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">get_formatted_name()</span><span class="rlm">‏</span> استفاده می‌کنیم که مشتمل بر نام میانی نیست. حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">while</span><span class="rlm">‏</span> از کاربر می‌خواهد که نامش را وارد کند، و نام و نام خانوادگی جداگانه پرسیده می‌شود <span class="n" dir="ltr">1</span>.</p><p>ولی این حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">while</span><span class="rlm">‏</span> یک مشکل دارد، و آن این است که شرط خروجی برای آن تعیین نکرده‌ایم. وقتی که یک سری ورودی را از کاربر می‌پرسید، شرط خروج را کجا می‌گذارید؟ می‌خواهیم که کاربر بتواند هرچه ساده‌تر از برنامه خارج شود، بنابراین، در هر بار پرسیدن، باید راهی برای خروج گذاشته شود. دستورالعمل <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">break</span><span class="rlm">‏</span> روش ساده‌ای را برای خروج از حلقه در هر بار پرسیدن فراهم می‌کند:</p><pre class="snippet" dir="ltr"><span class="ash">def get_formatted_name(first_name, last_name):</span>
    <span class="ash">"""Return a full name, neatly formatted."""</span>
    <span class="ash">full_name = f"{first_name} {last_name}"</span>
    <span class="ash">return full_name.title()</span>

<span class="ash">while True:</span>    <span class="ash">print("\nPlease tell me your name:")</span>
    print("(enter 'q' at any time to quit)")

    <span class="ash">f_name = input("First name: ")</span>
    if f_name == 'q':
        break

<a id="p142"></a>    <span class="ash">l_name = input("Last name: ")</span>
    if l_name == 'q':
        break

    <span class="ash">formatted_name = get_formatted_name(f_name, l_name)</span>
    <span class="ash">print(f"\nHello, {formatted_name}!")</span></pre><p>پیغامی اضافه می‌کنیم که به کاربر اطلاع می‌دهد که چگونه می‌تواند از برنامه خارج شود، و سپس در صورتی که کاربر در هر کدام از اعلان‌ها مقدار خروج را وارد کرد، حلقه را می‌شکنیم. اینکه برنامه همچنان به خوشامدگویی به افراد ادامه خواهد داد، تا آنکه کسی به جای نام یا نام خانوادگی خود، مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'q'</span><span class="rlm">‏</span> را وارد کند:</p><pre class="snippet" dir="ltr">Please tell me your name:
(enter 'q' at any time to quit)
First name: <span class="rlm">‏</span><span class="codestrong" dir="ltr">eric</span><span class="rlm">‏</span>
Last name: <span class="rlm">‏</span><span class="codestrong" dir="ltr">matthes</span><span class="rlm">‏</span>

Hello, Eric Matthes!

Please tell me your name:
(enter 'q' at any time to quit)
First name: <span class="rlm">‏</span><span class="codestrong" dir="ltr">q</span><span class="rlm">‏</span></pre><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<p class="tiy1"><span class="tiy" id="ch008_tiy006"><span class="tiy-num">۸-۶</span>. <span class="tiy-title">نام شهرها</span>: </span> تابعی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">city_country()</span><span class="rlm">‏</span> بنویسید که نام یک شهر و کشور آن را می‌گیرد. این تابع باید رشته‌ی فرمت‌شده‌ای به‌صورت زیر برگرداند:</p><pre class="snippet" dir="ltr">"Santiago, Chile"</pre><p>این تابع را لااقل با سه زوج شهر-کشور فراخوانی کنید، و مقادیری را که برگردانده می‌شود، نمایش دهید:</p><p class="tiy1"><span class="tiy" id="ch008_tiy007"><span class="tiy-num">۸-۷</span>. <span class="tiy-title">آلبوم</span>: </span> تابعی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">make_album()</span><span class="rlm">‏</span> بنویسید که یک دیکشنری برای توصیف یک آلبوم موسیقی ایجاد می‌کند. این تابع باید نام خواننده و عنوان آلبوم را بگیرد، و یک دیکشنری برگرداند که حاوی این دو عنوان است. با استفاده از این تابع، سه دیکشنری برای سه آلبوم متفاوت درست کنید. هر کدام از مقدارهای برگشتی را پرینت کنید تا معلوم شود که اطلاعات آلبوم به درستی ذخیره شده است.</p><p>با استفاده از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">None</span><span class="rlm">‏</span>، یک پارامتر اختیاری به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">make_album()</span><span class="rlm">‏</span> اضافه کنید که با آن بتوانید تعداد آهنگ‌های یک آلبوم را ذخیره کنید. اگر در فراخوانی تابع، مقداری برای تعداد آهنگ‌ها تعیین شده باشد، آن مقدار را به دیکشنری آلبوم اضافه کنید. لااقل یک بار دیگر تابع را فراخوانی کنید و در آن تعداد آهنگ‌های یک آلبوم را هم مشخص نمایید.</p><p class="tiy1"><span class="tiy" id="ch008_tiy008"><span class="tiy-num">۸-۸</span>. <span class="tiy-title">آلبوم‌های کاربر</span>: </span> با همان برنامه‌ی <span class="ref"><a href="c19-ch08.xhtml#ch008_tiy007">تمرین <span dir="ltr">۸-۷</span></a></span> شروع کنید. یک حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">while</span><span class="rlm">‏</span> بنویسید که به کاربران امکان می‌دهد که نام خواننده و عنوان آلبوم را وارد کنند. وقتی که این اطلاعات را گرفتید، تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">make_album()</span><span class="rlm">‏</span> را با ورودی کاربر فراخوانی کنید و دیکشنری ایجاد شده را نمایش دهید. یادتان باشد که یک مقدار خروج هم در حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">while</span><span class="rlm">‏</span> در نظر بگیرید.</p></div></div></div><div class="sect" id="ch08lev1sec4"><h3>دادن یک لیست به تابع</h3>
<a id="p143"></a><p class="noindent">خیلی وقت‌ها لازم است که یک لیست را به‌عنوان آرگومان به تابعی بدهید، مثلاً لیستی از نام‌ها یا اعداد، و یا اشیای پیچیده‌تر، مانند دیکشنری. وقتی که لیستی را به تابعی می‌دهید، تابع دسترسی مستقیم به محتویات لیست پیدا می‌کند. در اینجا از تابع برای کار کردن مؤثرتر با لیست‌ها استفاده می‌کنیم.</p><p>فرض کنید لیستی از کاربران داریم و می‌خواهیم یک پیام خوشامدگویی به هر کدام از آن‌ها نمایش دهیم. مثال زیر، لیستی از نام‌ها را به تابعی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">greet_users()</span><span class="rlm">‏</span> می‌دهد، و این تابع برای هر کدام از افراد موجود در لیست، پیام سلام نمایش می‌دهد:</p><div class="snippet-title" dir="ltr">greet_users.py</div><pre class="snippet" dir="ltr">def greet_users(names):
    """Print a simple greeting to each user in the list."""
    for name in names:
        msg = f"Hello, {name.title()}!"
        print(msg)

<span class="n" dir="ltr">1</span>usernames = ['hannah', 'ty', 'margot']
greet_users(usernames)</pre><p>تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">greet_users()</span><span class="rlm">‏</span> را به‌گونه‌ای تعریف می‌کنیم که نیاز به لیستی از نام‌ها دارد، و آن را به پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">names</span><span class="rlm">‏</span> اختصاص می‌دهد. تابع روی لیستی که دریافت می‌کند، حلقه تشکیل می‌دهد و برای هر کاربر، پیام سلام نمایش می‌دهد. در <span class="n" dir="ltr">1</span>، لیستی از کاربران را تعریف می‌کنیم و سپس لیست <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">usernames</span><span class="rlm">‏</span> را در فراخوانی تابع به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">greet_users()</span><span class="rlm">‏</span> می‌دهیم:</p><pre class="snippet" dir="ltr">Hello, Hannah!
Hello, Ty!
Hello, Margot!</pre><p>این همان خروجی‌ای است که می‌خواستیم. هر کاربر پیامی مخصوص به خود را می‌بیند، و شما می‌توانید تابع را هر چند بار که خواستید، برای خوشامدگویی به مجموعه‌ای از کاربران فراخوانی کنید.</p><div class="sect" id="ch08lev2sec12"><h4>تغییر دادن یک لیست در تابع</h4>
<p class="noindent">وقتی که لیستی را به تابعی می‌دهید، تابع می‌تواند آن لیست را تغییر دهد. هر تغییری که در داخل بدنه‌ی تابع در لیست داده شود، دائمی است، به‌طوری که حتی وقتی با مقادیر زیاد داده‌ها سر و کار دارید، می‌توانید به‌طور مؤثر با آن‌ها کار کنید.</p><p>شرکتی را در نظر بگیرید که برای طراحی‌هایی که کاربران تحویل می‌دهند، مدل‌های سه‌بعدی می‌سازد. طراحی‌هایی که باید چاپ شوند، در لیستی ذخیره می‌شوند، و پس از چاپ شدن به لیست دیگری منتقل می‌شوند. کد زیر این کار را بدون استفاده از تابع انجام می‌دهد:</p><div class="snippet-title" dir="ltr">printing_models.py</div><pre class="snippet" dir="ltr"># Start with some designs that need to be printed.
unprinted_designs = ['phone case', 'robot pendant', 'dodecahedron']
completed_models = []

# Simulate printing each design, until none are left.
#  Move each design to completed_models after printing.
while unprinted_designs:
    current_design = unprinted_designs.pop()
<a id="p144"></a>    print(f"Printing model: {current_design}")
    completed_models.append(current_design)

# Display all completed models.
print("\nThe following models have been printed:")
for completed_model in completed_models:
    print(completed_model)</pre><p>این برنامه در ابتدا لیستی از طراحی‌ها دارد که باید پرینت شود، و لیستی خالی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">completed_models</span><span class="rlm">‏</span> که هر کدام از طرح‌ها پس از چاپ به آن منتقل خواهد شد. مادام که طرح‌هایی در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">unprinted_designs</span><span class="rlm">‏</span> باقی مانده باشند، حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">while</span><span class="rlm">‏</span> فرایند چاپ طرح‌ها را شبیه‌سازی می‌کند، به این صورت که هر کدام از طرح‌ها را از انتهای لیست جدا می‌کند، آن را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">current_design</span><span class="rlm">‏</span> ذخیره می‌کند، و پیامی را نمایش می‌دهد حاکی از اینکه طرح کنونی در حال چاپ است. سپس آن طرح را به لیست مدل‌های تکمیل شده اضافه می‌کند. وقتی که اجرای حلقه به پایان رسید، لیستی از طرح‌های چاپ شده نمایش داده می‌شود:</p><pre class="snippet" dir="ltr">Printing model: dodecahedron
Printing model: robot pendant
Printing model: phone case

The following models have been printed:
dodecahedron
robot pendant
phone case</pre><p>می‌توانیم این کد را به طریق دیگری مرتب کنیم، به این صورت که دو تابع می‌نویسیم که هر کدام کار خاصی را انجام می‌دهد. بخش اعظم کد هیچ تغییری نمی‌کند؛  فقط می‌خواهیم ساختار دقیق‌تری به آن بدهیم. تابع اول کار چاپ طرح‌ها را انجام خواهد داد،  و تابع دوم خلاصه‌ای از طرح‌های چاپ شده را ارائه خواهد کرد:</p><pre class="snippet" dir="ltr"><span class="n" dir="ltr">1</span>def print_models(unprinted_designs, completed_models):
    """
    Simulate printing each design, until none are left.
    Move each design to completed_models after printing.
    """
    while unprinted_designs:
        current_design = unprinted_designs.pop()
        print(f"Printing model: {current_design}")
        completed_models.append(current_design)

<span class="n" dir="ltr">2</span>def show_completed_models(completed_models):
    """Show all the models that were printed."""
    print("\nThe following models have been printed:")
    for completed_model in completed_models:
        print(completed_model)

unprinted_designs = ['phone case', 'robot pendant', 'dodecahedron']
completed_models = []

print_models(unprinted_designs, completed_models)
show_completed_models(completed_models)</pre><a id="p145"></a><p>در <span class="n" dir="ltr">1</span>، تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">print_models()</span><span class="rlm">‏</span> را با دو پارامتر تعریف می‌کنیم: لیستی از طرح‌ها که باید چاپ شوند، و لیستی از مدل‌های کامل‌شده.  تابع با داشتن این دو لیست،  فرایند چاپ طرح‌ها را شبیه‌سازی می‌کند،  به این صورت که لیست طرح‌های چاپ‌نشده را خالی می‌کند و لیست مدل‌های تکمیل‌شده را پر می‌نماید . در <span class="n" dir="ltr">2</span>، تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">show_completed_models()</span><span class="rlm">‏</span> را با یک پارامتر،  یعنی لیست مدل‌های تکمیل‌شده، تعریف می‌کنیم.  تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">show_completed_models()</span><span class="rlm">‏</span> با داشتن این لیست، نام هر کدام از مدل‌های چاپ‌شده را نمایش می دهد.</p><p>خروجی این برنامه مانند همان نسخه‌ی قبلی برنامه است که فاقد تابع بود،  ولی در اینجا کد برنامه سازمان‌دهی بسیار بهتری دارد. کدی که قسمت عمده‌ی کار را انجام می دهد،  به دو تابع مجزا انتقال داده شده است،  که این کار سبب می‌شود که فهمیدن بخش اصلی برنامه آسان‌تر شود.  با نگاه کردن به بدنه‌ی برنامه،  خواهید دید که فهمیدن کاری که برنامه انجام می دهد،  بسیار آسان تر شده است: </p><pre class="snippet" dir="ltr">unprinted_designs = ['phone case', 'robot pendant', 'dodecahedron']
completed_models = []

print_models(unprinted_designs, completed_models)
show_completed_models(completed_models)</pre><p>لیستی از طرح‌های چاپ‌نشده و یک لیست خالی برای اضافه کردن مدل‌های تکمیل شده ایجاد می‌کنیم. سپس، از آنجا که دو تابع لازم را قبلاً تعریف کرده‌ایم، تنها کاری که باید بکنیم، این است که آن‌ها را با آرگومان‌های مناسب فراخوانی کنیم. تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">print_models()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم و دو لیستی را که نیاز دارد، به آن می‌دهیم؛ طبق انتظار؛ تابغ <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">print_models()</span><span class="rlm">‏</span> چاپ کردن طرح‌ها را شبیه‌سازی می‌کند. سپس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">show_completed_models()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم، و لیست مدل‌های کامل‌شده را به آن می‌دهیم تا گزارش آن‌ها را نمایش دهد. با توجه به گویا بودن نام توابع، دیگران می‌توانند کد را بخوانند، و حتی بدون هرگونه توضیحات، آن را بفهمند.</p><p>بسط دادن و نگهداری این برنامه راحت‌تر از نسخه‌ی قبلی بدون تابع آن است. اگر بعداً لازم باشد که طرح‌های بیشتری را چاپ کنیم، می‌توانیم به سادگی تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">print_models()</span><span class="rlm">‏</span> را یک بار دیگر فراخوانی کنیم. اگر متوجه شویم که کد مربوط به چاپ باید تغییر داده شود، می‌توانیم کد را یک بار تغییر دهیم، و و با این کار، تغییرات در تمام جاهایی که تابع فراخوانده شده است، اعمال خواهد شد. این تکنیک کارآمدتر از آن است که بخواهیم کد را در چندین جای برنامه اصلاح کنیم.</p><p>مطلب دیگری که از این مثال مشخص می‌شود، این است که هر تابع باید یک وظیفه‌ی خاص داشته باشد. تابع اول هر کدام از طرح‌ها را چاپ می‌کند، و تابع دوم مدل‌های تکمیل‌شده را نمایش می‌دهد. این روش مفیدتر از آن است که یک تابع هر دو کار را انجام دهد. اگر دید تابعی که نوشته‌اید، کارهای متفاوت زیادی انجام می‌دهد، سعی کنید کد آن را به دو تابع تقسیم کنید. یادتان باشد که همیشه می‌توانید یک تابع را از تابع دیگر فراخوانی کنید، م این می‌تواند در زمانی که کار پیچیده‌ای را به چند مرحله تقسیم می‌کنید، سودمند باشد.</p></div><div class="sect" id="ch08lev2sec13"><h4>جلوگیری از تغییر دادن یک لیست در تابع</h4>
<p class="noindent">بعضی وقت‌ها ممکن است بخواهید که مانع از آن شوید که یک تابع لیستی را تغییر دهد. مثلاً فرض کنید که در ابتدا لیستی از طرح‌های چاپ‌نشده دارید، و می‌خواهید مانند مثال قبل تابعی بنویسید که آن‌ها را به لیستی از مدل‌های تکمیل‌شده انتقال دهید. شاید بخواهید با وجود تمام شدن کار چاپ طرح‌ها، لیست اولیه‌ی طرح‌های چاپ‌نشده را برای حفظ سوابق، نگه دارید. <a id="p146"></a>ولی از آنجا که شما تمام طرح‌ها را از لیست <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">unprinted_designs</span><span class="rlm">‏</span> خارج کرده‌اید، اکنون این لیست خالی است، و فقط لیست خالی برای شما مانده است؛ لیست اصلی از بین رفته است. برای این منظور، می‌توانید به جای لیست اصلی، یک کپی از آن را به تابع بدهید. هرگونه تغییری که تابع در لیست بدهد، فقط در کپی اعمال خواهد شد، و لیست اصلی بدون تغییر باقی خواهد ماند.</p><p>برای اینکه یک کپی از لیست را به تابع بدهید، می‌توانید به این صورت عمل کنید:</p><pre class="snippet" dir="ltr"><span class="it">function_name</span>(<span class="it">list_name</span>[:])</pre><p>نماد قطعه <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">[:]</span><span class="rlm">‏</span> یک کپی از لیستی که می‌خواهید برای تابع بفرستید، می‌سازد. اگر در <span class="rlm">‏</span><span class="ident" dir="ltr">printing_models.py</span><span class="rlm">‏</span> می‌خواستیم که لیست طرح‌های چاپ‌نشده خالی نشود، می‌توانستیم <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">print_models()</span><span class="rlm">‏</span> را به‌صورت زیر فراخوانی کنیم:</p><pre class="snippet" dir="ltr">print_models(unprinted_designs[:], completed_models)</pre><p>تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">print_models()</span><span class="rlm">‏</span> می‌تواند کارش را انجام دهد، چرا که باز هم نام همه‌ی طرح‌های چاپ‌نشده را دریافت می‌کند. ولی این بار از یک کپی از لیست اصلی طرح‌های چاپ‌نشده استفاده می‌کند، نه لیست اصلی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">unprinted_designs</span><span class="rlm">‏</span>. لیست <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">completed_models</span><span class="rlm">‏</span> مانند قبل با نام مدل‌های چاپ‌شده پر خواهد شد، ولی لیست اصلی طرح‌های چاپ‌نشده بر اثر این تابع تغییری نخواهد کرد.</p><p>هر چند که می‌توانید با ساختن یک کپی از لیست و دادن آن به تابع،  محتویات لیست را حفظ کنید،  ولی باید سعی کنید لیست اصلی را به تابع‌ها بدهید مگر زمانی که به دلیل خاصی لازم باشد که یک کپی از آن تهیه کنید.  علت آن است که کار کردن تابع با لیست موجود کارایی بالاتری دارد، چرا که وقت و حافظه صرف ساختن کپی اضافی نمی‌شود،  به‌ویژه زمانی که با لیست‌های بزرگی سر و کار داشته باشید.</p><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<p class="tiy1"><span class="tiy" id="ch008_tiy009"><span class="tiy-num">۸-۹</span>. <span class="tiy-title">پیامک‌ها</span>: </span> لیستی حاوی یک سری پیامک تهیه کنید. این لیست را به تابعی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">show_messages()</span><span class="rlm">‏</span> بدهید، که آن‌ها را نمایش می‌دهد.</p><p class="tiy1"><span class="tiy" id="ch008_tiy010"><span class="tiy-num">۸-۱۰</span>. <span class="tiy-title">ارسال پیامک‌ها</span>: </span> از همان برنامه‌ی <span class="ref"><a href="c19-ch08.xhtml#ch008_tiy009">تمرین <span dir="ltr">۸-۹</span></a></span> شروع کنید. تابعی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">send_messages()</span><span class="rlm">‏</span> بنویسید که هر کدام از پیامک‌ها را نمایش می‌دهد و سپس آن را به لیست جدیدی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">sent_messages</span><span class="rlm">‏</span> منتقل می‌کند. پس از فراخوانی تابع، هر دو لیست را نمایش دهید تا معلوم شود که پیامک‌ها درست منتقل شده‌اند.</p><p class="tiy1"><span class="tiy" id="ch008_tiy011"><span class="tiy-num">۸-۱۱</span>. <span class="tiy-title">بایگانی پیامک‌ها</span>: </span> از همان برنامه‌ی <span class="ref"><a href="c19-ch08.xhtml#ch008_tiy010">تمرین <span dir="ltr">۸-۱۰</span></a></span> شروع کنید. تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">send_messages()</span><span class="rlm">‏</span> را با یک کپی از لیست پیامک‌ها فراخوانی کنید. پس از فراخوانی تابع، هر دو لیست را نمایش دهید تا معلوم شود که پیامک‌ها در لیست اصلی باقی مانده است.</p></div></div></div><div class="sect" id="ch08lev1sec5"><h3>دادن تعداد دلخواه آرگومان‌ها</h3>
<a id="p147"></a><p class="noindent">بعضی وقت‌ها شما از قبل نمی‌دانید که یک تابع باید چند آرگومان بگیرد.  خوشبختانه پایتون امکان آن را فراهم می‌کند که تابع در دستورالعمل فراخوانی،  به تعداد دلخواه آرگومان بگیرد.</p><p>به‌عنوان مثال، تابعی را در نظر بگیرید که پیتزا درست می‌کند. این تابع باید تعدادی چاشنی قبول کند،  ولی شما از قبل نمی‌دانید که مشتری چند چاشنی خواهد خواست.  تابع مثال زیر یک پارامتر به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">*toppings</span><span class="rlm">‏</span> دارد،  ولی این پارامتر هر تعداد آرگومان که در سطر فراخوانی آمده باشد، قبول می‌کند:</p><div class="snippet-title" dir="ltr">pizza.py</div><pre class="snippet" dir="ltr">def make_pizza(*toppings):
    """Print the list of toppings that have been requested."""
    print(toppings)

make_pizza('pepperoni')
make_pizza('mushrooms', 'green peppers', 'extra cheese')</pre><p>ستاره در نام پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">*toppings</span><span class="rlm">‏</span> به پایتون می‌گوید که یک تیوپل خالی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">toppings</span><span class="rlm">‏</span> ایجاد کند و تمام مقادیری را که دریافت می‌کند، داخل این تیوپل بریزد. خروجی فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">print()</span><span class="rlm">‏</span> در بدنه‌ی تابع نشان می‌دهد که پایتون هم زمانی که تابع با یک مقدار فراخوانی شده است و هم زمانی که با سه مقدار فراخوانی شده است، درست کار می‌کند. پایتون با این دو فراخوانی به‌صورت مشابهی برخورد می‌کند. دقت کنید که پایتون آرگومان‌ها را توی یک تیوپل قرار می‌دهد، ولو آنکه فقط یک مقدار دریافت کرده باشد:</p><pre class="snippet" dir="ltr">('pepperoni',)
('mushrooms', 'green peppers', 'extra cheese')</pre><p>اکنون می‌توانیم به جای فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">print()</span><span class="rlm">‏</span>، یک حلقه قرار دهیم که روی لیست چاشنی‌ها اجرا می‌شود و پیتزای سفارش داده شده را توصیف می‌کند:</p><pre class="snippet" dir="ltr"><span class="ash">def make_pizza(*toppings):</span>
    """Summarize the pizza we are about to make."""
    print("\nMaking a pizza with the following toppings:")
    for topping in toppings:
        print(f"- {topping}")

<span class="ash">make_pizza('pepperoni')</span>
<span class="ash">make_pizza('mushrooms', 'green peppers', 'extra cheese')</span></pre><p>تابع درست جواب می‌دهد، چه یک مقدار دریافت کند، چه سه مقدار:</p><pre class="snippet" dir="ltr">Making a pizza with the following toppings:
- pepperoni

Making a pizza with the following toppings:
- mushrooms
- green peppers
- extra cheese</pre><a id="p148"></a><p>این دستور نحوی صرف‌نظر از اینکه چند آرگومان به تابع داده شده باشد، درست عمل می‌کند.</p><div class="sect" id="ch08lev2sec14"><h4>مخلوط کردن آرگومان‌های موقعیتی و دلخواه</h4>
<p class="noindent">اگر می‌خواهید که یک تابع چندین نوع آرگومان متفاوت بگیرد، در آن صورت پارامتری که تعداد دلخواه آرگومان می‌گیرد، باید آخرین پارامتر در تعریف تابع باشد. پایتون ابتدا آرگومان‌های موقعیتی و کلیدواژه‌ی را در نظر می‌گیرد، و سپس آرگومان‌های باقیمانده را در پارامتر آخر قرار می‌دهد.</p><p>مثلاً اگر لازم باشد که تابع انداز‌ه‌ی پیتزا را هم بگیرد، این پارامتر باید قبل از پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">*toppings</span><span class="rlm">‏</span> بیاید:</p><pre class="snippet" dir="ltr">def make_pizza(size, *toppings):
    <span class="ash">"""Summarize the pizza we are about to make."""</span>
    print(f"\nMaking a {size}-inch pizza with the following toppings:")
    <span class="ash">for topping in toppings:</span>
        <span class="ash">print(f"- {topping}")</span>

make_pizza(16, 'pepperoni')
make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')</pre><p>در تعریف تابع، پایتون اولین مقداری را که دریافت می‌کند به پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">size</span><span class="rlm">‏</span> اختصاص  می‌دهد.  تمام مقادیر دیگری که بعد از آن می‌آیند، در تیوپل <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">toppings</span><span class="rlm">‏</span> ذخیره می‌شوند. در فراخوانی تابع، ابتدا آرگومان اندازه داده می‌شود و به دنبال آن چاشنی‌های لازم به تعداد دلخواه معین می‌شود.</p><p>حالا هر پیتزا دارای اندازه و تعدادی چاشنی است،  و هر کدام از این اطلاعات در محل مناسب نمایش داده می‌شود، به این صورت که ابتدا اندازه و به دنبال آن چاشنی‌ها پرینت می‌شود:</p><pre class="snippet" dir="ltr">Making a 16-inch pizza with the following toppings:
- pepperoni

Making a 12-inch pizza with the following toppings:
- mushrooms
- green peppers
- extra cheese</pre><div class="note"><h6 class="note-title">توجه</h6>
<p class="noindent">خیلی وقت‌ها از نام پارامتر عمومی  <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">*args</span><span class="rlm">‏</span> استفاده می‌شود که به تعداد دلخواه از این قبیل  آرگومان‌های موقعیتی می‌گیرد.</p></div></div><div class="sect" id="ch08lev2sec15"><h4>استفاده از آرگومان‌های کلیدواژه‌ای دلخواه</h4>
<p class="noindent">گاهی اوقات ممکن است بخواهید تعداد دلخواه آرگومان قبول کنید، ولی از قبل معلوم نباشد که چه نوع اطلاعاتی به تابع داده خواهد شد. در این حالت، می‌توانید توابعی بنویسید که در فراخوانی، به تعداد دلخواه زوج‌های کلید-مقدار قبول می‌کنند. یک نمونه‌ی آن مربوط به ساختن پروفایل کاربر است: می‌دانید که اطلاعاتی درباره‌ی کاربر خواهید گرفت، ولی دقیق نمی‌دانید چه نوع اطلاعاتی خواهد بود. تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">build_profile()</span><span class="rlm">‏</span> در <a id="p149"></a>مثال زیر همیشه نام و نام خانوادگی را می‌گیرد، ولی به تعداد دلخواه آرگومان‌های کلیدواژه‌ی نیز قبول می‌کند:</p><div class="snippet-title" dir="ltr">user_profile.py</div><pre class="snippet" dir="ltr">def build_profile(first, last, **user_info):
    """Build a dictionary containing everything we know about a user."""
<span class="n" dir="ltr">1</span>    user_info['first_name'] = first
    user_info['last_name'] = last
    return user_info

user_profile = build_profile('albert', 'einstein',
                             location='princeton',
                             field='physics')
print(user_profile)</pre><p>تعریف <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">build_profile()</span><span class="rlm">‏</span> به‌صورتی است که انتظار دریافت نام و نام خانوادگی را دارد، ولی علاوه بر آن، به تعداد دلخواه نیز زوج‌های نام-مقدار قبول می‌کند. وجود دو ستاره قبل از پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">**user_info</span><span class="rlm">‏</span> سبب می‌شود که پایتون یک دیکشنری خالی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">user_info</span><span class="rlm">‏</span> درست کند و هرگونه زوج نام-مقدار را که دریافت می‌کند، وارد این دیکشنری کند. با این تابع، می‌توانید درست مانند هر دیکشنری دیگری، به زوج‌های کلید-مقدار در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">user_info</span><span class="rlm">‏</span> دسترسی پیدا کنید.</p><p>در بدنه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">build_profile()</span><span class="rlm">‏</span>، نام و نام خانوادگی را نیز به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">user_info</span><span class="rlm">‏</span> اضافه می‌کنیم، چرا که این اطلاعات همیشه از کاربر دریافت می‌شود <span class="n" dir="ltr">1</span>، ولی هنوز داخل دیکشنری گذاشته نشده است. سپس دیکشنری <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">user_info</span><span class="rlm">‏</span> را به سطر فراخوانی‌کننده برمی‌گردانیم.</p><p>تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">build_profile()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم، و نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'albert'</span><span class="rlm">‏</span> و نام خانوادگی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'einstein'</span><span class="rlm">‏</span> را به همراه دو زوج کلید-مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">location='princeton'</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">field='physics'</span><span class="rlm">‏</span> به آن می‌دهیم. مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">profile</span><span class="rlm">‏</span> برگردانده شده را به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">user_profile</span><span class="rlm">‏</span> اختصاص می‌دهیم، و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">user_profile</span><span class="rlm">‏</span> را نمایش می‌دهیم:</p><pre class="snippet" dir="ltr">{'location': 'princeton', 'field': 'physics',
'first_name': 'albert', 'last_name': 'einstein'}</pre><p>دیکشنری برگردانده شده حاوی نام و نام خانوادگی کاربر است، و در این مورد، مکان و رشته‌ی کاربر نیز در آن گنجانده شده است. هر تعداد هم زوج کلید-مقدار دیگر در فراخوانی تابع داده شود، تابع کار خود را به درستی انجام خواهد داد.</p><p>شما می‌توانید در توابع‌تان مقادیر موقعیتی، کلیدواژه‌ای، و دلخواه را به طرق مختلف با هم ترکیب کنید. بد نیست تمام این انواع آرگومان را بشناسید، چون در برنامه‌های دیگران مکرراً شاهد استفاده از آن‌ها خواهید بود. مقداری تمرین لازم است تا یاد بگیرید از این انواع مختلف درست استفاده کنید و بدانید که هر نوع را در چه زمانی مورد استفاده قرار دهید. فعلاً یادتان باشد که از ساده‌ترین روشی که مؤثر باشد، برای انجام کار استفاده کنید. به تدریج که بیشتر پیشرفت می‌کنید، یاد خواهید گرفت که در هر مورد از مؤثرترین روش استفاده کنید.</p><div class="note"><h6 class="note-title">توجه</h6>
<p class="noindent">خیلی وقت‌ها خواهید دید که از نام پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">**kwargs</span><span class="rlm">‏</span> برای آرگومان‌های کلیدواژه‌ای عمومی استفاده می‌شود.</p></div><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<a id="p150"></a><p class="tiy1"><span class="tiy" id="ch008_tiy012"><span class="tiy-num">۸-۱۲</span>. <span class="tiy-title">ساندویچ</span>: </span> تابعی بنویسید که لیستی از چیزهایی را که مشتری توی ساندویچ خود می‌خواهد، قبول می‌کند. این تابع باید یک پارامتر داشته باشد که تمام آیتم‌هایی را که در تابع داده می‌شود، دریافت می‌کند، و باید گزارشی از ساندویچ مورد نظر را نمایش دهد. تابع را سه نوبت، هر بار با تعداد آرگومان متفاوتی، فراخوانی کنید.</p><p class="tiy1"><span class="tiy" id="ch008_tiy013"><span class="tiy-num">۸-۱۳</span>. <span class="tiy-title">پروفایل کاربر</span>: </span> ابتدا با یک کپی از همان برنامه‌ی <span class="rlm">‏</span><span class="ident" dir="ltr">user_profile.py</span><span class="rlm">‏</span> در <span class="ref"><a href="c19-ch08.xhtml#p149">صفحه‌ی <span>۱۴۹</span></a></span> شروع کنید. با فراخوانی تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">build_profile()</span><span class="rlm">‏</span>، پروفایلی برای خودتان بسازید، به این صورت که نام و نام خانوادگی و سه زوج کلید-مقدار دیگر در شرح خودتان به آن بدهید.</p><p class="tiy1"><span class="tiy" id="ch008_tiy014"><span class="tiy-num">۸-۱۴</span>. <span class="tiy-title">خودرو</span>: </span> تابعی بنویسید که اطلاعات مربوط به یک خودرو را در یک دیکشنری ذخیره می‌کند. این تابع باید همیشه نام سازنده و مدل ماشین را به عنوان آرگومان دریافت کند، و بعد از آن باید به تعداد دلخواه، آرگومان‌های کلیدواژه‌ای دریافت کند. تابع را با اطلاعات لازم و دو زوج نام-مقدار دیگر، مانند رنگ یا آپشن ماشین، فراخوانی کنید. تابع شما باید برای فراخوانی به‌صورت زیر قابل استفاده باشد:</p><pre class="snippet" dir="ltr">car = make_car('subaru', 'outback', color='blue', tow_package=True)</pre><p>دیکشنری برگردانده‌شده را نمایش دهید تا معلوم شود که اطلاعات به درستی ذخیره شده است.</p></div></div></div><div class="sect" id="ch08lev1sec6"><h3>ذخیره کردن توابع در مدول</h3>
<p class="noindent">یک مزیت توابع آن است که قطعاتی از کد شما را از برنامه‌ی اصلی جدا می‌کند. اگر به توابع خود نام‌های گویایی بدهید، فهمیدن برنامه‌ی اصلی بسیار آسان‌تر خواهد بود. یک قدم جلوتر این است که توابع خود را در فایل جداگانه‌ای به نام <span class="emphasis">مدول</span> ذخیره کنید و سپس مدل را به برنامه‌ی اصلی <span class="emphasis">وارد</span> کنید. دستورالعمل <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">import</span><span class="rlm">‏</span> به پایتون می‌گویند کد موجود در مدول را در دسترس فایل برنامه‌ی کنونی قرار دهد.</p><p>ذخیره کردن توابع در یک فایل جداگانه به شما امکان می‌دهد که جزئیات کد برنامه‌ی خود را مخفی کنید و روی منطق سطح بالاتر تمرکز نمایید. به‌علاوه، این امکان را فراهم می‌کند که از توابع خود در برنامه‌های مختلف استفاده‌ی مجدد کنید. وقتی که توابع را در فایل‌های جداگانه‌ای ذخیره می‌کنید، می‌توانید آن فایل‌ها را با برنامه‌نویسان دیگر به اشتراک بگذارید، بدون آنکه لازم باشد که تمام برنامه را در اختیار آنها قرار دهید. با دانستن نحوه‌ی ایمپورت کردن توابع، خواهید توانست از کتابخانه‌های تابع نیز که برنامه‌نویسان دیگر نوشته‌اند، استفاده کنید.</p><p>چندین راه برای وارد کردن یک مدول هست و در اینجا هر کدام از آنها را به اختصار برای شما توضیح خواهیم داد.</p><div class="sect" id="ch08lev2sec16"><h4>وارد کردن یک مدول کامل</h4>
<p class="noindent">برای وارد کردن توابع، ابتدا لازم است که یک مدول ایجاد کنیم. <span class="emphasis">مدول</span> فایلی است با پسوند <span class="rlm">‏</span><span class="ident" dir="ltr">.py</span><span class="rlm">‏</span> که حاوی کدی است که می‌خواهید آن را به <a id="p151"></a>برنامه‌ی خود وارد کنید. در اینجا، مدولی می‌سازیم که حاوی تابعی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">make_pizza()</span><span class="rlm">‏</span> است. برای ساختن این مدول، از برنامه‌ی <span class="rlm">‏</span><span class="ident" dir="ltr">pizza.py</span><span class="rlm">‏</span>، همه‌ی چیزها را غیر از تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">make_pizza()</span><span class="rlm">‏</span> حذف می‌کنیم:</p><div class="snippet-title" dir="ltr">pizza.py</div><pre class="snippet" dir="ltr">def make_pizza(size, *toppings):
    """Summarize the pizza we are about to make."""
    print(f"\nMaking a {size}-inch pizza with the following toppings:")
    for topping in toppings:
        print(f"- {topping}")</pre><p>حالا فایل دیگری به نام <span class="rlm">‏</span><span class="ident" dir="ltr">making_pizzas.py</span><span class="rlm">‏</span> در همان دایرکتوری که فایل <span class="rlm">‏</span><span class="ident" dir="ltr">pizza.py</span><span class="rlm">‏</span> قرار گرفته است، ایجاد می‌کنیم. این فایل مدولی را که درست کردیم، ایمپورت می‌کند، و سپس دو بار تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">make_pizza()</span><span class="rlm">‏</span> را فراخوانی می‌کند:</p><div class="snippet-title" dir="ltr">making_pizzas.py</div><pre class="snippet" dir="ltr">import pizza

<span class="n" dir="ltr">1</span>pizza.make_pizza(16, 'pepperoni')
pizza.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')</pre><p>وقتی که پایتون این فایل را می‌خواند، سطر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">import pizza</span><span class="rlm">‏</span> به پایتون می‌گوید که فایل <span class="rlm">‏</span><span class="ident" dir="ltr">pizza.py</span><span class="rlm">‏</span> را ایمپورت کند و تمام توابع موجود در آن را به داخل این برنامه کپی نماید. البته شما خودتان کپی شدن کد به این فایل را مشاهده نمی‌کنید، زیرا پایتون کد را پشت صحنه درست قبل از اجرا کردن برنامه کپی می‌کند. تنها چیزی که باید بدانید، این است که هرگونه تابعی که در <span class="rlm">‏</span><span class="ident" dir="ltr">pizza.py</span><span class="rlm">‏</span> تعریف شده باشد، اکنون در برنامه‌ی <span class="rlm">‏</span><span class="ident" dir="ltr">making_pizzas.py</span><span class="rlm">‏</span> در دسترس است.</p><p>برای فراخواندن یک تابع از یک مدول وارد شده، نام مدولی را که وارد کرده اید، یعنی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">pizza</span><span class="rlm">‏</span>، و به دنبال آن نام تابع، یعنی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">make_pizza()</span><span class="rlm">‏</span>،  را بنویسید، و بین آنها یک نقطه قرار دهید <span class="n" dir="ltr">1</span>. این کد همان خروجی برنامه‌ی اصلی را ایجاد می‌کند که در آن از وارد کردن مدول استفاده نشده بود.</p><pre class="snippet" dir="ltr">Making a 16-inch pizza with the following toppings:
- pepperoni

Making a 12-inch pizza with the following toppings:
- mushrooms
- green peppers
- extra cheese</pre><p>روش اول برای ایمپرت کردن که در آن کلمه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">import</span><span class="rlm">‏</span> را می‌نویسید و به دنبال آن نام مدول را می‌آورید، سبب می‌شود که هر کدام از توابع مدول در برنامه‌ی شما در دسترس قرار گیرد. اگر از این نوع دستورالعمل <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">import</span><span class="rlm">‏</span> برای وارد کردن تمام مدول <span class="rlm">‏</span><span class="ident" dir="ltr">module_name.py</span><span class="rlm">‏</span> استفاده کنید، در این صورت هر تابعی که در این مدول موجود است، از طریق دستور نحوی زیر قابل دسترس خواهد بود:</p><pre class="snippet" dir="ltr"><span class="it">module_name.function_name</span>()</pre></div><div class="sect" id="ch08lev2sec17"><h4>ایمپورت کردن یک تابع خاص</h4>
<a id="p152"></a><p class="noindent">کار دیگری که می‌توانید بکنید، این است که یک تابع خاص را از یک مدول وارد کنید. دستور نحوی عمومی برای این روش به‌صورت زیر است:</p><pre class="snippet" dir="ltr">from <span class="it">module_name</span> import <span class="it">function_name</span></pre><p>می‌توانید از یک مدول هر تعداد تابع را خواستید، ایمپورت کنید؛ برای این منظور، باید نام توابع را با کاما از هم جدا کنید:</p><pre class="snippet" dir="ltr">from <span class="it">module_name</span> import <span class="it">function_0</span>, <span class="it">function_1</span>, <span class="it">function_2</span></pre><p>در مثال <span class="rlm">‏</span><span class="ident" dir="ltr">making_pizzas.py</span><span class="rlm">‏</span>، اگر بخواهیم فقط تابعی را که لازم داریم وارد کنیم، می‌توانیم به‌صورت زیر بنویسیم:</p><pre class="snippet" dir="ltr">from pizza import make_pizza

make_pizza(16, 'pepperoni')
make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')</pre><p>با این دستور نحوی، وقتی تابعی را فراخوانی می‌کنید، نیازی نیست که از نماد نقطه استفاده کنید. از آنجا که تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">make_pizza()</span><span class="rlm">‏</span> را به صراحت در دستورالعمل <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">import</span><span class="rlm">‏</span> وارد کرده‌ایم، می‌توانیم برای استفاده آن را با نام خودش فراخوانی کنیم:</p></div><div class="sect" id="ch08lev2sec18"><h4>استفاده از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">as</span><span class="rlm">‏</span> برای دادن نام مستعار به تابع</h4>
<p class="noindent">اگر نام تابعی که می‌خواهید وارد کنید، با یک نام موجود در برنامه‌ی شما تداخل داشته باشند یا اینکه نام تابع طولانی باشد، می‌توانید از یک <span class="emphasis">نام مستعار</span> منحصر به فرد و کوتاه استفاده کنید، یعنی برای تابع مورد نظر، یک نام جایگزین یا لقب در نظر بگیرید. این لقب ویژه در هنگام وارد کردن تابع به آن داده می‌شود.</p><p>در اینجا، برای تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">make_pizza()</span><span class="rlm">‏</span> نام مستعار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">mp()</span><span class="rlm">‏</span> در نظر می‌گیریم، یعنی آن به‌صورت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">make_pizza as mp</span><span class="rlm">‏</span> ایمپورت می‌کنیم. کلیدواژه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">as</span><span class="rlm">‏</span>، نام مستعار داده شده را به تابع مورد نظر می‌دهد:</p><pre class="snippet" dir="ltr">from pizza import make_pizza as mp

mp(16, 'pepperoni')
mp(12, 'mushrooms', 'green peppers', 'extra cheese')</pre><p>دستورالعمل <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">import</span><span class="rlm">‏</span> در این مثال، نام تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">make_pizza()</span><span class="rlm">‏</span> را در این برنامه به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">mp()</span><span class="rlm">‏</span> تغییر می‌دهد. هر گاه بخواهیم تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">make_pizza()</span><span class="rlm">‏</span> را فراخوانی کنیم، به جای آن <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">mp()</span><span class="rlm">‏</span> می‌نویسیم، و پایتون کد مربوط به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">make_pizza()</span><span class="rlm">‏</span> را اجرا خواهد کرد، بدون آنکه اگر تابع دیگری با نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">make_pizza()</span><span class="rlm">‏</span> در این فایل برنامه تعریف شده باشد، تداخلی با آن پیدا کند.</p><p>دستور نحوی عمومی برای دادن نام مستعار به‌صورت زیر است:</p><pre class="snippet" dir="ltr">from <span class="it">module_name</span>
import <span class="it">function_name</span>
as <span class="it">fn</span></pre></div><div class="sect" id="ch08lev2sec19"><h4>استفاده از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">as</span><span class="rlm">‏</span> برای دادن نام مستعار به تابع</h4>
<a id="p153"></a><p class="noindent">برای نام مدول هم می‌توانید نام مستعار در نظر بگیرید. وقتی نام مستعار کوتاهی به یک مدول بدهید، مثلاً <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">p</span><span class="rlm">‏</span> برای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">pizza</span><span class="rlm">‏</span>، خواهید توانست توابع مدول را سریع‌تر فراخوانی کنید. مثلاً تایپ کردن <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">p.make_pizza()</span><span class="rlm">‏</span> کوتاه‌تر از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">pizza.make_pizza()</span><span class="rlm">‏</span> است:</p><pre class="snippet" dir="ltr">import pizza as p

p.make_pizza(16, 'pepperoni')
p.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')</pre><p>در دستورالعمل <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">import</span><span class="rlm">‏</span>، به مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">pizza</span><span class="rlm">‏</span> نام مستعار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">p</span><span class="rlm">‏</span> داده شده است، ولی تمام توابع موجود در مدول نام اصلی خود را حفظ می‌کنند. وقتی که توابع را به‌صورت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">p.make_pizza()</span><span class="rlm">‏</span> فراخوانی کنید، نه تنها از نوشتن <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">pizza.make_pizza()</span><span class="rlm">‏</span> کوتاه‌تر است، بلکه سبب می‌شود که توجه شما از نام مدول جدا شود و بتوانید بیشتر روی نام گویای توابع آن تمرکز کنید. نام این توابع، که به روشنی معرف عملکرد تابع هستند، برای خوانا بودن کد شما بیشتر اهمیت دارند، تا نوشتن نام کامل مدول.</p><p>دستور نحوی عمومی این روش به‌صورت زیر است:</p><pre class="snippet" dir="ltr">import <span class="it">module_name</span> as <span class="it">mn</span></pre></div><div class="sect" id="ch08lev2sec20"><h4>وارد کردن تمام توابع یک مدول</h4>
<p class="noindent">می‌توانید با استفاده از عملگر ستاره (<span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">*</span><span class="rlm">‏</span>) به پایتون بگویید که تمام توابع موود در مدول را وارد کند:</p><pre class="snippet" dir="ltr">from pizza import *

make_pizza(16, 'pepperoni')
make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')</pre><p>ستاره در دستورالعمل <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">import</span><span class="rlm">‏</span> به پایتون می‌گوید که تمام توابع موجود در مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">pizza</span><span class="rlm">‏</span> را به داخل این فایل برنامه کپی کند. از آنجا که تمام توابع مدول ایمپورت شده‌اند، لذا می‌توانید آن‌ها را با نام خودشان بدون استفاده از نماد نقطه فراخوانی کنید. اما بهتر است هنگام استفاده از مدول‌های بزرگ‌تری که خودتان ننوشته‌اید، از این روش استفاده نکنید: اگر نام یکی از توابع مدول با یک نام موجود در پروژه‌ی شما یکسان باشد، ممکن است نتایج غیرمنتظره‌ای حاصل شود. وقتی چند تابع یا متغیر با نام یکسان وجود داشته باشد، پایتون به جای اینکه همه‌ی این توابع را جداگانه وارد کند، آن‌ها را جایگزین خواهد کرد.</p><p>بهترین رویکرد آن است که فقط تابع یا توابعی را که نیاز دارید، وارد کنید، یا اینکه تمام مدول را وارد کنید و از نماد نقطه استفاده کنید. این روش منجر به کد واضح و گویایی می‌شود که همه می‌توانند به آسانی آن را بفهمند. هدف از بیان این قسمت این بود که وقتی دستورالعمل <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">import</span><span class="rlm">‏</span> مانند نمونه‌ی زیر در کد دیگران می‌بینید، با آن آشنا باشید:</p><pre class="snippet" dir="ltr">from <span class="it">module_name</span> import *</pre></div></div><div class="sect" id="ch08lev1sec7"><h3>سبک نوشتن توابع</h3>
<a id="p154"></a><p class="noindent">در نوشتن توابع، لازم است که برخی نکات را در نظر داشته باشید. توابع باید نام‌های گویایی داشته باشند، و این نام باید با حروف کوچک باشد و بین کلمات، از زیرخط (<span class="rlm">‏</span><span class="lr" dir="ltr">underscore</span><span class="rlm">‏</span>) استفاده شود. دادن نام گویا و روشن به توابع سبب می‌شود که هر کس کد شما را می‌خواند، بتواند به سادگی بفهمد که تابع چه کاری انجام می‌دهد. نام مدول‌ها نیز باید بر اساس همین قراردادها تعیین شود.</p><p>هر تابع باید توضیحی داشته باشد که به اختصار بیان می‌کند که تابع چه کاری انجام می‌دهد. این توضیح باید بلافاصله بعد از تعریف تابع قرار گیرد، و باید با فرمت داک‌استرینگ نوشته شود. وقتی که از این روش استفاده شود، برنامه‌نویسان دیگر می‌توانند با خواندن توصیف ارائه شده در این توضیح، از تابع استفاده کنند. آن‌ها باید بتوانند اعتماد کنند که کد تابع همان کاری را که گفته شده، انجام می‌دهد، و مادام که نام تابع، آرگومان‌های مورد نیاز، و مقدار برگشتی آن را بدانند، خواهند توانست در برنامه‌های خود از آن استفاده کنند.</p><p>در صورتی که بخواهید برای پارامتر مقدار پیش‌فرض ارائه دهید، نباید در دو طرف علامت تساوی هیچ‌گونه فضای سفید قرار دهید:</p><pre class="snippet" dir="ltr">def <span class="it">function_name</span>(<span class="it">parameter_0</span>, <span class="it">parameter_1</span>='<span class="it">default value</span>')</pre><p>در مورد آرگومان‌های کلیدواژه‌ای در فراخوانی تابع نیز باید به همین صورت عمل کنید:</p><pre class="snippet" dir="ltr"><span class="it">function_name</span>(<span class="it">value_0</span>, <span class="it">parameter_1</span>='<span class="it">value</span>')</pre><p>در <span class="rlm">‏</span><span class="lr" dir="ltr">PEP 8</span><span class="rlm">‏</span> (<span class="rlm">‏</span><a dir="ltr" target="_blank" href="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</a><span class="rlm">‏</span>) توصیه شده است که پهنای سطرهای کد را به ۷۹ کاراکتر محدود کنید، تا آنکه تمام سطرهای کد در پنجره‌ی نمایشگرهای معمولی قابل مشاهده باشد. اگر مجموعه‌ی پارامترها به‌گونه‌ای باشد که طول سطر تعریف تابع بیشتر از ۷۹ کاراکتر شود، در آن صورت پس از باز کردن پرانتز در تعریف تابع، کلید <span class="rlm">‏</span><span class="key" dir="ltr">enter</span><span class="rlm">‏</span> را بزنید.در سطر بعد، کلید <span class="rlm">‏</span><span class="key" dir="ltr">tab</span><span class="rlm">‏</span> را دو بار بزنید تا لیست آرگومان‌ها را از بدنه‌ی تابع که فقط یک سطح تورفتگی دارد، جدا کنید.</p><p>اکثر ویرایشگرها سطرهای بعدی پارامترها را به‌طور خودکار مطابق با سطر اول تورفتگی می‌دهند:</p><pre class="snippet" dir="ltr">def <span class="it">function_name</span>(
        <span class="it">parameter_0</span>, <span class="it">parameter_1</span>, <span class="it">parameter_2</span>,
        <span class="it">parameter_3</span>, <span class="it">parameter_4</span>, <span class="it">parameter_5</span>):
    <span class="it">function body...</span></pre><p>اگر برنامه‌ی شما بیشتر از یک تابع دارد، می‌توانید هر کدام از آن‌ها را با دو سطر خالی از دیگری جدا کنید تا معلوم باشد که کجا یک تابع تمام می‌شود و تابع بعدی شروع می‌شود.</p><p>تمام دستورالعمل‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">import</span><span class="rlm">‏</span> باید در ابتدای فایل نوشته شود. تنها استثنای آن زمانی است که در ابتدای برنامه توضیحاتی در تشریح عملکرد کلی برنامه گذاشته باشید.</p><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<a id="p155"></a><p class="tiy1"><span class="tiy" id="ch008_tiy015"><span class="tiy-num">۸-۱۵</span>. <span class="tiy-title">پرینت کردن طرح‌ها</span>: </span> توابع مثال <span class="rlm">‏</span><span class="ident" dir="ltr">printing_models.py</span><span class="rlm">‏</span> را در فایل جداگانه‌ای به نام <span class="rlm">‏</span><span class="ident" dir="ltr">printing_functions.py</span><span class="rlm">‏</span> قرار دهید. یک دستورالعمل <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">import</span><span class="rlm">‏</span> در بالای <span class="rlm">‏</span><span class="ident" dir="ltr">printing_models.py</span><span class="rlm">‏</span> بنویسید و فایل را تغییر دهید تا از توابع ایمپورت شده استفاده کند.</p><p class="tiy1"><span class="tiy" id="ch008_tiy016"><span class="tiy-num">۸-۱۶</span>. <span class="tiy-title">ایمپورت</span>: </span> از یکی از برنامه‌های خودتان که یک تابع داشته باشد، استفاده کنید. آن تابع را در فایل جداگانه‌ای قرار دهید. تاب را به برنامه‌ی اصلی ایمپورت کنید، و آن تابع را با هر کدام از رویکردهای زیر فراخوانی کنید:</p><pre class="snippet" dir="ltr">import <span class="it">module_name</span>
from <span class="it">module_name</span> import <span class="it">function_name</span>
from <span class="it">module_name</span> import <span class="it">function_name</span> as <span class="it">fn</span>
import <span class="it">module_name</span> as <span class="it">mn</span>
from <span class="it">module_name</span> import *</pre><p class="tiy1"><span class="tiy" id="ch008_tiy017"><span class="tiy-num">۸-۱۷</span>. <span class="tiy-title">سبک نوشتن توابع</span>: </span> سه تا از برنامه‌هایی را که برای این فصل نوشته‌اید، انتخاب کنید، و وارسی کنید که دستورالعمل‌های سبک کدنویسی که در این قسمت شرح داده شد، در آن‌ها رعایت شده باشد.</p></div></div><div class="sect" id="ch08lev1sec8"><h3>خلاصه</h3>
<p class="noindent">در این فصل، نوشتن تابع را یاد گرفتید و فهمیدید که چگونه به تابع خود آرگومان‌هایی بدهید تا به اطلاعات لازم دسترسی داشته باشد. نحوه‌ی استفاده از آرگومان‌های موقعیتی و کلیدواژه‌ای و نیز نحوه‌ی دادن تعداد دلخواه آرگومان را نیز یاد گرفتید. دیدید که برخی توابع خروجی نمایش می‌دهند و برخی دیگر مقادیری را برمی‌گردانند. نحوه‌ی استفاده از لیست، دیکشنری، دستورالعمل <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">if</span><span class="rlm">‏</span>، و حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">while</span><span class="rlm">‏</span> را در ارتباط با توابع یاد گرفتید. هم‌چنین، فراگرفتید که چگونه توابع را در فایل‌های جداگانه‌ای به نام <span class="emphasis">مدول</span> ذخیره کنید، تا فایل‌های برنامه‌تان ساده‌تر باشند و فهم آن‌ها آسان‌تر باشد. و سرانجام اینکه سبک نوشتن صحیح توابع را یاد گرفتید، به‌طوری که برنامه‌ی شما ساختار مناسبی داشته و خواندن آن برای خودتان و دیگران هرچه آسان‌تر باشد.</p><p>یکی از اهداف شما به‌عنوان برنامه‌نویس باید این باشد که کد ساده‌ای بنویسید که کاری را که می‌خواهید، انجام دهد، و توابع در این کار به شما کمک می‌کند. با استفاده از توابع می‌توانید بلوک کدی بنویسید و بعد که دیدید درست کار می‌کند، آن را به حال خود بگذارید.وک می‌دانید تابعی درست کار می‌کند، می‌توانید مطمئن باشید که بعداً هم درست کار خواهد کرد و لذا می‌توانید به سراغ بقیه‌ی کار کدنویسی خود بروید.</p><p>با استفاده از توابع، می‌توانید یک بار کدنویسی کنید و بعد بارها از آن کد استفاده‌ی مجدد به عمل آورید. وقتی که نیاز به اجرای کد درون تابع دارید، کافی است یک فراخوانی یک‌سطری بنویسید، تا تابع کارش را انجام دهد. وقتی که لازم است که رفتار تابعی را تغییر دهید، کافی است بلوک کد آن را تغییر دهید، و با این کار، آن تغییر در تمام جاهایی که تابع را فراخوانی کرده‌اید، اعمال خواهد شد.</p><p>استفاده از تابع سبب می‌شود که برنامه‌ی شما راحت‌تر قابل خواندن باشد، و با انتخاب نام‌های خوب برای توابع، مشخص می‌شود که هر قسمت از برنامه‌ی شما چه کاری انجام می‌دهد. در صورتی که یک سری فراخوانی تابع را بخوانید، سریع‌تر متوجه می‌شوید که برنامه چه کاری انجام می‌دهد، تا اینکه بخواهید چندین بلوک طولانی کد را بخوانید.</p><a id="p156"></a><p>علاوه بر این، استفاده از توابع سبب می‌شود که آزمایش کردن و اشکال‌زدایی برنامه نیز آسان‌تر باشد. وقتی که قسمت عمده‌ی کار برنامه‌ی شما در مجموعه‌ای از توابع صورت می‌گیرد که هر کدام از آن‌ها کار خاصی را انجام می‌دهد، در آن صورت آزمایش کردن و اصلاح کردن کد شما بسیار راحت‌تر خواهد بود. می‌توانید برنامه‌ی جداگانه‌ای بنویسید که هر کدام از توابع را فراخوانی می‌کند، و آزمایش می‌کند که آیا هر تابع در تمام موقعیت‌هایی که برخورد می‌کند، درست کار می‌کند یا خیر. وقتی که این کار را کردید، می‌توانید مطمئن باشید که توابع شما هر بار که آن‌ها را فراخوانی می‌کنید، درست کار خواهند کرد.</p><p>در <span class="ref"><a href="c20-ch09.xhtml">فصل ۹</a></span>، نحوه‌ی نوشتن کلاس را یاد خواهید گرفت. <span class="emphasis">کلاس</span> مانند نوعی بسته‌بندی مرتب است که توابع و داده‌ها را با هم ترکیب می‌کند، و می‌توان به‌صورتی انعطاف‌پذیر و کارآمد از آن استفاده کرد.</p></div></article>
				<div class="row pager"><div class="col-md-5 text-center text-md-left pager-prev"><a href="c18-ch07.xhtml"><span xmlns="http://www.w3.org/1999/xhtml"><span>فصل ۷</span>: <span>ورودی کاربر و حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">while</span><span class="rlm">‏</span></span></span></a></div><div class="col-md-2 text-center pager-title"><a href="c01-cover.xhtml">آغاز</a></div><div class="col-md-5 text-center text-md-right pager-next"><a href="c20-ch09.xhtml"><span xmlns="http://www.w3.org/1999/xhtml"><span>فصل ۹</span>: <span>کلاس</span></span></a></div></div></main><aside class="col-md-2 order-md-first"><ul class="nav nav-pills flex-column"><li class="nav-item"><a class="nav-link" href="../">دوره‌ی فشرده‌ی پایتون</a></li><li class="nav-item"><a class="nav-link" href="c06-toc.xhtml">فهرست</a></li></ul></aside></div></div><div class="container"><div id="footer" class="row"><div class="col-sm-6"><p><span>© ۱۴۰۰، قاسم کیانی مقدم.</span></p></div><div class="col-sm-6"><p class="text-right"><span><a target="_blank" rel="me" href="https://linkedin.com/in/ghasemkiani" title="لینکدین"><span class="fab fa-linkedin"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://github.com/ghasemkiani" title="گیت‌هاب"><span class="fab fa-github"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://twitter.com/ghasemkiani" title="توئیتر"><span class="fab fa-twitter"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://facebook.com/ghasemkiani" title="فیس‌بوک"><span class="fab fa-facebook"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://telegram.me/ghasemkiani" title="تلگرام"><span class="fab fa-telegram"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://instagram.com/ghasem.kiani" title="اینستاگرام"><span class="fab fa-instagram"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://mastodon.social/@ghasemkiani" title="ماستودون"><span class="fab fa-mastodon"></span></a></span></p></div></div></div><script crossorigin="anonymous" src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"></script><script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut"></script><script crossorigin="anonymous" src="https://cdn.rtlcss.com/bootstrap/v4.0.0/js/bootstrap.min.js" integrity="sha384-54+cucJ4QbVb99v8dcttx/0JRx4FHMmhOWi4W+xrXpKcsKQodCBwAvu3xxkZAwsH"></script><script src="https://www.googletagmanager.com/gtag/js?id=UA-135468998-1"></script><script src="data:application/javascript;charset=UTF-8;base64,KCh7aWR9KSA9PiB7Cgl3aW5kb3cuZGF0YUxheWVyID0gd2luZG93LmRhdGFMYXllciB8fCBbXTsKCWZ1bmN0aW9uIGd0YWcoKXtkYXRhTGF5ZXIucHVzaChhcmd1bWVudHMpO30KCWd0YWcoImpzIiwgbmV3IERhdGUoKSk7CgoJZ3RhZygiY29uZmlnIiwgaWQpOwp9KSh7ImlkIjoiVUEtMTM1NDY4OTk4LTEifSk7Cg=="></script></body></html>