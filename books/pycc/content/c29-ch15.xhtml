<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="fa" dir="rtl"><head><meta charset="utf-8"/><title>تولید داده‌ها</title><meta name="description" content="وب‌سایت قاسم کیانی مقدم"/><meta name="keywords" content="قاسم کیانی مقدم, وب‌سایت, وب‌سایت قاسم کیانی مقدم, کتاب, فارسی, کتاب فارسی, ترجمه, برنامه‌نویسی, جاوا, جاوا اسکریپت, پزشکی, طب اطفال"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="stylesheet" crossorigin="anonymous" href="https://cdn.rtlcss.com/bootstrap/v4.0.0/css/bootstrap.min.css" integrity="sha384-P4uhUIGk/q1gaD/NdgkBIl3a6QywJjlsFJFk7SPRdruoGddvRVSwv5qFnvZ73cpz"/><link rel="stylesheet" crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.7.1/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr"/><link rel="icon" href="../../../favicon.ico"/><style>@import url(https://fonts.googleapis.com/css?family=Droid+Sans);
@import url(https://fonts.googleapis.com/css?family=Droid+Serif);
@import url(https://fonts.googleapis.com/css?family=Droid+Arabic+Kufi);
@import url(https://fonts.googleapis.com/css?family=Droid+Arabic+Naskh);
html,body,input,textarea,select,option,h1,h2,h3,h4,h5,h6{font-family:Droid Arabic Naskh,Droid Serif;}
nav,.nav{font-family:Droid Arabic Kufi,Droid Sans;}
h1,h2,h3,h4,h5,h6{font-family:Droid Arabic Naskh,Droid Serif;}
#footer{margin-top:0.5rem;padding-top:0.5rem;border-top:#eeeeee solid thick;}</style><style>@import url(https://fonts.googleapis.com/css?family=Courier+Prime);
div.row.pager{margin-top:0.5em;padding:0.5em 0;border-top:solid #cccccc 2px;background-color:#dddddd;}
div.pager-prev{}
div.pager-title{}
div.pager-next{}</style><link rel="stylesheet" type="text/css" href="styles.css"/></head><body style="min-height:75rem;"><nav class="navbar navbar-expand-md navbar-dark bg-dark mb-4"><div class="container"><a class="navbar-brand" href="../../../">وب‌سایت قاسم کیانی مقدم</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#divNavBarToggle" aria-controls="divNavBarToggle" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div id="divNavBarToggle" class="collapse navbar-collapse"><ul class="navbar-nav mr-auto"><li class="nav-item active"><a class="nav-link" href="../../">کتاب‌ها<span class="sr-only"> (current)</span></a></li><li class="nav-item"><a class="nav-link" href="../../../essays/">مقالات</a></li><li class="nav-item"><a class="nav-link" href="../../../translation/">ترجمه</a></li><li class="nav-item"><a class="nav-link" href="../../../about/">درباره</a></li><li class="nav-item"><a class="nav-link" href="../../../contact/">تماس</a></li></ul></div></div></nav><div class="container"><div class="row"><main class="col-md-10 order-md-last">
							<div class="ch" id="ch15"><h2 class="ch-title"><a class="bkmk" name="ch15"></a><a class="rtoc" href="c06-toc.xhtml"><span class="ch-title-num">۱۵</span><br/><span class="ch-title-text">تولید داده‌ها</span></a></h2><img style="float:right;margin-left:0.5em;margin-bottom:0.25em;" alt="تصویر ابتدای فصل" src="images/ch.svg"/>
<a id="p305"></a><p class="noindent"><span class="emphasis">مصورسازی داده‌ها</span> به معنای کاوش داده‌ها از طریق نمایش بصری است. این کار ارتباط نزدیکی با <span class="emphasis">تحلیل داده‌ها</span> دارد، که در آن الگوها و پیوندهای موجود در یک دادگان با استفاده از برنامه‌نویسی مورد کاوش قرار می‌گیرد. دادگان مورد نظر ممکن است متشکل از لیست کوچکی از اعداد باشد که در یک سطر کد جای می‌گیرد یا اینکه شامل چندین گیگابایت از داده‌ها باشد.</p><p>نمایش زیبای داده‌ها صرفاً به معنای ایجاد تصاویر قشنگ نیست. وقتی که بازنمایی یک دادگان به‌صورت ساده و جذاب انجام شود، درک معنای آن برای بیننده آسان‌تر می‌شود. افراد در دادگاه شما الگوها و معنایی را مشاهده خواهند کرد که قبلاً از وجود آن اطلاع نداشتند.</p><p>خوشبختانه، برای مصورسازی داده‌های پیچیده نیازی به یک ابرکامپیوتر نیست. با کارایی خوبی که پایتون دارد، به آسانی می‌توانید روی یک لپ‌تاپ معمولی دادگان‌هایی متشکل از میلیون‌ها نقطه‌ی داده‌ای را کاوش کنید. به‌علاوه، حتماً لازم نیست که این نقاط داده‌ای به‌صورت عدد باشند. با استفاده از مطالب پایه‌ای که در بخش اول این کتاب یاد گرفتید، داده‌های غیرعددی را نیز می‌توانید تحلیل کنید.</p><p>از پایتون برای تحلیل داده‌ها در حوزه‌های ژنتیک، پژوهش‌های اقلیمی، تحلیل‌های سیاسی و اقتصادی، و بسیاری حوزه‌های دیگر استفاده می‌شود. داده‌پژوهان <a id="p306"></a>انواع و اقسام ابزارهای مصورسازی و تحلیل به زبان پایتون ایجاد کرده‌اند که بسیاری از آن‌ها در دسترس شما نیز قرار دارند. یکی از متداول‌ترین این ابزارها <span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span> است که کبتاخانه‌ای برای رسم نمودارهای ریاضی است. ما از این کتابخانه برای رسم نمودارهای ساده، از قبیل نمودارهای خطی و نمودارهای پراکندگی، استفاده خواهیم کرد. سپس بر اساس مفهوم قدم زدن تصادفی که نوعی مصورسازی است که با یک رشته تصمیماتی تصادفی ایجاد می‌شود، دادگان جالب‌تری را ایجاد خواهیم کرد.</p><p>در ضمن، از پکیجی به نام <span class="rlm">‏</span><span class="lr" dir="ltr">Plotly</span><span class="rlm">‏</span> استفاده خواهیم کرد که مصورسازی‌هایی جرم که برای نمایش بر روی دستگاه‌های دیجیتال مناسب است. مصورسازی‌های این پکیج به‌طور خودکار اندازه‌ی خود را با انواع مختلف نمایشگرهای دستگاه‌ها هماهنگ می‌کند. به‌علاوه، این مصورسازی‌ها می‌تواند مشتمل بر ویژگی‌های تعاملی مختلفی نیز باشد، مثلاً اینکه وقتی کاربر از روی بخش‌های مختلف مصورسازی رد می‌شود، قسمت‌های خاص داده‌ها را برجسته می‌کند. ما از این پکیج برای تحلیل نتایج انداختن تاس استفاده خواهیم کرد.</p><div class="sect" id="ch15lev1sec1"><a class="bkmk" name="ch15lev1sec1"></a><h3>نصب <span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span></h3>
<p class="noindent">برای اینکه از پکیج <span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span> در مصورسازی‌های خود استفاده کنید، باید آن را با استفاده از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pip</span><span class="rlm">‏</span> نصب کنید. <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pip</span><span class="rlm">‏</span> مدولی است که پکیج‌های پایتون را دانلود و نصب می‌کند. فرمان زیر را در سطر فرمان ترمینال وارد کنید:</p><div class="snippet"><pre class="snippet" dir="ltr">$ <span class="bo">python -m pip install --user matplotlib</span></pre></div><p>این فرمان به پایتون می‌گوید که مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pip</span><span class="rlm">‏</span> را اجرا کند و پکیج <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">matplotlib</span><span class="rlm">‏</span> را در پایتون نصب شده‌ی کنونی کاربر نصب کند. در صورتی که برای اجرای برنامه‌ها یا شروع ترمینال از فرمان دیگری غیر از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">python</span><span class="rlm">‏</span> استفاده می‌کنید، مثلاً از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">python3</span><span class="rlm">‏</span>، در آن صورت فرمان شما چیزی شبیه این خواهد بود:</p><div class="snippet"><pre class="snippet" dir="ltr">$ <span class="bo">python3 -m pip install --user matplotlib</span></pre></div><div class="note"><h6 class="note-title">توجه</h6>
<p class="noindent">اگر این فرمان در <span class="rlm">‏</span><span class="lr" dir="ltr">macOS</span><span class="rlm">‏</span> کار نکند، می‌توانید فرمان را مجدداً بدون فلگ <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">--user</span><span class="rlm">‏</span> اجرا کنید.</p></div><p>برای آشنایی با انواع مصورسازی‌هایی که می‌توانید با <span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span> ایجاد کنید، به گالری نمونه‌ی آن در نشانی <span class="rlm">‏</span><a dir="ltr" target="_blank" href="https://matplotlib.org/gallery/">https://matplotlib.org/gallery/</a><span class="rlm">‏</span> سر بزنید. وقتی که روی یکی از مصورسازی های این گالری کلیک کنید، کد استفاده شده برای ایجاد نمودار به شما نشان داده می‌شود.</p></div><div class="sect" id="ch15lev1sec2"><a class="bkmk" name="ch15lev1sec2"></a><h3>رسم یک نمودار خطی ساده</h3>
<p class="noindent">در اینجا نمودار خطی ساده‌ای با استفاده از <span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span> ترسیم می‌کنیم، سپس آن را سفارشی‌سازی می‌کنیم تا به مصورسازی مفیدتری دست پیدا کنیم. به‌عنوان داده‌های این نمودار از دنباله‌ی اعداد مربعی ۱، ۴، ۹، ۱۶، ۲۵ استفاده خواهیم کرد.</p><p>مانند برنامه‌ی زیر، کافی است اعداد را به <span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span> بدهید تا بقیه‌ی کار را برایتان انجام دهد:</p><div class="snippet"><div class="snippet-title" dir="ltr">mpl_squares.py</div><pre class="snippet" dir="ltr">import matplotlib.pyplot as plt

squares = [1, 4, 9, 16, 25]
<a id="p307"></a><span class="n" dir="ltr">1</span>fig, ax = plt.subplots()
ax.plot(squares)

plt.show()</pre></div><p>ابتدا مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pyplot</span><span class="rlm">‏</span> را ایمپورت می‌کنیم و برای آن از نام مستعار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">plt</span><span class="rlm">‏</span> استفاده می‌کنیم تا مجبور نباشیم مکرراً <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pyplot</span><span class="rlm">‏</span> را تایپ کنیم. (این روش کار را در مثال‌های آنلاین به وفور شاهد خواهید بود، بنابراین، ما هم از همین روش پیروی می‌کنیم.) مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pyplot</span><span class="rlm">‏</span> حاوی تعدادی تابع است که نمودار و منحنی ایجاد می‌کنند.</p><p>لیستی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">squares</span><span class="rlm">‏</span> ایجاد می‌کنیم و داده‌هایی را که می‌خواهیم نمودار آن را ترسیم کنیم، در آن لیست قرار می‌دهیم. سپس به پیروی از روش متداول دیگری در رابطه با این پکیج، تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">subplots()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم <span class="n" dir="ltr">1</span>. این تابع می‌تواند در یک شکل واحد، یک یا چند نمودار ایجاد کند. متغیر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">fig</span><span class="rlm">‏</span> نشان‌دهنده‌ی کل شکل یا مجموعه‌ی نمودارهای تولید شده است. متغیر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">ax</span><span class="rlm">‏</span> نماینده‌ی یکی از نمودارهای موجود در شکل است، و اکثر اوقات از این متغیر استفاده خواهیم کرد.</p><p>سپس از متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">plot()</span><span class="rlm">‏</span> استفاده می‌کنیم که تلاش می‌کند که نمودار داده‌های داده شده را به‌صورت معنی‌داری ترسیم کند. تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">plt.show()</span><span class="rlm">‏</span> پنجره‌ی نمایشگر <span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span> را باز می‌کند و نمودار را نمایش می‌دهد، مانند <refFig xmlns="urn:dox:pycc">۱۵-۱</refFig>. در این پنجره می‌توانید نمودار را زوم کنید و قسمت‌های مختلف آن را نگاه کنید، و اگر روی آیکون دیسک کلیک کنید، می‌توانید تصویر هر نموداری نظر را که خواستید، ذخیره کنید.</p><figure class="fig" id="ch15_fig01"><img class="fig" src="images/ch15_fig01.jpg"/><figcaption class="fig">شکل ۱۵-۱: یکی از ساده‌ترین نمودارهایی که می‌توانید با <span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span> درست کنید.</figcaption></figure><div class="sect" id="ch15lev2sec1"><a class="bkmk" name="ch15lev2sec1"></a><h4>تغییر دادن فونت برچسب‌ها و ضخامت خط</h4>
<p class="noindent">گرچه نمودار <refFig xmlns="urn:dox:pycc">۱۵-۱</refFig> به خوبی نشان می‌دهد که اعداد در حال افزایش هستند، ولی فونت برچسب‌ها خیلی ریز است و خط نمودار هم تا حدودی نازک است. خوشبختانه، <span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span> این امکان را به شما می‌دهد که تمام جنبه‌های مصورسازی را تنظیم کنید.</p><a id="p308"></a><p>از چند روش سفارشی‌سازی استفاده می‌کنیم تا نمودار را بیشتر قابل خواندن کنیم، به این صورت:</p><div class="snippet"><div class="snippet-title" dir="ltr">mpl_squares.py</div><pre class="snippet" dir="ltr"><span class="ash">import matplotlib.pyplot as plt</span>

<span class="ash">squares = [1, 4, 9, 16, 25]</span>

<span class="ash">fig, ax = plt.subplots()</span>
<span class="n" dir="ltr">1</span>ax.plot(squares, linewidth=3)

# Set chart title and label axes.
<span class="n" dir="ltr">2</span>ax.set_title("Square Numbers", fontsize=24)
<span class="n" dir="ltr">3</span>ax.set_xlabel("Value", fontsize=14)
ax.set_ylabel("Square of Value", fontsize=14)

# Set size of tick labels.
<span class="n" dir="ltr">4</span>ax.tick_params(axis='both', labelsize=14)

<span class="ash">plt.show()</span></pre></div><p>پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">linewidth</span><span class="rlm">‏</span> در <span class="n" dir="ltr">1</span> ضخامت خطی را که به‌وسیله‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">plot()</span><span class="rlm">‏</span> ایجاد می‌شود، کنترل می‌کند. متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">set_title()</span><span class="rlm">‏</span> در <span class="n" dir="ltr">2</span> عنوان نمودار را تعیین می‌کند. پارامترهای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">fontsize</span><span class="rlm">‏</span>، که در قسمت‌های مختلف کد استفاده شده‌اند، اندازه‌ی متن را در اجزای مختلف نمودار تعیین می‌کنند.</p><p>متدهای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">set_xlabel()</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">set_ylabel()</span><span class="rlm">‏</span> امکان تعیین عنوان را برای هر کدام از محورها فراهم می‌کنند <span class="n" dir="ltr">3</span>، و متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">tick_params()</span><span class="rlm">‏</span> استایل تیک‌مارک‌ها را مشخص می‌کند <span class="n" dir="ltr">4</span>. آرگومان‌های نشان داده شده در اینجا بر تیک‌مارک‌های هر دو محور <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> تأثیر می‌گذارند (<span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">axis='both'</span><span class="rlm">‏</span>)، و اندازه‌ی فونت برچسب تیک‌مارک را ۱۴ تعیین کرده‌اند (<span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">labelsize=14</span><span class="rlm">‏</span>).</p><p>همان‌گونه که در <refFig xmlns="urn:dox:pycc">۱۵-۲</refFig> می‌بینید، خواندن نمودار حاصله بسیار آسان‌تر است. اندازه‌ی فونت برچسب‌ها بزرگ‌تر شده و نمودار با خط ضخیم‌تری ترسیم شده است. اغلب اوقات باید تغییراتی را در این مقادیر بدهید تا متوجه شوید که چه مقادیری در نمودار حاصله منظره‌ی بهتری ایجاد می‌کنند.</p><figure class="fig" id="ch15_fig02"><img class="fig" src="images/ch15_fig02.jpg"/><figcaption class="fig">شکل ۱۵-۲: حالا خواندن نمودار بسیار آسان‌تر است.</figcaption></figure></div><div class="sect" id="ch15lev2sec2"><a class="bkmk" name="ch15lev2sec2"></a><h4>اصلاح نمودار</h4>
<a id="p309"></a><p class="noindent">ولی حالا که می‌توانیم نمودار را بهتر بخوانیم، مشاهده می‌کنیم که داده‌ها به درستی ترسیم نشده‌اند. اگر به انتهای نمودار نگاه کنید، می‌بینید که مربع ۴٫۰ به صورت ۲۵ نشان داده شده است! باید این اشتباه را اصلاح کنیم.</p><p>وقتی که دنباله‌ای از اعداد را به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">plot()</span><span class="rlm">‏</span> می‌دهید، این تابع فرض می‌کند که اولین نقطه‌ی داده‌ای متناظر با مقدار <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> ۰ است، ولی اولین نقطه‌ی داده‌ای ما متناظر با مقدار <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> ۱ است. می‌توانیم با دادن مقادیر ورودی و خروجی استفاده شده برای محاسبه‌ی مربع‌ها به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">plot()</span><span class="rlm">‏</span>، این رفتار پیش‌فرض را جایگزین کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">mpl_squares.py</div><pre class="snippet" dir="ltr"><span class="ash">import matplotlib.pyplot as plt</span>

input_values = [1, 2, 3, 4, 5]
<span class="ash">squares = [1, 4, 9, 16, 25]</span>

<span class="ash">fig, ax = plt.subplots()</span>
ax.plot(input_values, squares, linewidth=3)

<span class="ash"># Set chart title and label axes.</span>
<span class="ash">--<span class="it">snip</span>--</span></pre></div><p>حالا <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">plot()</span><span class="rlm">‏</span> نمودار داده‌ها را درست ترسیم خواهد کرد، زیرا ما مقادیر ورودی و خروجی را به آن داده‌ایم، لذا نیازی نیست که خودش نحوه‌ی ایجاد داده‌های خروجی را حدس بزند. حالا نمودار حاصله، که در <refFig xmlns="urn:dox:pycc">۱۵-۳</refFig> نشان داده شده است، صحیح است.</p><figure class="fig" id="ch15_fig03"><img class="fig" src="images/ch15_fig03.jpg"/><figcaption class="fig">شکل ۱۵-۳: حالا نمودار داده‌ها درست ترسیم می‌شود.</figcaption></figure><p>شما برای استفاده از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">plot()</span><span class="rlm">‏</span> می‌توانید از آرگومان‌های متعددی استفاده کنید، و نیز می‌توانید توابع مختلفی را برای سفارشی‌سازی نمودارها به کار بگیرید. در طول این فصل ضمن کار با برخی دادگان‌های جالب‌تر، موارد استفاده‌ی این توابع سفارشی‌سازی را بررسی خواهیم کرد.</p></div><div class="sect" id="ch15lev2sec3"><a class="bkmk" name="ch15lev2sec3"></a><h4>استفاده از استایل‌های درونی</h4>
<a id="p310"></a><p class="noindent"><span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span> دارای برخی استایل‌های از پیش تعریف شده است که سبب می‌شود که مصورسازی‌های شما از لحاظ رنگ پس‌زمینه، خطوط راهنما، پهنای خطوط، فونت‌ها اندازه‌ی فونت، و غیره منظره‌ی خوشایندی داشته باشند و نیاز چندانی به سفارشی‌سازی نداشته باشند. برای اینکه استایل‌های موجود بر روی سیستمتان را ببینید، دستورهای زیر را در سطر فرمان پایتون اجرا کنید:</p><div class="snippet"><pre class="snippet" dir="ltr">&gt;&gt;&gt; <span class="bo">import matplotlib.pyplot as plt</span>
&gt;&gt;&gt; <span class="bo">plt.style.available</span>
['seaborn-dark', 'seaborn-darkgrid', 'seaborn-ticks', 'fivethirtyeight',
--<span class="it">snip</span>--</pre></div><p>برای استفاده از هر کدام از این استایل‌ها، قبل از ایجاد نمودار، یک سطر کد اضافه کنید:</p><div class="snippet"><div class="snippet-title" dir="ltr">mpl_squares.py</div><pre class="snippet" dir="ltr"><span class="ash">import matplotlib.pyplot as plt</span>

<span class="ash">input_values = [1, 2, 3, 4, 5]</span>
<span class="ash">squares = [1, 4, 9, 16, 25]</span>

plt.style.use('seaborn')
<span class="ash">fig, ax = plt.subplots()</span>
<span class="ash">--<span class="it">snip</span>--</span></pre></div><p>این کد نمودار نشان داده شده در <refFig xmlns="urn:dox:pycc">۱۵-۴</refFig> را ایجاد می‌کند. استایل‌های زیادی در دسترس شما است؛ آن‌ها را آزمایش کنید تا ببینید از کدام‌یک خوشتان می‌آید.</p><figure class="fig" id="ch15_fig04"><img class="fig" src="images/ch15_fig04.jpg"/><figcaption class="fig">شکل ۱۵-۴: استایل از پیش تعریف شده‌ی سی‌بورن.</figcaption></figure></div><div class="sect" id="ch15lev2sec4"><a class="bkmk" name="ch15lev2sec4"></a><h4>ترسیم و استایل‌دهی نقاط منفرد با <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">scatter()</span><span class="rlm">‏</span></h4>
<p class="noindent">بعضی وقت‌ها لازم است که نقاط منفرد را با مشخصات خاصی ترسیم و استایل‌دهی کنیم. مثلاً شاید بخواهید مقادیر کوچک رال با یک رنگ و مقادیر بزرگ را بال رنگ دیگری ترسیم کنید. یا اینکه مثلاً می‌توانید دادگان بزرگی را با <a id="p311"></a>مجموعه‌ی استایل‌های خاصی ترسیم کنید ، و استایل برخی از نقاط را برای تأکید بیشتر تغییر دهید.</p><p>برای ترسیم یک نقطه‌ی منفرد، از متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">scatter()</span><span class="rlm">‏</span> استفاده می‌کنیم. مقادیر مختصات نقطه‌ی مورد نظر (<span class="emphasis">x</span> و <span class="emphasis">y</span>) را به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">scatter()</span><span class="rlm">‏</span> بدهید تا آن نقطه را ترسیم کند:</p><div class="snippet"><div class="snippet-title" dir="ltr">scatter_squares.py</div><pre class="snippet" dir="ltr">import matplotlib.pyplot as plt

plt.style.use('seaborn')
fig, ax = plt.subplots()
ax.scatter(2, 4)

plt.show()</pre></div><p>حالا خروجی را استایل می‌دهیم تا کمی جالب‌تر شود. عنوان اضافه می‌کنیم، به محورها برچسب می‌دهیم، و اندازه‌ی متن را بزرگ‌تر می‌کنیم تا خواندن آن آسان‌تر باشد:</p><div class="snippet"><pre class="snippet" dir="ltr"><span class="ash">import matplotlib.pyplot as plt</span>

<span class="ash">plt.style.use('seaborn')</span>
<span class="ash">fig, ax = plt.subplots()</span>
<span class="n" dir="ltr">1</span>ax.scatter(2, 4, s=200)

# Set chart title and label axes.
ax.set_title("Square Numbers", fontsize=24)
ax.set_xlabel("Value", fontsize=14)
ax.set_ylabel("Square of Value", fontsize=14)

# Set size of tick labels.
ax.tick_params(axis='both', which='major', labelsize=14)

<span class="ash">plt.show()</span></pre></div><p>در <span class="n" dir="ltr">1</span>، از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">scatter()</span><span class="rlm">‏</span> استفاده می‌کنیم و به آن آرگومان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">s</span><span class="rlm">‏</span> می‌دهیم که اندازه‌ی نقطه‌ی کشیده شده را مشخص می‌کند. حالا وقتی که <span class="rlm">‏</span><span class="ident" dir="ltr">scatter_squares.py</span><span class="rlm">‏</span> را اجرا کنید، یک نقطه‌ی واحد را وسط نمودار خواهید دید، ماندن <refFig xmlns="urn:dox:pycc">۱۵-۵</refFig>.</p><figure class="fig" id="ch15_fig05"><img class="fig" src="images/ch15_fig05.jpg"/><figcaption class="fig">شکل ۱۵-۵: رسم یک نقطه‌ی واحد.</figcaption></figure></div><div class="sect" id="ch15lev2sec5"><a class="bkmk" name="ch15lev2sec5"></a><h4>رسم رشته‌ای از نقاط به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">scatter()</span><span class="rlm">‏</span></h4>
<a id="p312"></a><p class="noindent">برای رسم رشته‌ای از نقاط، باید لیستی از مقادیر <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> را به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">scatter()</span><span class="rlm">‏</span> بدهیم، به این صورت:</p><div class="snippet"><div class="snippet-title" dir="ltr">scatter_squares.py</div><pre class="snippet" dir="ltr"><span class="ash">import matplotlib.pyplot as plt</span>

x_values = [1, 2, 3, 4, 5]
y_values = [1, 4, 9, 16, 25]

<span class="ash">plt.style.use('seaborn')</span>
<span class="ash">fig, ax = plt.subplots()</span>
ax.scatter(x_values, y_values, s=100)

<span class="ash"># Set chart title and label axes.</span>
<span class="ash">--<span class="it">snip</span>--</span></pre></div><p>لیست <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">x_values</span><span class="rlm">‏</span> حاوی اعدادی است که می‌خواهیم مربع آن‌ها را نمایش دهیم، و لیست <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">y_values</span><span class="rlm">‏</span> حاوی مربع هر کدام از آن اعداد است. وقتی که این لیست‌ها به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">scatter()</span><span class="rlm">‏</span> داده شوند، <span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span> از هر لیست یک مقدار را می‌خواند و نقطه‌ی مربوطه را ترسیم می‌کند. نقاطی که باید ترسیم شوند، عبارت‌اند از <span class="rlm">‏</span><span class="lr" dir="ltr">(1, 1)</span><span class="rlm">‏</span>، <span class="rlm">‏</span><span class="lr" dir="ltr">(2, 4)</span><span class="rlm">‏</span>، <span class="rlm">‏</span><span class="lr" dir="ltr">(3, 9)</span><span class="rlm">‏</span>، <span class="rlm">‏</span><span class="lr" dir="ltr">(4, 16)</span><span class="rlm">‏</span>، و <span class="rlm">‏</span><span class="lr" dir="ltr">(5, 25)</span><span class="rlm">‏</span>؛ <refFig xmlns="urn:dox:pycc">۱۵-۶</refFig> نتیجه را نشان می‌دهد.</p><figure class="fig" id="ch15_fig06"><img class="fig" src="images/ch15_fig06.jpg"/><figcaption class="fig">شکل ۱۵-۶: یک نمودار پراکندگی با نقاط متعدد.</figcaption></figure></div><div class="sect" id="ch15lev2sec6"><a class="bkmk" name="ch15lev2sec6"></a><h4>محاسبه‌ی خودکار داده‌ها</h4>
<p class="noindent">نوشتن لیست‌ها با دست کار راحتی نیست، خصوصاً در صورتی که تعداد نقطه‌ها زیاد باشد. به جای اینکه نقطه‌ها را در داخل لیست بنویسیم و به تابع بدهیم، حلقه‌ای درست می‌کنیم تا محاسبات را برایمان انجام دهد.</p><a id="p313"></a><p>مثلاً برای ۱۰۰۰ نقطه، به‌صورت زیر است:</p><div class="snippet"><div class="snippet-title" dir="ltr">scatter_squares.py</div><pre class="snippet" dir="ltr">
<span class="ash">import matplotlib.pyplot as plt</span>

<span class="n" dir="ltr">1</span>x_values = range(1, 1001)
y_values = [x**2 for x in x_values]

<span class="ash">plt.style.use('seaborn')</span>
<span class="ash">fig, ax = plt.subplots()</span>
<span class="n" dir="ltr">2</span>ax.scatter(x_values, y_values, s=10)

<span class="ash"># Set chart title and label axes.</span>
<span class="ash">--<span class="it">snip</span>--</span>

# Set the range for each axis.
<span class="n" dir="ltr">3</span>ax.axis([0, 1100, 0, 1100000])

<span class="ash">plt.show()</span></pre></div><p>ابتدا با دامنه‌ای از مقادیر <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> شامل اعداد ۱ تا ۱۰۰۰ شروع می‌کنیم <span class="n" dir="ltr">1</span>. سپس، با استفاده از روش <span class="rlm">‏</span><span class="lr" dir="ltr">list comprehension</span><span class="rlm">‏</span>، مقادیر <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> را با تشکیل حلقه روش مقادیر <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> (<span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">for x in x_values</span><span class="rlm">‏</span>) و مربع کردن هر عدد (<span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">x**2</span><span class="rlm">‏</span>)ایجاد می‌کنیم، و نتایج را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">y_values</span><span class="rlm">‏</span> ذخیره می‌کنیم. سپس لیست‌های ورودی و خروجی را به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">scatter()</span><span class="rlm">‏</span> می‌دهیم <span class="n" dir="ltr">2</span>. از آنجا که حجم این دادگان بزرگ‌تر است، لذا اندازه‌ی نقطه‌ها را کوچک‌تر می‌گیریم.</p><p>در <span class="n" dir="ltr">3</span>، با استفاده از متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">axis()</span><span class="rlm">‏</span>، دامنه‌ی هر کدام از محورها را تعیین می‌کنیم. متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">axis()</span><span class="rlm">‏</span> نیاز به چهار مقدار دارد: مقادیر کمینه و بیشینه‌ی محور <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span>. در اینجا، دامنه‌ی محور <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> را از ۰ تا ۱۱۰ و دامنه‌ی محور <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> را از ۰ تا ۱٬۱۰۰٬۰۰۰ می‌گیریم. <refFig xmlns="urn:dox:pycc">۱۵-۷</refFig> نتیجه‌ی کار را نشان می‌دهد.</p><figure class="fig" id="ch15_fig07"><img class="fig" src="images/ch15_fig07.jpg"/><figcaption class="fig">شکل ۱۵-۷: پایتون می‌تواند ۱۰۰ نقطه را به همان آسانی ۵ نقطه ترسیم کند.</figcaption></figure></div><div class="sect" id="ch15lev2sec7"><a class="bkmk" name="ch15lev2sec7"></a><h4>تعریف رنگ‌های سفارشی</h4>
<a id="p314"></a><p class="noindent">برای تغییر دادن رنگ نقطه‌ها، نام رنگ مورد نظر را داخل علامت نقل‌قول به پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">c</span><span class="rlm">‏</span> از تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">scatter()</span><span class="rlm">‏</span> بدهید، مانند آنچه در اینجا می‌بینید:</p><div class="snippet"><pre class="snippet" dir="ltr">ax.scatter(x_values, y_values, c='red', s=10)</pre></div><p>هم‌چنین، می‌توانید رنگ‌های خاص مورد نظرتان را با استفاده از مدل رنگ <span class="rlm">‏</span><span class="lr" dir="ltr">RGB</span><span class="rlm">‏</span> بسازید. برای تعریف یک رنگ، یک توپل حاوی سه عدد اعشاری بین ۰ و ۱ (به‌ترتیب برای قرمز، سبز، و آبی) به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">c</span><span class="rlm">‏</span> بدهید. مثلاً سطر زیر نموداری با نقطه‌های سبز روشن ایجاد می‌کند:</p><div class="snippet"><pre class="snippet" dir="ltr">ax.scatter(x_values, y_values, c=(0, 0.8, 0), s=10)</pre></div><p>هرچه مقادیر به ۰ نزدیک‌تر باشد، رنگ تیره‌تری ایجاد می‌کند، و هرچه به ۱ نزدیک‌تر باشد، رنگ روشن‌تری ایجاد می‌کند.</p></div><div class="sect" id="ch15lev2sec8"><a class="bkmk" name="ch15lev2sec8"></a><h4>استفاده از نگاشت رنگ</h4>
<p class="noindent"><span class="emphasis">نگاشت رنگ</span> (<span class="emphasis"><span class="rlm">‏</span><span class="lr" dir="ltr">colormap</span><span class="rlm">‏</span></span>) به معنای یک سری رنگ به‌صورت گرادیان است که از رنگ شروع تا رنگ پایان تغییر می‌کند. از نگاشت رنگ در مصورسازی‌ها برای تأکید بر الگوی داده‌ها استفاده می‌شود. مثلاً می‌توانید برای مقادیر پایین از رنگ روشن و برای مقادیر بالا از رنگ تیره استفاده کنید.</p><p>مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pyplot</span><span class="rlm">‏</span> شامل یک سری نگاشت رنگ درونی است. برای استفاده از آن‌ها، باید مشخص کنید که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pyplot</span><span class="rlm">‏</span> چگونه باید به هر نقطه‌ی موجود در دادگان، رنگی اختصاص دهد. مثلاً به‌صورت زیر می‌توانید به هر نقطه بر اساس مقدار <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> آن، رنگ اختصاص دهید:</p><div class="snippet"><div class="snippet-title" dir="ltr">scatter_squares.py</div><pre class="snippet" dir="ltr"><span class="ash">import matplotlib.pyplot as plt</span>

<span class="ash">x_values = range(1, 1001)</span>
<span class="ash">y_values = [x**2 for x in x_values]</span>

ax.scatter(x_values, y_values, c=y_values, cmap=plt.cm.Blues, s=10)

<span class="ash"># Set chart title and label axes.</span>
<span class="ash">--<span class="it">snip</span>--</span></pre></div><p>در اینجا، لیست مقادیر <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> را به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">c</span><span class="rlm">‏</span> می‌دهیم، و سپس با استفاده از آرگومان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">cmap</span><span class="rlm">‏</span>، به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pyplot</span><span class="rlm">‏</span> می‌گوییم که چگونه از این نگاشت رنگ استفاده کند. این کد نقاطی را که مقدار <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> پایین‌تری دارند با آبی روشن، و نقاطی را که مقدار <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> بالاتری دارند با آبی تیره ترسیم می‌کند. <refFig xmlns="urn:dox:pycc">۱۵-۸</refFig> نمودار حاصله را نشان می‌دهد.</p><div class="note"><h6 class="note-title">توجه</h6>
<p class="noindent">تمام نگاشت‌های رنگ موجود در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pyplot</span><span class="rlm">‏</span> را می‌توانید در نشانی <span class="rlm">‏</span><a dir="ltr" target="_blank" href="https://matplotlib.org/">https://matplotlib.org/</a><span class="rlm">‏</span> ببینید؛ به بخش <span class="strong"><span class="rlm">‏</span><span class="lr" dir="ltr">Examples</span><span class="rlm">‏</span></span> بروید، سپس در قسمت <span class="strong"><span class="rlm">‏</span><span class="lr" dir="ltr">Color</span><span class="rlm">‏</span></span>، روی <span class="strong"><span class="rlm">‏</span><span class="lr" dir="ltr">Colormap reference</span><span class="rlm">‏</span></span> کلیک کنید.</p></div><a id="p315"></a><figure class="fig" id="ch15_fig08"><img class="fig" src="images/ch15_fig08.jpg"/><figcaption class="fig">شکل ۱۵-۸: یک نمودار با استفاده از نگاشت رنگ <span class="it">Blues</span>.</figcaption></figure></div><div class="sect" id="ch15lev2sec9"><a class="bkmk" name="ch15lev2sec9"></a><h4>ذخیره کردن خودکار نمودارها</h4>
<p class="noindent">اگر می‌خواهید که برنامه‌ی شما به‌طور خودکار نمودار را در فایلی ذخیره کند، می‌توانید به جای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">plt.show()</span><span class="rlm">‏</span>، فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">plt.savefig()</span><span class="rlm">‏</span> را قرار دهید:</p><div class="snippet"><pre class="snippet" dir="ltr">plt.savefig('squares_plot.png', bbox_inches='tight')</pre></div><p>آرگومان اول نام فایل مورد نظر برای ذخیره کردن تصویر نمودار است، که در همان دایرکتوری <span class="rlm">‏</span><span class="ident" dir="ltr">scatter_squares.py</span><span class="rlm">‏</span> ایجاد خواهد شد. آرگومان دوم فضای سفید اضافه را از نمودار حذف می‌کند. اگر می‌خواهید که دور نمودار فضای سفید بیشتری وجود داشته باشد، کافی است این آرگومان را حذف کنید.</p><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<p class="tiy1"><span class="tiy" id="ch15_tiy01"><span class="tiy-num">۱۵-۱</span>. <span class="tiy-title">مکعب‌ها</span>: </span> به توان سوم یک عدد، <span class="emphasis">مکعب</span> می‌گویند. نمودار مکعب‌های اعداد یک تا پنج را رسم کنید، و سپس نمودار مکعب‌های اعداد یک تا ۵۰۰۰ را رسم نمایید.</p><p class="tiy1"><span class="tiy" id="ch15_tiy02"><span class="tiy-num">۱۵-۲</span>. <span class="tiy-title">مکعب‌های رنگی</span>: </span> برای نمودار مکعب‌ها از نگاشت رنگ استفاده کنید.</p></div></div></div><div class="sect" id="ch15lev1sec3"><a class="bkmk" name="ch15lev1sec3"></a><h3>قدم زدن تصادفی</h3>
<p class="noindent">در این قسمت، با استفاده از پایتون، داده‌های لازم برای قدم زدن تصادفی را ایجاد خواهیم کرد، و سپس با استفاده از <span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span>، داده‌ها را به‌صورت جذابی مصورسازی خواهیم کرد. <span class="emphasis">قدم زدن تصادفی</span> به معنای مسیری است که جهت مشخصی ندارد، ولی به‌وسیله‌ی یک رشته تصمیمات تصادفی معین می‌شود که هر کدام از آن‌ها کاملاً وابسته به شانس است. مثلاً می‌توان آن را به‌عنوان مسیر مورچه‌ی گیجی در نظر گرفت که هر قدمش را در جهتی تصادفی برمی‌دارد.</p><a id="p316"></a><p>قدم زدن تصادفی کاربردهای عملی در طبیعت، فیزیک، زیست‌شناسی، شیمی، و اقتصاد دارد. مثلاً یک دانه‌ی گرده که روی قطره‌ی آبی شناور است، روی سطح آب حرکت می‌کند، زیرا مولکول‌های آب مرتب به آن نیرو وارد می‌کنند. حرکت مولکول‌ها در قطره‌ی آب تصادفی است، ازاین‌رو، مسیر حرکت دانه‌ی گرده روی سطح آب نوعی قدم زدن تصادفی است. کدی که در زیر می‌نویسیم، مدلی برای بسیاری از موقعیت‌های دنیای واقعی است.</p><div class="sect" id="ch15lev2sec10"><a class="bkmk" name="ch15lev2sec10"></a><h4>ایجاد کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">RandomWalk</span><span class="rlm">‏</span></h4>
<p class="noindent">برای ایجاد قدم زدن تصادفی، کلاسی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">RandomWalk</span><span class="rlm">‏</span> ایجاد می‌کنیم، که جهت قدم زدن را به‌صورت تصادفی تعیین خواهد کرد. این کلاس نیاز به سه صفت دارد: یک متغیر برای ذخیره کردن تعداد نقطه‌های مسیر قدم زدن، و دو لیست برای ذخیره کردن مقادیر مختصات <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> هر کدام از نقاط مسیر.</p><p>برای کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">RandomWalk</span><span class="rlm">‏</span>، فقط دو متد مورد نیاز است: متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> و متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">fill_walk()</span><span class="rlm">‏</span> که نقاط مسیر قدم زدن را محاسبه می‌کند. ابتدا با متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> شروع می‌کنیم که در اینجا نشان داده شده است:</p><div class="snippet"><div class="snippet-title" dir="ltr">random_walk.py</div><pre class="snippet" dir="ltr"><span class="n" dir="ltr">1</span>from random import choice

class RandomWalk:
    """A class to generate random walks."""

<span class="n" dir="ltr">2</span>    def __init__(self, num_points=5000):
        """Initialize attributes of a walk."""
        self.num_points = num_points

        # All walks start at (0, 0).
<span class="n" dir="ltr">3</span>        self.x_values = [0]
        self.y_values = [0]</pre></div><p>برای اینکه تصمیمات به‌صورت تصادفی گرفته شود، حرکت‌های ممکن را در لیستی ذخیره می‌کنیم و هنگام برداشتن هر قدم، با استفاده از تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">choice()</span><span class="rlm">‏</span> از مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">random</span><span class="rlm">‏</span>، نوع حرکت را مشخص می‌کنیم <span class="n" dir="ltr">1</span>. تعداد پیش‌فرض نقاط در یک راه‌پیمایی را ۵۰۰۰ قدم در نظر می‌گیریم، که آن‌قدر بزرگ هست که الگوهای جالبی را ایجاد کند، ولی آن‌قدر کوچک است که راه‌پیمایی را می‌توان به سرعت ایجاد کرد <span class="n" dir="ltr">2</span>. سپس در <span class="n" dir="ltr">3</span>، دو لیست برای ذخیره کردن مقدار <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> ایجاد می‌کنیم، و هر راه‌پیمایی را از نقطه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">(0, 0)</span><span class="rlm">‏</span> آغاز می‌کنیم.</p></div><div class="sect" id="ch15lev2sec11"><a class="bkmk" name="ch15lev2sec11"></a><h4>انتخاب جهت</h4>
<p class="noindent">با استفاده از متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">fill_walk()</span><span class="rlm">‏</span> که در اینجا نشان داده شده است، نقطه‌های راه‌پیمایی را ایجاد می‌کنیم و جهت هر قدم را مشخص می‌کنیم. این متد را به <span class="rlm">‏</span><span class="ident" dir="ltr">random_walk.py</span><span class="rlm">‏</span> اضافه کنید:</p><div class="snippet"><div class="snippet-title" dir="ltr">random_walk.py</div><pre class="snippet" dir="ltr">    def fill_walk(self):
        """Calculate all the points in the walk."""

        # Keep taking steps until the walk reaches the desired length.
<span class="n" dir="ltr">1</span>        while len(self.x_values) &lt; self.num_points:

            # Decide which direction to go and how far to go in that direction.
<span class="n" dir="ltr">2</span>            x_direction = choice([1, -1])
<a id="p317"></a>            x_distance = choice([0, 1, 2, 3, 4])
<span class="n" dir="ltr">3</span>            x_step = x_direction * x_distance

            y_direction = choice([1, -1])
            y_distance = choice([0, 1, 2, 3, 4])
<span class="n" dir="ltr">4</span>            y_step = y_direction * y_distance

            # Reject moves that go nowhere.
<span class="n" dir="ltr">5</span>            if x_step == 0 and y_step == 0:
                continue

            # Calculate the new position.
<span class="n" dir="ltr">6</span>            x = self.x_values[-1] + x_step
            y = self.y_values[-1] + y_step

            self.x_values.append(x)
            self.y_values.append(y)</pre></div><p>در <span class="n" dir="ltr">1</span>، حلقه‌ای درست می‌کنیم که تا وقتی که تمام نقاط راه‌پیمایی ایجاد شده باشند، اجرا می‌شود. قسمت اصلی متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">fill_walk()</span><span class="rlm">‏</span> به پایتون می‌گوید که چگونه چهار تصمیم تصادفی را شبیه‌سازی کند: آیا راه‌پیمایی به طرف راست خواهد رفت یا به طرف چپ؟ تا کجا به آن سمت خواهد رفت؟ آیا بالا خواهد رفت یا پایین؟ و تا کجا در آن جهت خواهد رفت؟</p><p>از فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">choice([1, -1])</span><span class="rlm">‏</span> برای انتخاب مقداری برای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">x_direction</span><span class="rlm">‏</span> استفاده می‌کنیم، که این فراخوانی یا مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">1</span><span class="rlm">‏</span> برمی‌گرداند به معنای راست و یا مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">-1</span><span class="rlm">‏</span> به معنای چپ <span class="n" dir="ltr">2</span>. سپس، فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">choice([0, 1, 2, 3, 4])</span><span class="rlm">‏</span> به پایتون می‌گوید که در آن جهت چقدر حرکت کند (<span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">x_distance</span><span class="rlm">‏</span>)، به این صورت که به‌طور تصادفی یک عدد صحیح بین ۰ و ۴ ایجاد می‌کند. (گنجاندن ۰ این امکان را فراهم می‌کند که هم در امتداد محور <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> گام برداریم و هم گام‌هایی که در امتداد هر دو محور حرکت می‌کنند.)</p><p>در <span class="n" dir="ltr">3</span> و <span class="n" dir="ltr">4</span>، طول هر قدم را در راستای <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> با ضرب کردن مسیر حرکت در مسافت تعیین شده، مشخص می‌کنیم. اگر مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">x_step</span><span class="rlm">‏</span> مثبت باشد، به معنای حرکت به طرف راست است، مقدار منفی به معنای حرکت به طرف چپ است، و مقدار ۰ به معنای حرکت عمودی است. در مورد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">y_step</span><span class="rlm">‏</span>، مقدار مثبت به معنای حرکت به طرف بالا، مقدار منفی به معنای حرکت به طرف پایین، و ۰ به معنای حرکت افقی است. اگر مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">x_step</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">y_step</span><span class="rlm">‏</span> هر دو صفر باشد، حرکتی صورت نمی‌گیرد، لذا از این حرکت صرف نظر می‌کنیم و حلقه را ادامه می‌دهیم <span class="n" dir="ltr">5</span>.</p><p>برای اینکه مقدار <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> بعدی راه‌پیمایی به دست آید، مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">x_step</span><span class="rlm">‏</span> را به آخرین مقدار ذخیره شده در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">x_values</span><span class="rlm">‏</span> اضافه می‌کنیم <span class="n" dir="ltr">6</span>، و همین کار را برای مقادیر <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> نیز انجام می‌دهیم. وقتی که این مقادیر را به دست آوردیم، آن‌ها را به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">x_values</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">y_values</span><span class="rlm">‏</span> پیوست می‌کنیم.</p></div><div class="sect" id="ch15lev2sec12"><a class="bkmk" name="ch15lev2sec12"></a><h4>رسم نمودار قدم زدن تصادفی</h4>
<p class="noindent">کد زیر نمودار تمام نقاط راه‌پیمایی را ترسیم می‌کند:</p><div class="snippet"><div class="snippet-title" dir="ltr">rw_visual.py</div><pre class="snippet" dir="ltr">import matplotlib.pyplot as plt

from random_walk import RandomWalk

# Make a random walk.
<span class="n" dir="ltr">1</span>rw = RandomWalk()
rw.fill_walk()

<a id="p318"></a># Plot the points in the walk.
plt.style.use('classic')
fig, ax = plt.subplots()
<span class="n" dir="ltr">2</span>ax.scatter(rw.x_values, rw.y_values, s=15)
plt.show()</pre></div><p>ابتدا <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pyplot</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">RandomWalk</span><span class="rlm">‏</span> را ایمپورت می‌کنیم. سپس یک راه‌پیمایی تصادفی ایجاد می‌کنیم و آن را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rw</span><span class="rlm">‏</span> ذخیره می‌کنیم <span class="n" dir="ltr">1</span>، و سپس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">fill_walk()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم. در <span class="n" dir="ltr">2</span>، مقادیر <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> راه‌پیمایی را به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">scatter()</span><span class="rlm">‏</span> می‌دهیم و اندازه‌ی مناسبی نیز برای نقطه‌ها تعیین می‌کنیم. <refFig xmlns="urn:dox:pycc">۱۵-۹</refFig> نمودار حاصله را با ۵۰۰۰ نقطه نشان می‌دهد. (در تصاویر این قسمت، تصویر پنجره‌ی نمایش‌دهنده‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span> حذف شده است، ولی شما هنگام اجرای <span class="rlm">‏</span><span class="ident" dir="ltr">rw_visual.py</span><span class="rlm">‏</span> آن را مشاهده خواهید کرد.)</p><figure class="fig" id="ch15_fig09"><img class="fig" src="images/ch15_fig09.jpg"/><figcaption class="fig">شکل ۱۵-۹: یک راه‌پیمایی تصادفی به ۵۰۰۰ نقطه</figcaption></figure></div><div class="sect" id="ch15lev2sec13"><a class="bkmk" name="ch15lev2sec13"></a><h4>ایجاد چندین راه‌پیمایی تصادفی</h4>
<p class="noindent">راه‌پیمایی‌های تصادفی هر کدام با دیگری متفاوت است، و بررسی الگوهای مختلفی که ایجاد می‌شود، بسیار سرگرم کننده است. یک راه برای اینکه با همان برنامه‌ی قبلی چندین راه‌پیمایی ایجاد کنیم، بودن اینکه لازم باشد که برنامه را چندین بار اجرا کنیم، این است که آن را درون یک حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">while</span><span class="rlm">‏</span> قرار دهیم، به این صورت:</p><div class="snippet"><div class="snippet-title" dir="ltr">rw_visual.py</div><pre class="snippet" dir="ltr"><span class="ash">import matplotlib.pyplot as plt</span>

<span class="ash">from random_walk import RandomWalk</span>

# Keep making new walks, as long as the program is active.
while True:
    <span class="ash"># Make a random walk.</span>
    <span class="ash">rw = RandomWalk()</span>
    <span class="ash">rw.fill_walk()</span>

    <span class="ash"># Plot the points in the walk.</span>
    <span class="ash">plt.style.use('classic')</span>
<a id="p319"></a>    <span class="ash">fig, ax = plt.subplots()</span>
    <span class="ash">ax.scatter(rw.x_values, rw.y_values, s=15)</span>
    <span class="ash">plt.show()</span>

    keep_running = input("Make another walk? (y/n): ")
    if keep_running == 'n':
        break</pre></div><p>این کد یک راه‌پیمایی تصادفی ایجاد می‌کند، آن را در پنجره‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span> نمایش می‌دهد، و تا وقتی که پنجره باز است، مکث می‌کند. وقتی که پنجره را بستید، از شما پرسیده می‌شود که آیا می‌خواهید یک راه‌پیمایی دیگر ایجاد شود؟ وقتی که کلید <span class="bo"><span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span></span> را فشار دهید، راه‌پیمایی دیگر ایجاد می‌شود که مثلاً نزدیک نقطه‌ی شروع می‌ماند، یا عمدتاً به یک جهت منحرف می‌شود، یا به‌صورت گروه‌های بزرگی از نقاط است که با قطعه‌ی نازکی به هم متصل شده‌اند، و الی آخر. وقتی که می‌خواهید برنامه را متوقف کنید، کلید <span class="bo"><span class="rlm">‏</span><span class="lr" dir="ltr">n</span><span class="rlm">‏</span></span> را فشار دهید.</p></div><div class="sect" id="ch15lev2sec14"><a class="bkmk" name="ch15lev2sec14"></a><h4>تعیین استایل‌های راه‌پیمایی</h4>
<p class="noindent">در این قسمت، نمودار را به‌صورتی تغییر می‌دهیم که بر مشخصات مهم هر راه‌پیمایی تأکید کنیم و به عناصر بی‌اهمیت جلوه‌ی کمتری بدهیم. برای این منظور، مشخصاتی را که می‌خواهیم مورد تأکید قرار دهیم، شناسایی می‌کنیم، مثلاً اینکه راه‌پیمایی از کجا شروع شده، کجا تمام شده، و از چه مسیری عبور کرده است. سپس مشخصاتی را که می‌خواهیم کمتر بر آن تأکید شود، شناسایی می‌کنیم، مثلاً خطوط درجه‌بندی محور و برچسب‌ها. نتیجه‌ی آن یک نمایش بصری ساده خواهد بود که به روشنی مسیر اتخاذ شده در هر راه‌پیمایی تصادفی را نمایش می‌دهد.</p><div class="sect" id="ch15lev3sec1"><a class="bkmk" name="ch15lev3sec1"></a><h5>رنگ زدن نقطه‌ها</h5>
<p class="noindent">برای نشان دادن ترتیب نقطه‌ها در راه‌پیمایی از یک نگاشت رنگ استفاده می‌کنیم، و سپس خط حاشیه‌ی سیاه دور هر نقطه را برمی‌داریم تا رنگ نقطه واضح‌تر باشد. برای رنگ کردن نقطه‌ها بر اساس موقعیت آن‌ها در راه‌پیمایی، لیستی حاوی موقعیت هر نقطه را به آرگومان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">c</span><span class="rlm">‏</span> می‌دهیم. از آنجا که نقطه‌ها به ترتیب ترسیم می‌شوند، لذا لیست فقط حاوی اعداد ۰ تا ۴۹۹۹ است، به‌صورت زیر:</p><div class="snippet"><div class="snippet-title" dir="ltr">rw_visual.py</div><pre class="snippet" dir="ltr"><span class="ash">--<span class="it">snip</span>--</span>
<span class="ash">while True:</span>
    <span class="ash"># Make a random walk.</span>
    <span class="ash">rw = RandomWalk()</span>
    <span class="ash">rw.fill_walk()</span>

    <span class="ash"># Plot the points in the walk.</span>
    <span class="ash">plt.style.use('classic')</span>
    <span class="ash">fig, ax = plt.subplots()</span>
<span class="n" dir="ltr">1</span>    point_numbers = range(rw.num_points)
    ax.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues,
        edgecolors='none', s=15)
    <span class="ash">plt.show()</span>

    <span class="ash">keep_running = input("Make another walk? (y/n): ")</span>
    <span class="ash">--<span class="it">snip</span>--</span></pre></div><a id="p320"></a><p>در <span class="n" dir="ltr">1</span>، با استفاده از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">range()</span><span class="rlm">‏</span>، لیستی از اعداد به تعداد نقطه‌های راه‌پیمایی ایجاد می‌کنیم. سپس آن‌ها را در لیست <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">point_numbers</span><span class="rlm">‏</span> ذخیره می‌کنیم که از این‌ها برای تعیین رنگ هر نقطه استفاده خواهیم کرد. لیست <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">point_numbers</span><span class="rlm">‏</span> را به آرگومان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">c</span><span class="rlm">‏</span> می‌دهیم، از نگاشت رنگ <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Blues</span><span class="rlm">‏</span> استفاده می‌کنیم، و سپس با دادن <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">edgecolors='none'</span><span class="rlm">‏</span>، از شر حاشیه‌ی سیاه دور هر نقطه خلاص می‌شویم. نتیجه‌ی آن نموداری است که بر اساس یک گرادیان، از رنگ آبی روشن تا آبی تیره تغییر می‌کند، مانند <refFig xmlns="urn:dox:pycc">۱۵-۱۰</refFig>.</p><figure class="fig" id="ch15_fig10"><img class="fig" src="images/ch15_fig10.jpg"/><figcaption class="fig">شکل ۱۵-۱۰: رنگ‌آمیزی راه‌پیمایی تصادفی با نگاشت رنگ <span class="it">Blues</span>.</figcaption></figure></div><div class="sect" id="ch15lev3sec2"><a class="bkmk" name="ch15lev3sec2"></a><h5>رسم نقطه‌های اول و آخر</h5>
<p class="noindent">علاوه بر رنگ کردن نقطه‌ها برای نشان دادن موقعیت آن‌ها در طول مسیر، بد نیست که مشخص کنیم که هر راه‌پیمایی از کجا شروع می‌شود و کجا تمام می‌شود. بطظ می‌توانیم پس از ترسیم سری اصلی نقاط، نقطه‌های اول و آخر را جداگانه رنگ‌آمیزی کنیم. نقاط انتهایی را بزرگ‌تر می‌کنیم و با رنگ متفاوتی رنگ‌آمیزی می‌کنیم تا بهتر مشخص شوند، به این صورت:</p><div class="snippet"><div class="snippet-title" dir="ltr">rw_visual.py</div><pre class="snippet" dir="ltr"><span class="ash">--<span class="it">snip</span>--</span>
<span class="ash">while True:</span>
    <span class="ash">--<span class="it">snip</span>--</span>
    <span class="ash">ax.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues,</span>
        <span class="ash">edgecolors='none', s=15)</span>

    # Emphasize the first and last points.
    ax.scatter(0, 0, c='green', edgecolors='none', s=100)
    ax.scatter(rw.x_values[-1], rw.y_values[-1], c='red', edgecolors='none',
        s=100)

    <span class="ash">plt.show()</span>
    <span class="ash">--<span class="it">snip</span>--</span></pre></div><a id="p321"></a><p>برای مشخص کردن نقطه‌ی شروع، نقطه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">(0, 0)</span><span class="rlm">‏</span> را به رنگ سبز با انداز‌ه‌ی بزرگ‌تر (<span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">s=100</span><span class="rlm">‏</span>) نسبت به بقیه‌ی نقاط ترسیم می‌کنیم. برای مشخص کردن نقطه‌ی پایان، آخرین مقدار <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> در مسیر راه‌پیمایی را با رنگ قرمز و با انداز‌ه‌ی ۱۰۰ ترسیم می‌کنیم. دقت کنید که این کد را درست قبل از فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">plt.show()</span><span class="rlm">‏</span> وارد کنید، به‌طوری که نقطه‌های شروع و پایان روی نقطه‌های دیگر ترسیم شوند.</p><p>وقتی که این کد را اجرا می‌کنید، خواهید توانست دقیقاً مشخص کنید که هر راه‌پیمایی از کجا شروع می‌شود و کجا تمام می‌شود. (اگر این نقطه‌های پایانی به‌طور واضح برجسته نباشند، اندازه و رنگ آن‌ها را تنظیم کنید تا مشخص‌تر شوند.)</p></div><div class="sect" id="ch15lev3sec3"><a class="bkmk" name="ch15lev3sec3"></a><h5>پاک کردن محورها</h5>
<p class="noindent">حالا محورهای نمودار را حذف می‌کنیم تا حواسمان را از مسیر راه‌پیمایی پرت نکنند. برای خاموش کردن ترسیم محورها، از این کد استفاده کنید:</p><div class="snippet"><div class="snippet-title" dir="ltr">rw_visual.py</div><pre class="snippet" dir="ltr">
<span class="ash">--<span class="it">snip</span>--</span>
<span class="ash">while True:</span>
    <span class="ash">--<span class="it">snip</span>--</span>
    <span class="ash">ax.scatter(rw.x_values[-1], rw.y_values[-1], c='red', edgecolors='none',</span>
        <span class="ash">s=100)</span>

    # Remove the axes.
<span class="n" dir="ltr">1</span>    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)

    <span class="ash">plt.show()</span>
    <span class="ash">--<span class="it">snip</span>--</span></pre></div><p>برای تغییر دادن محورها، با استفاده از متدهای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">ax.get_xaxis()</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">ax.get_yaxis()</span><span class="rlm">‏</span> در <span class="n" dir="ltr">1</span>، برای نمایش هر محور مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">False</span><span class="rlm">‏</span> اختصاص می‌دهیم. در ادامه‌ی کارتان در زمینه‌ی مصورسازی، با این روش زنجیر کردن متدها مکرراً برخورد خواهید داشت.</p><p>حالا <span class="rlm">‏</span><span class="ident" dir="ltr">rw_visual.py</span><span class="rlm">‏</span> را اجرا کنید؛ یک سری نمودار بدون محور خواهید دید.</p></div><div class="sect" id="ch15lev3sec4"><a class="bkmk" name="ch15lev3sec4"></a><h5>اضافه کردن نقاط نمودار</h5>
<p class="noindent">می‌خواهیم تعداد نقطه‌ها را بیشتر کنیم تا بتوانیم با داده‌های بیشتری کار کنیم. برای این منظور، مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">num_points</span><span class="rlm">‏</span> را در هنگام ایجاد نمونه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">RandomWalk</span><span class="rlm">‏</span>، افزایش می‌دهیم، و اندازهعی نقطه‌ها را هنگام ترسیم نمودار تنظیم می‌کنیم، به‌صورت زیر:</p><div class="snippet"><div class="snippet-title" dir="ltr">rw_visual.py</div><pre class="snippet" dir="ltr"><span class="ash">--<span class="it">snip</span>--</span>
<span class="ash">while True:</span>
    <span class="ash"># Make a random walk.</span>
    rw = RandomWalk(50_000)
    <span class="ash">rw.fill_walk()</span>

    <span class="ash"># Plot the points in the walk.</span>
    <span class="ash">plt.style.use('classic')</span>
    <span class="ash">fig, ax = plt.subplots()</span>
    <span class="ash">point_numbers = range(rw.num_points)</span>
    ax.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues,
        edgecolor='none', s=1)
    <span class="ash">--<span class="it">snip</span>--</span></pre></div><a id="p322"></a><p>این مثال (به‌عنوان نمایشی از داده‌های دنیای واقعی) یک راه‌پیمایی تصادفی با ۵۰٬۰۰۰ نقطه ایجاد می‌کند و نقطه‌ها را با <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">s=1</span><span class="rlm">‏</span> ترسیم می‌نماید. راه‌پیمایی حاصله، که در <refFig xmlns="urn:dox:pycc">۱۵-۱۱</refFig> نشان داده شده است، انبوه و ابرمانند است. همان طور که می‌بینید، با استفاده از یک نمودار پراکندگی ساده، توانستیم یک اثر هنری خلق کنیم!</p><p>می‌توانید مقادیر این کد را برای امتحان تغییر دهید تا ببینید تا کجا می‌توانید تعداد نقاط راه‌پیمایی را افزایش دهید بدون آنکه عملکرد سیستم شما کُند شود یا اینکه جذابیت بصری نمودار کاهش یابد.</p><figure class="fig" id="ch15_fig11"><img class="fig" src="images/ch15_fig11.jpg"/><figcaption class="fig">شکل ۱۵-۱۱: یک راه‌پیمایی با ۵۰٬۰۰۰ نقطه.</figcaption></figure></div><div class="sect" id="ch15lev3sec5"><a class="bkmk" name="ch15lev3sec5"></a><h5>تغییر دادن اندازه برای پر کردن صفحه</h5>
<p class="noindent">مصورسازی زمانی در نمایش دادن الگوها کارایی بیشتری دارد که به خوبی صفحه را پر کرده باشد. برای اینکه پنجره‌ی نمودار بهتر در صفحه‌ی نمایش شما جا شود، اندازه‌ی خروجی <span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span> را به‌صورت زیر تنظیم کنید:</p><div class="snippet"><div class="snippet-title" dir="ltr">rw_visual.py</div><pre class="snippet" dir="ltr"><span class="ash">--<span class="it">snip</span>--</span>
<span class="ash">while True:</span>
    <span class="ash"># Make a random walk.</span>
    <span class="ash">rw = RandomWalk(50_000)</span>
    <span class="ash">rw.fill_walk()</span>

    <span class="ash"># Plot the points in the walk.</span>
    <span class="ash">plt.style.use('classic')</span>
    fig, ax = plt.subplots(figsize=(15, 9))
    <span class="ash">--<span class="it">snip</span>--</span></pre></div><p>هنگام ایجاد نمودار، می‌توانید با دادن آرگومان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">figsize</span><span class="rlm">‏</span>، اندازه‌ی شکل را تعیین کنید. پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">figsize</span><span class="rlm">‏</span> یک توپل می‌گیرد، و ابعاد پنجره‌ی نمودار را بر حسب اینچ برای <span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span> مشخص می‌کند.</p><p><span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span> فرض می‌کند که تفکیک‌پذیری صفحه‌ی نمایش شما ۱۰۰ پیکسل بر اینچ است؛ اگر اندازه‌ی نمودار در این کد برای شما مناسب نیست، می‌توانید اعداد را به میزان <a id="p323"></a>لازم تغییر دهید. یا اینکه اگر تفکیک‌پذیری سیستم خود را می‌دانید، می‌توانید آن را با استفاده از پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">dpi</span><span class="rlm">‏</span> به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">plt.subplots()</span><span class="rlm">‏</span> بدهید تا با تعیین اندازه‌ی مناسب نمودار، از فضای موجود در صفحه‌ی نمایش خود استفاده‌ی بهتری به عمل آورید، مانند کد زیر:</p><div class="snippet"><pre class="snippet" dir="ltr">fig, ax = plt.subplots(figsize=(10, 6), dpi=128)</pre></div><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<p class="tiy1"><span class="tiy" id="ch15_tiy03"><span class="tiy-num">۱۵-۳</span>. <span class="tiy-title">حرکت مولکولی</span>: </span> برنامه‌ی <span class="rlm">‏</span><span class="ident" dir="ltr">rw_visual.py</span><span class="rlm">‏</span> را تغییر دهید، به این صورت که در آن به جای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">plt.scatter()</span><span class="rlm">‏</span> از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">plt.plot()</span><span class="rlm">‏</span> استفاده کنید. برای اینکه حرکت یک دانه‌ی گرده را روی سطح یک قطره‌ی آب شبیه‌سازی کنید، مقادیر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rw.x_values</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rw.y_values</span><span class="rlm">‏</span> را به همراه آرگومان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">linewidth</span><span class="rlm">‏</span> به آن بدهید. به جای ۵۰٬۰۰۰ نقطه، از ۵۰۰۰ نقطه استفاده کنید.</p><p class="tiy1"><span class="tiy" id="ch15_tiy04"><span class="tiy-num">۱۵-۴</span>. <span class="tiy-title">راه‌پیمایی تصادفی با تغییرات</span>: </span> در کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">RandomWalk</span><span class="rlm">‏</span>، مقادیر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">x_step</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">y_step</span><span class="rlm">‏</span> بر اساس شرایط یکسانی تعیین می‌شود. جهت به‌صورت تصادفی از لیست <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">[1, -1]</span><span class="rlm">‏</span> انتخاب می‌شود، و مسافت از لیست <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">[0, 1, 2, 3, 4]</span><span class="rlm">‏</span>. مقادیر این لیست‌ها را تغییر دهید و ببینید که شکل کلی راه‌پیمایی‌ها چه تغییری می‌کند. برای مسافت از لیست طولانی‌تری، مثلاً از ۰ تا ۸، استفاده کنید، یا اینکه <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">-1</span><span class="rlm">‏</span> را از لیست جهت <span class="emphasis">x</span> یا <span class="emphasis">y</span> حذف کنید.</p><p class="tiy1"><span class="tiy" id="ch15_tiy05"><span class="tiy-num">۱۵-۵</span>. <span class="tiy-title">بازساخت</span>: </span> متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">fill_walk()</span><span class="rlm">‏</span> طولانی است. متد جدیدی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_step()</span><span class="rlm">‏</span> ایجاد کنید و که برای تعیین جهت و مسافت هر گام فراخوانی می‌شود، و سپس گام را محاسبه کنید. در نهایت، دو فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_step()</span><span class="rlm">‏</span> را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">fill_walk()</span><span class="rlm">‏</span> خواهید داشت:</p><div class="snippet"><pre class="snippet" dir="ltr">x_step = self.get_step()
y_step = self.get_step()</pre></div><p>این بازساخت اندازه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">fill_walk()</span><span class="rlm">‏</span> را کوچک‌تر می‌کند و سبب می‌شود که خواندن و فهمیدن متد آسان‌تر شود.</p></div></div></div></div><div class="sect" id="ch15lev1sec4"><a class="bkmk" name="ch15lev1sec4"></a><h3>تاس انداختن با <span class="rlm">‏</span><span class="lr" dir="ltr">Plotly</span><span class="rlm">‏</span></h3>
<p class="noindent">در این قسمت، از پکیج <span class="rlm">‏</span><span class="lr" dir="ltr">Plotly</span><span class="rlm">‏</span> برای انجام مصورسازی‌های تعاملی استفاده می‌کنیم. این پکیج خصوصاً برای مصورسازی‌هایی مفید است که می‌خواهید در مرورگر نمایش دهید، چرا که مصورسازی را می‌توان به خوبی بزرگ کرد تا تمام صفحه را پر کند. علاوه بر این، مصورسازی‌های حاصل از این پکیج تعاملی هستند؛ وقتی که کاربر نشانگر ماوس را روی برخی از عناصر صفحه می‌برد، اطلاعات درباره‌ی آن عنصر نمایش داده می‌شود.</p><p>در این پروژه، نتایج انداختن تاس را تحلیل خواهیم کرد. وقتی که یک تاس معمولی شش‌وجهی را می‌اندازید، احتمال یکسانی وجود دارد که هر کدام از اعداد ۱ تا ۶ بیاید. ولی وقتی که از دو تاس استفاده می‌کنید، احتمال آمدن بعضی اعداد بیشتر از اعداد دیگر است. در اینجا با تولید دادگانی که معرف انداختن تاس است، سعی می‌کنیم <a id="p324"></a>مشخص کنیم که احتمال آمدن چه اعدادی بیشتر است. سپس نموداری از نتایج دفعات زیاد انداختن تاس ترسیم خواهیم کرد تا مشخص شود چه نتایجی احتمال بیشتری دارند.</p><p>در ریاضیات غالباً از انداختن تاس برای توضیح انواع مختلف روش‌های تحلیل داده‌ها استفاده می‌شود. ولی این کار در بازی‌های قمار و نیز بازی‌هایی مانند مونوپولی و بسیاری بازی‌های نقش‌آفرینی نیز مورد استفاده قرار می‌گیرد.</p><div class="sect" id="ch15lev2sec15"><a class="bkmk" name="ch15lev2sec15"></a><h4>نصب <span class="rlm">‏</span><span class="lr" dir="ltr">Plotly</span><span class="rlm">‏</span></h4>
<p class="noindent">درست مانند <span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span>، این پکیج را هم با استفاده از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pip</span><span class="rlm">‏</span> نصب کنید:</p><div class="snippet"><pre class="snippet" dir="ltr">$ <span class="bo">python -m pip install --user plotly</span></pre></div><p>اگر هنگام نصب <span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span> از فرمانی مانند <span class="bo"><span class="rlm">‏</span><span class="lr" dir="ltr">python3</span><span class="rlm">‏</span></span> یا چیز دیگری استفاده کرده‌اید، در اینجا نیز همان فرمان را به کار بگیرید.</p><p>برای اینکه ببینید چه نوع مصورسازی‌هایی با <span class="rlm">‏</span><span class="lr" dir="ltr">Plotly</span><span class="rlm">‏</span> امکان‌پذیر است، از گالری انواع نمودار در نشانی <span class="rlm">‏</span><a dir="ltr" target="_blank" href="https://plot.ly/python/">https://plot.ly/python/</a><span class="rlm">‏</span> دیدن کنید. هر کدام از مثال‌ها حاوی سورس کد است، به‌طوری که می‌توانید ببینید که <span class="rlm">‏</span><span class="lr" dir="ltr">Plotly</span><span class="rlm">‏</span> نمودار را چگونه ایجاد کرده است.</p></div><div class="sect" id="ch15lev2sec16"><a class="bkmk" name="ch15lev2sec16"></a><h4>ایجاد کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Die</span><span class="rlm">‏</span></h4>
<p class="noindent">در اینجا، کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Die</span><span class="rlm">‏</span> را ایجاد می‌کنیم که انداختن تاس را شبیه‌سازی می‌کند:</p><div class="snippet"><div class="snippet-title" dir="ltr">die.py</div><pre class="snippet" dir="ltr">from random import randint

class Die:
    """A class representing a single die."""

<span class="n" dir="ltr">1</span>    def __init__(self, num_sides=6):
        """Assume a six-sided die."""
        self.num_sides = num_sides

    def roll(self):
        """"Return a random value between 1 and number of sides."""
<span class="n" dir="ltr">2</span>        return randint(1, self.num_sides)</pre></div><p>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> یک آرگومان اختیاری می‌گیرد. در کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Die</span><span class="rlm">‏</span>، وقتی که یک نمونه‌ی تاس ایجاد می‌شود، در صورتی که هیچ‌گونه آرگومانی داده نشود، تعداد وجه‌های تاس همیشه شش خواهد بود. اما اگر آرگومان داده شود، مقدار داده شده تعداد وجه‌های تاس را تعیین خواهد کرد <span class="n" dir="ltr">1</span>. (تاس بر اساس تعداد وجه‌های آن نام‌گذاری می‌شود: تاس شش‌وجهی <span class="rlm">‏</span><span class="lr" dir="ltr">D6</span><span class="rlm">‏</span> نامیده می‌شود، تاس هشت‌وجهی <span class="rlm">‏</span><span class="lr" dir="ltr">D8</span><span class="rlm">‏</span>، و الی آخر.)</p><p>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">roll()</span><span class="rlm">‏</span> با بهره‌گیری از تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">randint()</span><span class="rlm">‏</span>، یک عدد تصادفی بین ۱ و تعداد وجه‌ها برمی‌گرداند <span class="n" dir="ltr">2</span>. مقدار برگشتی این تابع ممکن است عدد شروع باشد (یعنی ۱)، یا عدد پایان (یعنی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">num_sides</span><span class="rlm">‏</span>)، و یا عدد صحیحی بین آن دو.</p></div><div class="sect" id="ch15lev2sec17"><a class="bkmk" name="ch15lev2sec17"></a><h4>انداختن تاس</h4>
<a id="p325"></a><p class="noindent">قبل از ایجاد مصورسازی بر اساس کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Die</span><span class="rlm">‏</span>، یک تاس <span class="rlm">‏</span><span class="lr" dir="ltr">D6</span><span class="rlm">‏</span> را می‌اندازیم، نتایج آن را نمایش می‌دهیم، و درست بودن آن را بررسی می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">die_visual.py</div><pre class="snippet" dir="ltr">from die import Die

# Create a D6.
<span class="n" dir="ltr">1</span>die = Die()

# Make some rolls, and store results in a list.
results = []
<span class="n" dir="ltr">2</span>for roll_num in range(100):
    result = die.roll()
    results.append(result)

print(results)</pre></div><p>در <span class="n" dir="ltr">1</span>، یک نمونه از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Die</span><span class="rlm">‏</span> با تعداد وجه پیش‌فرض شش ایجاد می‌کنیم. در <span class="n" dir="ltr">2</span>، تاس را ۱۰۰ بار می‌اندازیم و نتایج هر بار انداختن تاس را در لیست <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">results</span><span class="rlm">‏</span> ذخیره می‌کنیم. یک سری از نتایج حاصله به‌صورت زیر است:</p><div class="snippet"><pre class="snippet" dir="ltr">[4, 6, 5, 6, 1, 5, 6, 3, 5, 3, 5, 3, 2, 2, 1, 3, 1, 5, 3, 6, 3, 6, 5, 4,
 1, 1, 4, 2, 3, 6, 4, 2, 6, 4, 1, 3, 2, 5, 6, 3, 6, 2, 1, 1, 3, 4, 1, 4,
 3, 5, 1, 4, 5, 5, 2, 3, 3, 1, 2, 3, 5, 6, 2, 5, 6, 1, 3, 2, 1, 1, 1, 6,
 5, 5, 2, 2, 6, 4, 1, 4, 5, 1, 1, 1, 4, 5, 3, 3, 1, 3, 5, 4, 5, 6, 5, 4,
 1, 5, 1, 2]</pre></div><p>نگاه سریعی به این نتایج نشان می‌دهد که کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Die</span><span class="rlm">‏</span> ظاهراً درست کار می‌کند. در اینجا مقادیر ۱ تا ۶ را می‌بینیم، پس معلوم می‌شود که کوچک‌ترین و بزرگ‌ترین مقادیر در محدوده‌ی مورد نظر است، و از آنجا که مقادیر ۰ یا ۷ را در اینجا نمی‌بینیم، پس معلوم می‌شود که نتایج در دامنه‌ی مناسب هستند. هم‌چنین، تمام اعداد بین ۱ تا ۶ را در اینجا می‌بینیم، که نشان می‌دهد که تمام پیامدهای ممکن در میان نتایج هستند. ببینیم که هر عدد دقیقاً چند بار آمده است.</p></div><div class="sect" id="ch15lev2sec18"><a class="bkmk" name="ch15lev2sec18"></a><h4>تحلیل نتایج</h4>
<p class="noindent">نتایج انداختن تاس <span class="rlm">‏</span><span class="lr" dir="ltr">D6</span><span class="rlm">‏</span> را با شمارش اینکه هر عدد چند بار آمده است، تحلیل می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">die_visual.py</div><pre class="snippet" dir="ltr">
<span class="ash">--<span class="it">snip</span>--</span>
<span class="ash"># Make some rolls, and store results in a list.</span>
<span class="ash">results = []</span>
<span class="n" dir="ltr">1</span>for roll_num in range(1000):
    <span class="ash">result = die.roll()</span>
    <span class="ash">results.append(result)</span>

# Analyze the results.
frequencies = []
<span class="n" dir="ltr">2</span>for value in range(1, die.num_sides+1):
<span class="n" dir="ltr">3</span>  frequency = results.count(value)
<a id="p326"></a><span class="n" dir="ltr">4</span>    frequencies.append(frequency)

print(frequencies)</pre></div><p>از آنجا که دیگر نتایج را پرینت نمی‌کنیم، لذا می‌توانیم تعداد موارد شبیه‌سازی را به ۱۰۰۰ بار افزایش دهیم <span class="n" dir="ltr">1</span>. برای تحلیل نتایج، لیست خالی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">frequencies</span><span class="rlm">‏</span> را ایجاد می‌کنیم تا تعداد دفعاتی را که هر عدد می‌آید، در آن ذخیره کنیم. در <span class="n" dir="ltr">2</span>، روی مقادیر ممکن (که در این حالت، اعداد ۱ تا ۶ هستند) حلقه‌ای تشکیل می‌دهیم، و می‌شماریم که هر کدام از آن‌ها چند بار در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">results</span><span class="rlm">‏</span> ظاهر می‌شوند <span class="n" dir="ltr">3</span>، و سپس این مقدار را به لیست <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">frequencies</span><span class="rlm">‏</span> اضافه می‌کنیم <span class="n" dir="ltr">4</span>. آنگاه، این لیست را پرینت می‌کنیم و مصورسازی را ایجاد می‌کنیم:</p><div class="snippet"><pre class="snippet" dir="ltr">[155, 167, 168, 170, 159, 181]</pre></div><p>این نتایج معقول به نظر می‌رسند: شش تا فراوانی داریم، یعنی یکی برای هر کدام از اعدادی که ممکن است با انداختن یک تاس <span class="rlm">‏</span><span class="lr" dir="ltr">D6</span><span class="rlm">‏</span> حاصل شود، و می‌بینیم که هیچ‌کدام از فراوانی‌ها به‌طور قابل‌توجهی از بقیه بالاتر نیست. حالا نتایج را مصورسازی می‌کنیم.</p></div><div class="sect" id="ch15lev2sec19"><a class="bkmk" name="ch15lev2sec19"></a><h4>ایجاد یک هیستوگرام</h4>
<p class="noindent">با داشتن لیست فراوانی‌ها، می‌توانیم یک <span class="emphasis">هیستوگرام</span> از آن‌ها ایجاد کنیم. هیستوگرام یک نمودار ستونی است که فراوانی هر کدام از نتایج را نشان می‌دهد. کد ایجاد هیستوگرام به‌صورت زیر است:</p><div class="snippet"><div class="snippet-title" dir="ltr">die_visual.py</div><pre class="snippet" dir="ltr">from plotly.graph_objs import Bar, Layout
from plotly import offline

<span class="ash">from die import Die</span>
<span class="ash">--<span class="it">snip</span>--</span>

<span class="ash"># Analyze the results.</span>
<span class="ash">frequencies = []</span>
<span class="ash">for value in range(1, die.num_sides+1):</span>
    <span class="ash">frequency = results.count(value)</span>
    <span class="ash">frequencies.append(frequency)</span>

# Visualize the results.
<span class="n" dir="ltr">1</span>x_values = list(range(1, die.num_sides+1))
<span class="n" dir="ltr">2</span>data = [Bar(x=x_values, y=frequencies)]

<span class="n" dir="ltr">3</span>x_axis_config = {'title': 'Result'}
y_axis_config = {'title': 'Frequency of Result'}
<span class="n" dir="ltr">4</span>my_layout = Layout(title='Results of rolling one D6 1000 times',
        xaxis=x_axis_config, yaxis=y_axis_config)
<span class="n" dir="ltr">5</span>offline.plot({'data': data, 'layout': my_layout}, filename='d6.html')</pre></div><p>برای ایجاد هیستوگرام، نیاز به یک ستون برای هر کدام از نتایج ممکن داریم. این‌ها را در لیستی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">x_values</span><span class="rlm">‏</span> ذخیره می‌کنیم، که از ۱ شروع می‌شود و به تعداد وجه‌های تاس ختم می‌شود <span class="n" dir="ltr">1</span>. <span class="rlm">‏</span><span class="lr" dir="ltr">Plotly</span><span class="rlm">‏</span> نتایج تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">range()</span><span class="rlm">‏</span> را به‌صورت مستقیم قبول نمی‌کند، لذا لازم است که دامنه را به‌صورت صریح با استفاده از <a id="p327"></a>تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">list()</span><span class="rlm">‏</span> به لیست تبدیل کنیم. کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Bar()</span><span class="rlm">‏</span> از پکیج <span class="rlm">‏</span><span class="lr" dir="ltr">Plotly</span><span class="rlm">‏</span> نشان‌دهنده‌ی دادگانی است که به‌صورت یک نمودار ستونی مصورسازی خواهد شد <span class="n" dir="ltr">2</span>. این کلاس نیاز به لیستی از مقادیر <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> و لیستی از مقادیر <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> دارد. این کلاس باید داخل کروشه قرار داده شود، چرا که دادگان ممکن است عناصر متعدد داشته باشد.</p><p>هر محور را می‌توان به طرق مختلفی پیکربندی کرد، و هر گزینه‌ی پیکربندی به‌صورت درایه‌ای در یک دیکشنری ذخیره می‌شود. در اینجا، فقط عنوان هر محور را تعیین می‌کنیم <span class="n" dir="ltr">3</span>. کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Layout()</span><span class="rlm">‏</span> شیئی است که چیدمان و پیکربندی کلی نمودار را مشخص می‌کند <span class="n" dir="ltr">4</span>. در اینجا، عنوان نمودار را تعیین می‌کنیم و دیکشنری‌های پیکربندی محورهای <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> را نیز به آن می‌دهیم.</p><p>برای ایجاد نمودار، تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">offline.plot()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم <span class="n" dir="ltr">5</span>. این تابع نیاز به یک دیکشنری حاوی داده‌ها و اشیای چیدمان دارد، و یک نام فایل نیز می‌گیرد که نمودار را در آن ذخیره می‌کند. ما خروجی را در فایلی به نام <span class="rlm">‏</span><span class="ident" dir="ltr">d6.html</span><span class="rlm">‏</span> ذخیره می‌کنیم.</p><p>وقتی که برنامه‌ی <span class="rlm">‏</span><span class="ident" dir="ltr">die_visual.py</span><span class="rlm">‏</span> را اجرا می‌کنید، احتمالاً مرورگر شما باز خواهد شد و فایل <span class="rlm">‏</span><span class="ident" dir="ltr">d6.html</span><span class="rlm">‏</span> را نمایش خواهد داد. اگر این کار به‌طور خودکار انجام نشود، می‌توانید یک صفحه را در مرورگر وب خود باز کنید و فایل <span class="rlm">‏</span><span class="ident" dir="ltr">d6.html</span><span class="rlm">‏</span> را (در همان پوشه‌ای که فایل <span class="rlm">‏</span><span class="ident" dir="ltr">die_visual.py</span><span class="rlm">‏</span> را در آن ذخیره کرده‌اید) باز کنید. نموداری خواهید دید که مشابه نمودار <refFig xmlns="urn:dox:pycc">۱۵-۱۲</refFig> است. (من این نمودار را برای چاپ کمی تغییر داده‌ام؛ <span class="rlm">‏</span><span class="lr" dir="ltr">Plotly</span><span class="rlm">‏</span> به‌طور پیش‌فرض از فونت کوچک‌تری برای نمودارها استفاده می‌کند.)</p><figure class="fig" id="ch15_fig12"><img class="fig" src="images/ch15_fig12.jpg"/><figcaption class="fig">شکل ۱۵-۱۲: یک نمودار ستونی ساده‌ی ایجاد شده با <span class="rlm">‏</span><span class="lr" dir="ltr">Plotly</span><span class="rlm">‏</span>.</figcaption></figure><p>دقت کنید که <span class="rlm">‏</span><span class="lr" dir="ltr">Plotly</span><span class="rlm">‏</span> نمودار را تعاملی کرده است: اگر نشانگر ماوس را روی هر کدام از ستون‌های نمودار ببرید، داده‌های مربوط به آن ظاهر می‌شود. این ویژگی خصوصاً برای زمانی که چندین دادگان را روی یک نمودار ترسیم می‌کنید، سودمند است. اگر دقت کنید، در سمت راست بالای نمودار نیز آیکون‌هایی قرار دارد که به شما امکان می‌دهد که مصورسازی را جابه‌جا کنید یا زوم کنید، و نیز می‌توانید آن را به‌صورت تصویر ذخیره کنید.</p></div><div class="sect" id="ch15lev2sec20"><a class="bkmk" name="ch15lev2sec20"></a><h4>انداختن دو تاس</h4>
<a id="p328"></a><p class="noindent">انداختن دو تاس منجر به اعداد بزرگ‌تری می‌شود و توزیع نتایج نیز متفاوت است. در اینجا، کدمان را تغییر می‌دهیم و دو تاس <span class="rlm">‏</span><span class="lr" dir="ltr">D6</span><span class="rlm">‏</span> ایجاد می‌کنیم تا انداختن یک جفت تاس را شبیه‌سازی کنیم. هر بار که جفت تاس را می‌اندازیم، دو عددی را که می‌آید (از هر تاس، یک عدد)، جمع می‌زنیم و مجموع را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">results</span><span class="rlm">‏</span> ذخیره می‌کنیم. یک نسخه از فایل <span class="rlm">‏</span><span class="ident" dir="ltr">die_visual.py</span><span class="rlm">‏</span> را با نام <span class="rlm">‏</span><span class="ident" dir="ltr">dice_visual.py</span><span class="rlm">‏</span> ضبط کنید و تغییرات زیر را در آن اعمال کنید:</p><div class="snippet"><div class="snippet-title" dir="ltr">dice_visual.py</div><pre class="snippet" dir="ltr"><span class="ash">from plotly.graph_objs import Bar, Layout</span>
<span class="ash">from plotly import offline</span>

<span class="ash">from die import Die</span>

# Create two D6 dice.
die_1 = Die()
die_2 = Die()

<span class="ash"># Make some rolls, and store results in a list.</span>
<span class="ash">results = []</span>
<span class="ash">for roll_num in range(1000):</span>
<span class="n" dir="ltr">1</span>    result = die_1.roll() + die_2.roll()
    <span class="ash">results.append(result)</span>


<span class="ash"># Analyze the results.</span>

<span class="ash">frequencies = []</span>
<span class="n" dir="ltr">2</span>max_result = die_1.num_sides + die_2.num_sides
<span class="n" dir="ltr">3</span>for value in range(2, max_result+1):
    <span class="ash">frequency = results.count(value)</span>
    <span class="ash">frequencies.append(frequency)</span>

<span class="ash"># Visualize the results.</span>
x_values = list(range(2, max_result+1))
<span class="ash">data = [Bar(x=x_values, y=frequencies)]</span>

<span class="n" dir="ltr">4</span>x_axis_config = {'title': 'Result', 'dtick': 1}
<span class="ash">y_axis_config = {'title': 'Frequency of Result'}</span>
my_layout = Layout(title='Results of rolling two D6 dice 1000 times',
        <span class="ash">xaxis=x_axis_config, yaxis=y_axis_config)</span>
offline.plot({'data': data, 'layout': my_layout}, filename='d6_d6.html')</pre></div><p>پس از ایجاد دو نمونه از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Die</span><span class="rlm">‏</span>، تاس‌ها را می‌اندازیم و مجموع اعداد آن‌ها را محاسبه می‌کنیم <span class="n" dir="ltr">1</span>. بزرگ‌ترین نتیجه‌ی ممکن (۱۲) مجموع بزرگ‌ترین عدد هر تاس است، که آن را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">max_result</span><span class="rlm">‏</span> ذخیره می‌کنیم <span class="n" dir="ltr">2</span>. کوچک‌ترین نتیجه‌ی ممکن (۲) مجموع کوچک‌ترین عدد هر تاس است. برای تحلیل نتایج، تعداد هر کدام از نتایج بین ۲ و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">max_result</span><span class="rlm">‏</span> را می‌شماریم <span class="n" dir="ltr">3</span>. (می‌توانستیم از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">range(2, 13)</span><span class="rlm">‏</span> استفاده کنیم، ولی این فقط برای دو تاس <span class="rlm">‏</span><span class="lr" dir="ltr">D6</span><span class="rlm">‏</span> مناسب می‌بود. هنگام مدل‌سازی موقعیت‌های دنیای واقعی، بهتر است کد را به‌صورتی بنویسیم که به راحتی امکان مدل‌سازی موقعیت‌های مختلف را داشته باشد. این کد به ما امکان می‌دهد که انداتن دو تاس بال هر تعداد وجه را شبیه‌سازی کنیم.)</p><p>هنگام ایجاد نمودار، کلید <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">dtick</span><span class="rlm">‏</span> را نیز در دیکشنری <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">x_axis_config</span><span class="rlm">‏</span> منظور می‌کنیم <span class="n" dir="ltr">4</span>. این تنظیم فاصله‌ی بین تیک‌مارک‌های روی محور <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> را کنترل می‌کند. حالا که تعداد ستون‌های هیستوگرام زیاد است، <a id="p329"></a>تنظیمات پیش‌فرض پلاتلی به‌گونه‌ای است که فقط بعضی از ستون‌ها را برچسب می‌زند. تنظیم <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">'dtick': 1</span><span class="rlm">‏</span> به پلاتلی می‌گوید که هر یک از تیک‌مارک‌‌ها را برچسب بزند. عنوان نمودار و نام فایل خروجی را هم تغییر می‌دهیم.</p><p>پس از اجرا کردن این کد، نموداری شبیه نمودار نشان داده شده در <refFig xmlns="urn:dox:pycc">۱۵-۱۳</refFig> خواهید دید.</p><figure class="fig" id="ch15_fig13"><img class="fig" src="images/ch15_fig13.jpg"/><figcaption class="fig">شکل ۱۵-۱۳: نتیجه شبیه‌سازی شده‌ی ۱۰۰۰ بار انداختن دو تاس شش‌وجهی.</figcaption></figure><p>این نمودار نتایج تقریبی را با انداختن یک جفت تاس <span class="rlm">‏</span><span class="lr" dir="ltr">D6</span><span class="rlm">‏</span> نشان می‌دهد. همان طور که می‌بینید، کمترین احتمال مربوط به آمدن اعداد ۲ و ۱۲ است و بیشترین احتمال مربوط به عدد ۷. علت آن است که شش حالت برای آمدن عدد ۷ وجود دارد، شامل: ۱ و ۶، ۲ و ۵، ۳ و ۴، ۴ و ۳، ۵ و ۲، و یا ۶ و ۱.</p></div><div class="sect" id="ch15lev2sec21"><a class="bkmk" name="ch15lev2sec21"></a><h4>انداختن تاس‌هایی با اندازه‌ی متفاوت</h4>
<p class="noindent">در اینجا یک تاس شش‌وجهی و یک تاس ده‌وجهی ایجاد می‌کنیم، و می‌بینیم که اگر آن‌ها را ۵۰٬۰۰۰ بار بیندازیم، چه اتفاقی می‌افتد:</p><div class="snippet"><div class="snippet-title" dir="ltr">dice_visual.py</div><pre class="snippet" dir="ltr"><span class="ash">from plotly.graph_objs import Bar, Layout</span>
<span class="ash">from plotly import offline</span>

<span class="ash">from die import Die</span>

# Create a D6 and a D10.
<span class="ash">die_1 = Die()</span>
<span class="n" dir="ltr">1</span>die_2 = Die(10)

<span class="ash"># Make some rolls, and store results in a list.</span>
<span class="ash">results = []</span>
for roll_num in range(50_000):
    <span class="ash">result = die_1.roll() + die_2.roll()</span>
    <span class="ash">results.append(result)</span>

<a id="p330"></a><span class="ash"># Analyze the results.</span>
<span class="ash">--<span class="it">snip</span>--</span>

<span class="ash"># Visualize the results.</span>
<span class="ash">x_values = list(range(2, max_result+1))</span>
<span class="ash">data = [Bar(x=x_values, y=frequencies)]</span>

<span class="ash">x_axis_config = {'title': 'Result', 'dtick': 1}</span>
<span class="ash">y_axis_config = {'title': 'Frequency of Result'}</span>
<span class="n" dir="ltr">2</span>my_layout = Layout(title='Results of rolling a D6 and a D10 50000 times',
        <span class="ash">xaxis=x_axis_config, yaxis=y_axis_config)</span>
offline.plot({'data': data, 'layout': my_layout}, filename='d6_d10.html')</pre></div><p>برای ساحتن تاس <span class="rlm">‏</span><span class="lr" dir="ltr">D10</span><span class="rlm">‏</span>، آرگومان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">10</span><span class="rlm">‏</span> را هنگام ایجاد دومین نمونه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Die</span><span class="rlm">‏</span> به آن می‌دهیم <span class="n" dir="ltr">1</span>، و حلقه‌ی اول را تغییر می‌دهیم تا به جای هزار بار، ۵۰٬۰۰۰ بار تاس بیندازد. عنوان نمودار را تغییر می‌دهیم و نام فایل خروجی را نیز اصلاح می‌کنیم <span class="n" dir="ltr">2</span>.</p><p><refFig xmlns="urn:dox:pycc">۱۵-۱۴</refFig> نمودار حاصله را نشان می‌دهد. در اینجا، محتمل‌ترین نتایج به جای یکی، پنج تا هستند. علت آن است که باز هم فقط یک حالت برای آمدن کوچک‌ترین نتیجه (۱ و ۱) و بزرگ‌ترین نتیجه (۶ و ۱۰) وجود دارد، ولی تعداد حالت‌های ایجاد کننده‌ی اعداد میانی به علت تاس کوچک‌تر، محدود می‌شود: برای آمدن هر کدام از اعداد ۷، ۸، ۹، ۱۰، و ۱۱، شش حالت وجود دارد. بنابراین، این‌ها شایع‌ترین نتایج هستند و احتمال آمدن هر کدام از این اعداد یکسان است.</p><figure class="fig" id="ch15_fig14"><img class="fig" src="images/ch15_fig14.jpg"/><figcaption class="fig">شکل ۱۵-۱۴: نتایج انداختن یک تاس شش‌وجهی و یک تاس ده‌وجهی به تعداد ۵۰٬۰۰۰ بار.</figcaption></figure><p>با توجه به اینکه می‌توانیم انداختن تاس را با پلاتلی مدل‌سازی کنیم، آزادی عمل قابل‌توجهی در بررسی این پدیده داریم. در واقع، ظرف چند دقیقه، می‌توانید تعداد عظیمی دفعات انداختن تاس را با انواع مختلف تاس شبیه‌سازی کنید.</p><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<a id="p331"></a><p class="tiy1"><span class="tiy" id="ch15_tiy06"><span class="tiy-num">۱۵-۶</span>. <span class="tiy-title">دو تاس <span class="rlm">‏</span><span class="lr" dir="ltr">D8</span><span class="rlm">‏</span></span>: </span> یک شبیه‌سازی ایجاد کنید و ببینید که وقتی دو تاس هشت‌وجهی را ۱۰۰۰ بار بیندازید، چه اتفاقی می‌افتد. قبل از اجرای شبیه‌سازی، سعی کنید در ذهنتان تصور کنید که مصورسازی به چه شکلی خواهد بود؛ سپس ببینید که فکرتان درست بوده یا نه. به‌تدریج تعداد پرتاب‌ها را افتاده‌اید تا آنکه حد قابلیت‌های سیستم برایتان آشکار شود.</p><p class="tiy1"><span class="tiy" id="ch15_tiy07"><span class="tiy-num">۱۵-۷</span>. <span class="tiy-title">سه تاس</span>: </span> وقتی که سه تاس <span class="rlm">‏</span><span class="lr" dir="ltr">D6</span><span class="rlm">‏</span> را می‌اندازید، کوچک‌ترین عددی که حاصل می‌شود، ۳ است، و بزرگ‌ترین عدد، ۱۸. یک مصورسازی ایجاد کنید که نشان دهد با انداختن سه تاس چه اتفاقی می‌افتد.</p><p class="tiy1"><span class="tiy" id="ch15_tiy08"><span class="tiy-num">۱۵-۸</span>. <span class="tiy-title">ضرب</span>: </span> وقتی دو تاس می‌اندازید، معمولاً دو عدد را با هم جمع می‌کنید تا نتیجه به دست آید. یک مصورسازی درست کنید و ببینید که اگر این دو عدد را به جای جمع کردن در هم ضرب کنید، چه اتفاقی می‌افتد.</p><p class="tiy1"><span class="tiy" id="ch15_tiy09"><span class="tiy-num">۱۵-۹</span>. <span class="tiy-title">کامپریهنشن تاس</span>: </span> در برنامه‌های این قسمت برای اینکه مطالب راحت‌تر قابل‌درک باشد، از شکل طولانی حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">for</span><span class="rlm">‏</span> استفاده شده است. در صورتی که شما با روش کامپریهنشن لیست آشنا هستید، برای یکی از حلقه‌های هر کدام از این برنامه‌ها یا برای هر دو حلقه از روش کامپریهنشن استفاده کنید.</p><p class="tiy1"><span class="tiy" id="ch15_tiy10"><span class="tiy-num">۱۵-۱۰</span>. <span class="tiy-title">تمرین با هر دو کتابخانه</span>: </span> از کتابخانه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span> برای مصورسازی انداختن تاس و از کتابخانه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Plotly</span><span class="rlm">‏</span> برای مصورسازی راه‌پیمایی تصادفی استفاده کنید. (برای انجام این تمرین، نیاز خواهید داشت که به مستندات این کتابخانه‌ها مراجعه کنید.)</p></div></div></div><div class="sect" id="ch15lev1sec5"><a class="bkmk" name="ch15lev1sec5"></a><h3>خلاصه</h3>
<p class="noindent">در این فصل، چگونگی ایجاد دادگان و انجام مصورسازی برای آن داده‌ها را فراگرفتید. نمودارهای ساده‌ای را با <span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span> ایجاد کردید، و با استفاده از نمودار پراکندگی، راه‌پیمایی تصادفی را بررسی کردید. هم‌چنین، با استفاده از <span class="rlm">‏</span><span class="lr" dir="ltr">Plotly</span><span class="rlm">‏</span>، هیستوگرامن ایجاد کردید و به کمک هیستوگرام، نتایج انداختن تاس‌هایی با اندازه‌های مختلف را بررسی کردید.</p><p>ایجاد داده‌ها با استفاده از کد، روشی جالب و قدرتمند برای مدل‌سازی و کاوش انواع مختلف موقعیت‌های دنیای واقعی است. ضمن انجام مصورسازی داده‌ها برای پروژه‌های بعدی، حواستان به موقعیت‌هایی که می‌توانید آن‌ها را با کد مدل‌سازی کنید، باشد. به مصورسازی‌هایی که در رسانه‌های خبری می‌بینید، دقت کنید، و سعی کنید مواردی را که با روش‌های ذکر شده در این پروژه‌ها ایجاد شده‌اند، شناسایی کنید.</p><p>در <span class="ref"><a href="c30-ch16.xhtml">فصل ۱۶</a></span>، داده‌ها را از منابع آنلاین دانلود خواهید کرد و باز هم با استفاده از <span class="rlm">‏</span><span class="lr" dir="ltr">Matplotlib</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="lr" dir="ltr">Plotly</span><span class="rlm">‏</span>، به کاوش آن داده‌ها خواهید پرداخت.</p><a id="p332"></a></div></div>
						<div class="row pager"><div class="col-md-5 text-center text-md-left pager-prev"><a href="c28-prj2.xhtml"><span xmlns="http://www.w3.org/1999/xhtml"><span>پروژه‌ی ۲</span>: <span>مصورسازی داده‌ها</span></span></a></div><div class="col-md-2 text-center pager-title"><a href="c01-cover.xhtml">آغاز</a></div><div class="col-md-5 text-center text-md-right pager-next"><a href="c30-ch16.xhtml"><span xmlns="http://www.w3.org/1999/xhtml"><span>فصل ۱۶</span>: <span>دانلود داده‌ها</span></span></a></div></div></main><aside class="col-md-2 order-md-first"><ul class="nav nav-pills flex-column"><li class="nav-item"><a class="nav-link" href="../">دوره‌ی فشرده‌ی پایتون</a></li><li class="nav-item"><a class="nav-link" href="c06-toc.xhtml">فهرست</a></li></ul></aside></div></div><div class="container"><div id="footer" class="row"><div class="col-sm-6"><p><span>© ۱۴۰۰، قاسم کیانی مقدم.</span></p></div><div class="col-sm-6"><p class="text-right"><span><a target="_blank" rel="me" href="https://linkedin.com/in/ghasemkiani" title="لینکدین"><span class="fab fa-linkedin"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://github.com/ghasemkiani" title="گیت‌هاب"><span class="fab fa-github"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://twitter.com/ghasemkiani" title="توئیتر"><span class="fab fa-twitter"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://facebook.com/ghasemkiani" title="فیس‌بوک"><span class="fab fa-facebook"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://telegram.me/ghasemkiani" title="تلگرام"><span class="fab fa-telegram"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://instagram.com/ghasem.kiani" title="اینستاگرام"><span class="fab fa-instagram"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://mastodon.social/@ghasemkiani" title="ماستودون"><span class="fab fa-mastodon"></span></a></span></p></div></div></div><script crossorigin="anonymous" src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"></script><script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut"></script><script crossorigin="anonymous" src="https://cdn.rtlcss.com/bootstrap/v4.0.0/js/bootstrap.min.js" integrity="sha384-54+cucJ4QbVb99v8dcttx/0JRx4FHMmhOWi4W+xrXpKcsKQodCBwAvu3xxkZAwsH"></script><script src="https://www.googletagmanager.com/gtag/js?id=UA-135468998-1"></script><script src="data:application/javascript;charset=UTF-8;base64,KCh7aWR9KSA9PiB7Cgl3aW5kb3cuZGF0YUxheWVyID0gd2luZG93LmRhdGFMYXllciB8fCBbXTsKCWZ1bmN0aW9uIGd0YWcoKXtkYXRhTGF5ZXIucHVzaChhcmd1bWVudHMpO30KCWd0YWcoImpzIiwgbmV3IERhdGUoKSk7CgoJZ3RhZygiY29uZmlnIiwgaWQpOwp9KSh7ImlkIjoiVUEtMTM1NDY4OTk4LTEifSk7Cg=="></script></body></html>