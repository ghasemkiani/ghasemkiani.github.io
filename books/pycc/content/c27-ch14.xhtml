<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="fa" dir="rtl"><head><meta charset="utf-8"/><title>امتیازدهی</title><meta name="description" content="وب‌سایت قاسم کیانی مقدم"/><meta name="keywords" content="قاسم کیانی مقدم, وب‌سایت, وب‌سایت قاسم کیانی مقدم, کتاب, فارسی, کتاب فارسی, ترجمه, برنامه‌نویسی, جاوا, جاوا اسکریپت, پزشکی, طب اطفال"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="stylesheet" crossorigin="anonymous" href="https://cdn.rtlcss.com/bootstrap/v4.0.0/css/bootstrap.min.css" integrity="sha384-P4uhUIGk/q1gaD/NdgkBIl3a6QywJjlsFJFk7SPRdruoGddvRVSwv5qFnvZ73cpz"/><link rel="stylesheet" crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.7.1/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr"/><link rel="icon" href="../../../favicon.ico"/><style>@import url(https://fonts.googleapis.com/css?family=Droid%20Sans);
@import url(https://fonts.googleapis.com/css?family=Droid%20Serif);
@import url(https://fonts.googleapis.com/css?family=Droid%20Arabic%20Kufi);
@import url(https://fonts.googleapis.com/css?family=Droid%20Arabic%20Naskh);
html,body,input,textarea,select,option,h1,h2,h3,h4,h5,h6{font-family:Droid Arabic Naskh,Droid Serif;}
nav,.nav{font-family:Droid Arabic Kufi,Droid Sans;}
h1,h2,h3,h4,h5,h6{font-family:Droid Arabic Naskh,Droid Serif;}
#footer{margin-top:0.5rem;padding-top:0.5rem;border-top:#eeeeee solid thick;}</style><style>@import url(https://fonts.googleapis.com/css?family=Courier+Prime);
div.row.pager{margin-top:0.5em;padding:0.5em 0;border-top:solid #cccccc 2px;background-color:#dddddd;}
div.pager-prev{}
div.pager-title{}
div.pager-next{}</style><link rel="stylesheet" type="text/css" href="styles.css"/></head><body style="min-height:75rem;"><nav class="navbar navbar-expand-md navbar-dark bg-dark mb-4"><div class="container"><a class="navbar-brand" href="../../../">وب‌سایت قاسم کیانی مقدم</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#divNavBarToggle" aria-controls="divNavBarToggle" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div id="divNavBarToggle" class="collapse navbar-collapse"><ul class="navbar-nav mr-auto"><li class="nav-item active"><a class="nav-link" href="../../">کتاب‌ها<span class="sr-only"> (current)</span></a></li><li class="nav-item"><a class="nav-link" href="../../../essays/">مقالات</a></li><li class="nav-item"><a class="nav-link" href="../../../translation/">ترجمه</a></li><li class="nav-item"><a class="nav-link" href="../../../about/">درباره</a></li><li class="nav-item"><a class="nav-link" href="../../../contact/">تماس</a></li></ul></div></div></nav><div class="container"><div class="row"><main class="col-md-10 order-md-last">
							<div class="ch" id="ch14"><h2 class="ch-title"><a class="bkmk" name="ch14"></a><a class="rtoc" href="c06-toc.xhtml"><span class="ch-title-num">۱۴</span><br/><span class="ch-title-text">امتیازدهی</span></a></h2><img style="float:right;margin-left:0.5em;margin-bottom:0.25em;" alt="تصویر ابتدای فصل" src="images/ch.svg"/>
<a id="p279"></a><p class="noindent">در این فصل، بازی <span class="emphasis">تهاجم بیگانگان</span> را کامل می‌کنیم. یک دکمه‌ی شروع اضافه می‌کنیم تا بازیکن بتواند بازی را در زمان دلخواه شروع کند، یا اینکه وقتی بازی تمام شد، آن را دوباره آغاز نماید. تغییر دیگری نیز در بازی ایجاد خواهیم کرد تا وقتی بازیکن به سطح بالاتر می‌رود، سرعت بازی بیشتر شود، و سیستم امتیازدهی را پیاده‌سازی خواهیم کرد. در پایان فصل، به خوبی خواهید توانست بازی‌هایی بنویسید که با پیشرفت بازیکن، دشواری آن‌ها بیشتر می‌شود و امتیاز بازیکن را هم نمایش می‌دهند.</p><div class="sect" id="ch14lev1sec1"><a class="bkmk" name="ch14lev1sec1"></a><h3>افزودن دکمه‌ی شروع</h3>
<a id="p280"></a><p class="noindent">در این قسمت، یک دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> اضافه می‌کنیم که در ابتدای شروع بازی ظاهر می‌شود، و پس از تمام شدن بازی هم دوباره پدیدار می‌گردد تا بازیکن بتواند دوباره بازی کند.</p><p>در حال حاضر، از همان زمانی که فایل <span class="rlm">‏</span><span class="ident" dir="ltr">alien_invasion.py</span><span class="rlm">‏</span> را اجرا می‌کنید، بازی شروع می‌شود. ولی می‌خواهیم بازی را در حالت غیرفعال آغاز کنیم و سپس از کاربر بخواهیم که برای شروع بازی، روی دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> کلیک کند. برای این منظور، متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> از کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">GameStats</span><span class="rlm">‏</span> را به‌صورت زیر تغییر می‌دهیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">game_stats.py</div><pre class="snippet" dir="ltr">    <span class="ash">def __init__(self, ai_game):</span>
        <span class="ash">"""Initialize statistics."""</span>
        <span class="ash">self.settings = ai_game.settings</span>
        <span class="ash">self.reset_stats()</span>
        # Start game in an inactive state.
        self.game_active = False</pre></div><p>حالا بازی در حالت غیرفعال شروع می‌شود، ولی چون هنوز دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> را نساخته‌ایم، بازیکن به هیچ طریقی نمی‌تواند بازی را شروع کند.</p><div class="sect" id="ch14lev2sec1"><a class="bkmk" name="ch14lev2sec1"></a><h4>ایجاد کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Button</span><span class="rlm">‏</span></h4>
<p class="noindent">از آنجا که پای‌گیم متد آماده‌ای برای ساختن دکمه ندارد، یک کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Button</span><span class="rlm">‏</span> ایجاد می‌کنیم که یک مستطیل ایجاد می‌کند که داخل آن یک برچسب قرار می‌گیرد. می‌توانید از این کد برای ساختن هر کدام از دکمه‌های بازی استفاده کنید. بخش اول کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Button</span><span class="rlm">‏</span> به‌صورت زیر است؛ آن را در فایلی به نام <span class="rlm">‏</span><span class="ident" dir="ltr">button.py</span><span class="rlm">‏</span> ذخیره کنید:</p><div class="snippet"><div class="snippet-title" dir="ltr">button.py</div><pre class="snippet" dir="ltr">import pygame.font
class Button:
<span class="n" dir="ltr">1</span>    def __init__(self, ai_game, msg):
        """Initialize button attributes."""
        self.screen = ai_game.screen
        self.screen_rect = self.screen.get_rect()
        # Set the dimensions and properties of the button.
<span class="n" dir="ltr">2</span>        self.width, self.height = 200, 50
        self.button_color = (0, 255, 0)
        self.text_color = (255, 255, 255)
<span class="n" dir="ltr">3</span>        self.font = pygame.font.SysFont(None, 48)
        # Build the button's rect object and center it.
<span class="n" dir="ltr">4</span>        self.rect = pygame.Rect(0, 0, self.width, self.height)
        self.rect.center = self.screen_rect.center
        # The button message needs to be prepped only once.
<span class="n" dir="ltr">5</span>        self._prep_msg(msg)</pre></div><p>ابتدا، مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame.font</span><span class="rlm">‏</span> را ایمپورت می‌کنیم، که پای‌گیم برای ترسیم متن روی صفحه به آن نیاز دارد. متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> سه پارامتر می‌گیرد: <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self</span><span class="rlm">‏</span>، <a id="p281"></a>شیء <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">ai_game</span><span class="rlm">‏</span>، و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">msg</span><span class="rlm">‏</span>، که حاوی متن دکمه است <span class="n" dir="ltr">1</span>. ابعاد دکمه را در <span class="n" dir="ltr">2</span> تعیین می‌کنیم، و سپس به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">button_color</span><span class="rlm">‏</span> مقدار می‌دهیم که شیء <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> دکمه را به رنگ سبز روشن درمی‌آورد، و مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">text_color</span><span class="rlm">‏</span> را تعیین می‌کنیم تا متن به رنگ سفید نوشته شود.</p><p>در <span class="n" dir="ltr">3</span>، یک صفت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">font</span><span class="rlm">‏</span> برای ترسیم متن ایجاد می‌کنیم. آرگومان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">None</span><span class="rlm">‏</span> به پای‌گیم می‌گوید که از فونت پیش‌فرض استفاده کند، و عدد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">48</span><span class="rlm">‏</span> اندازه‌ی متن را مشخص می‌کند. برای الینک دکمه در وسط صفحه قرار گیرد، یک <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> برای دکمه ایجاد می‌کنیم <span class="n" dir="ltr">4</span> و مقدار صفت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">center</span><span class="rlm">‏</span> آن را معادل همین صفت از صفحه قرار می‌دهیم.</p><p>روش کار پای‌گیم به این صورت است که رشته‌ای را که می‌خواهید نمایش دهید، به‌عنوان یک تصویر ترسیم می‌کند. در <span class="n" dir="ltr">5</span>، متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_prep_msg()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم تا این ترسیم را انجام دهد.</p><p>کد مربوط به متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_prep_msg()</span><span class="rlm">‏</span> به‌صورت زیر است:</p><div class="snippet"><div class="snippet-title" dir="ltr">button.py</div><pre class="snippet" dir="ltr">    def _prep_msg(self, msg):
        """Turn msg into a rendered image and center text on the button."""
<span class="n" dir="ltr">1</span>        self.msg_image = self.font.render(msg, True, self.text_color,
                self.button_color)
<span class="n" dir="ltr">2</span>        self.msg_image_rect = self.msg_image.get_rect()
        self.msg_image_rect.center = self.rect.center</pre></div><p>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_prep_msg()</span><span class="rlm">‏</span> نیاز به دو پارامتر دارد: یکی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self</span><span class="rlm">‏</span>، و دیگری متنی که باید به‌صورت تصویر تسیم شود (<span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">msg</span><span class="rlm">‏</span>). فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">font.render()</span><span class="rlm">‏</span> سبب می‌شود که متن ذخیره‌شده در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">msg</span><span class="rlm">‏</span> به‌صورت یک تصویر ترسیم شود، که آن را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.msg_image</span><span class="rlm">‏</span> ذخیره می‌کنیم <span class="n" dir="ltr">1</span>. متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">font.render()</span><span class="rlm">‏</span> نیز یک مقدار بولی می‌گیرد که قابلیت ضدپلگی (<span class="rlm">‏</span><span class="lr" dir="ltr">antialiasing</span><span class="rlm">‏</span>) را روشن یا خاموش می‌کند (ضدپلگی سبب می‌شود که لبه‌های متن صاف‌تر شود). آرگومان‌های دیگر، رنگ مشخص شده برای فونت و رنگ پس‌زمینه هستند. ما برای ضدپلگی مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">True</span><span class="rlm">‏</span> تعیین می‌کنیم و رنگ پس‌زمینه را همان رنگ دکمه قرار می‌دهیم. (اگر رنگ پس‌زمینه تعیین نکنید، پای‌گیم تلاش خواهد کرد که متن را با پس‌زمینه‌ی شفاف ترسیم کند.)</p><p>در <span class="n" dir="ltr">2</span>، تصویر متن را در مرکز دکمه قرار می‌دهیم، به این صورت که یک <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> ایجاد می‌کنیم و مقدار صفت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">center</span><span class="rlm">‏</span> آن را مطابق با مرکز دکمه تعیین می‌کنیم.</p><p>سرانجام، یک متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">draw_button()</span><span class="rlm">‏</span> ایجاد می‌کنیم تا برای نمایش دادن دکمه روی صفحه، آن را فراخوانی کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">button.py</div><pre class="snippet" dir="ltr">    def draw_button(self):
        # Draw blank button and then draw message.
        self.screen.fill(self.button_color, self.rect)
        self.screen.blit(self.msg_image, self.msg_image_rect)</pre></div><p>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">screen.fill()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم تا بخش مستطیلی دکمه را ترسیم کنیم. سپس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">screen.blit()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم تا تصویر متن را روی صفقحه ترسیم کنیم، و برای این کار، تصویر و شیء <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> مربوط به تصویر را به‌عنوان آرگومان به آن می‌دهیم. به این ترتیب، کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Button</span><span class="rlm">‏</span> کامل می‌شود.</p></div><div class="sect" id="ch14lev2sec2"><a class="bkmk" name="ch14lev2sec2"></a><h4>ترسیم دکمه روی صفحه</h4>
<p class="noindent">با استفاده از کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Button</span><span class="rlm">‏</span>، یک دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> به کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AlienInvasion</span><span class="rlm">‏</span> اضافه می‌کنیم. ابتدا دستورالعمل <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">import</span><span class="rlm">‏</span> را اضافه می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr"><span class="ash">--<span class="it">snip</span>--</span>
<span class="ash">from game_stats import GameStats</span>
from button import Button</pre></div><a id="p282"></a><p>از آنجا که فقط به یک دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> نیاز داریم، لذا دکمه را در متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> از کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AlienInvasion</span><span class="rlm">‏</span> ایجاد می‌کنیم. می‌توانیم این کد را در انتهای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> قرار دهیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def __init__(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash">self._create_fleet()</span>
        # Make the Play button.
        self.play_button = Button(self, "Play")</pre></div><p>این کد نمونه‌ای از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Button</span><span class="rlm">‏</span> با برچسب <span class="emphasis"><span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span></span> ایجاد می‌کند، ولی دکمه را روی صفحه ترسیم نمی‌کند. متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">draw_button()</span><span class="rlm">‏</span> را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_update_screen()</span><span class="rlm">‏</span> فراخوانی می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _update_screen(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash">self.aliens.draw(self.screen)</span>
        # Draw the play button if the game is inactive.
        if not self.stats.game_active:
            self.play_button.draw_button()
        <span class="ash">pygame.display.flip()</span></pre></div><p>برای اینکه دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> روی همه‌ی عناصر دیگر صفحه قابل مشاهده باشد، آن را بعد از ترسیم سایر عناصر، ولی قبل از فلیپ کردن روی صفحه، ترسیم می‌کنیم. یک بلوک <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">if</span><span class="rlm">‏</span> نیز قرار می‌دهیم، تا دکمه فقط زمانی که بازی غیرفعال است، ظاهر شود.</p><p>حالا وقتی که برنامه را اجرا می‌کنید، دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> را در وسط صفحه خواهید دید، مانند آنچه در <refFig xmlns="urn:dox:pycc">۱۴-۱</refFig> می‌بینید.</p><figure class="fig" id="ch14_fig01"><img class="fig" src="images/ch14_fig01.jpg"/><figcaption class="fig">شکل ۱۴-۱: زمانی که بازی غیرفعال است، دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> نمایش داده می‌شود.</figcaption></figure></div><div class="sect" id="ch14lev2sec3"><a class="bkmk" name="ch14lev2sec3"></a><h4>شروع کردن بازی</h4>
<a id="p283"></a><p class="noindent">برای اینکه وقتی بازیکن دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> را می‌زند، بازی شروع شود، بلوک <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">elif</span><span class="rlm">‏</span> زیر را به پایان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_events()</span><span class="rlm">‏</span> اضافه کنید، تا رویدادهای ماوس بر روی دکمه را پایش کنید:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _check_events(self):</span>
        <span class="ash">"""Respond to keypresses and mouse events."""</span>
        <span class="ash">for event in pygame.event.get():</span>
            <span class="ash">if event.type == pygame.QUIT:</span>
                <span class="ash">--<span class="it">snip</span>--</span>
<span class="n" dir="ltr">1</span>            elif event.type == pygame.MOUSEBUTTONDOWN:
<span class="n" dir="ltr">2</span>                mouse_pos = pygame.mouse.get_pos()
<span class="n" dir="ltr">3</span>                self._check_play_button(mouse_pos)</pre></div><p>هر گاه بازیکن در هر جایی از صفحه (<span class="rlm">‏</span><span class="lr" dir="ltr">screen</span><span class="rlm">‏</span>) کلیک کند، پای‌گیم یک رویداد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">MOUSEBUTTONDOWN</span><span class="rlm">‏</span> را شناسایی می‌کند <span class="n" dir="ltr">1</span>، ولی ما می‌خواهیم که فقط وقتی ماوس روی دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> کلیک می‌کند، بازی را شروع کنیم. برای این منظور، از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame.mouse.get_pos()</span><span class="rlm">‏</span> استفاده می‌کنیم که وقتی دکمه‌ی ماوس کلیک می‌کند، یک توپل برمی‌گرداند که حاوی مختصات <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> نشانگر ماوس است <span class="n" dir="ltr">2</span>. این مقادیر را به متد جدید <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_play_button()</span><span class="rlm">‏</span> می‌دهیم <span class="n" dir="ltr">3</span>.</p><p>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_play_button()</span><span class="rlm">‏</span> را بعد از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_events()</span><span class="rlm">‏</span> قرار داده‌ام. کد آن به‌صورت زیر است:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    def _check_play_button(self, mouse_pos):
        """Start a new game when the player clicks Play."""
<span class="n" dir="ltr">1</span>        if self.play_button.rect.collidepoint(mouse_pos):
            self.stats.game_active = True</pre></div><p>از متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">collidepoint()</span><span class="rlm">‏</span> در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> استفاده می‌کنیم تا ببینیم که نشانگر ماوس در منطقه‌ی مربوط به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> قرار گرفته است یا نه <span class="n" dir="ltr">1</span>. اگر چنین باشد، مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">game_active</span><span class="rlm">‏</span> را برابر با <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">True</span><span class="rlm">‏</span> تعیین می‌کنیم، و بازی شروع می‌شود!</p><p>اکنون می‌توانید بازی را آغاز کنید و تا آخر بازی کنید. وقتی که بازی تمام می‌شود، به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">game_active</span><span class="rlm">‏</span> مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">False</span><span class="rlm">‏</span> داده می‌شود، و دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> دوباره ظاهر می‌شود.</p></div><div class="sect" id="ch14lev2sec4"><a class="bkmk" name="ch14lev2sec4"></a><h4>از سر گرفتن بازی</h4>
<p class="noindent">کدی که برای دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> نوشتیم، در اولین دفعه‌ای که بازیکن روی این دکمه کلیک می‌کند، درست کار می‌کند. ولی پس از پایان یافتن دور اول بازی دیگر کار نمی‌کند، چرا که شرایطی که موجب خاتمه یافتن بازی شده است، به حالت بازگردانده نشده است.</p><p>برای بازگردانیِ بازی در زمانی که بازیکن روی دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> کلیک می‌کند، باید آمار بازی را بازگردان کنیم، بیگانه‌ها و گلوله‌های قدیمی را دور بریزیم، ناوگان جدیدی ئچکیم، و سفینه را در مرکز قرار دهیم، که این کارها در اینجا نشان داده شده است:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _check_play_button(self, mouse_pos):</span>
        <span class="ash">"""Start a new game when the player clicks Play."""</span>
        <span class="ash">if self.play_button.rect.collidepoint(mouse_pos):</span>
            # Reset the game statistics.
<span class="n" dir="ltr">1</span>            self.stats.reset_stats()
            <span class="ash">self.stats.game_active = True</span>
            # Get rid of any remaining aliens and bullets.
<span class="n" dir="ltr">2</span>            self.aliens.empty()
<a id="p284"></a>            self.bullets.empty()
            # Create a new fleet and center the ship.
<span class="n" dir="ltr">3</span>            self._create_fleet()
            self.ship.center_ship()</pre></div><p>در <span class="n" dir="ltr">1</span>، آمار بازی را به حالت اول برمی‌گردانیم، که سبب می‌شود که بازیکن سه سفینه‌ی جدید داشته باشد. سپس به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">game_active</span><span class="rlm">‏</span>، مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">True</span><span class="rlm">‏</span> می‌دهیم، که سبب می‌شود که بازی به محض تمام شدن اجرای این تابع، شروع شود. گروه‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">aliens</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">bullets</span><span class="rlm">‏</span> را خالی می‌کنیم <span class="n" dir="ltr">2</span>، و سپس ناوگان جدیدی ایجاد می‌کنیم و سفینه را در مرکز قرار می‌دهیم <span class="n" dir="ltr">3</span>.</p><p>حالا هر زمان که دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> را بزنید، بازی به درستی شروع خواهد شد، طوری که خواهید توانست هر چند بار که خواستید، بازی کنید!</p></div><div class="sect" id="ch14lev2sec5"><a class="bkmk" name="ch14lev2sec5"></a><h4>غیرفعال کردن دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span></h4>
<p class="noindent">یکی از مشکلات دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> آن است که ناحیه‌ی مربوط به این دکمه، حتی در زمانی که خود دکمه روی صفحه مشاهده نمی‌شود، همچنان به رویدادهای کلیک پاسخ می‌دهد. اگر پس از شروع بازی به‌طور اتفاقی در ناحیه‌ی دکمه کلیک کنید، بازی از نو شروع خواهد شد!</p><p>برای اصلالح این مشکل، کاری می‌کنیم که بازی فقط وقتی که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">game_active</span><span class="rlm">‏</span> مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">False</span><span class="rlm">‏</span> دارد، شروع شود:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _check_play_button(self, mouse_pos):</span>
        <span class="ash">"""Start a new game when the player clicks Play."""</span>
<span class="n" dir="ltr">1</span>        button_clicked = self.play_button.rect.collidepoint(mouse_pos)
<span class="n" dir="ltr">2</span>        if button_clicked and not self.stats.game_active:
            <span class="ash"># Reset the game statistics.</span>
            <span class="ash">self.stats.reset_stats()</span>
            <span class="ash">--<span class="it">snip</span>--</span></pre></div><p>فلگ <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">button_clicked</span><span class="rlm">‏</span> مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">True</span><span class="rlm">‏</span> یا <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">False</span><span class="rlm">‏</span> را در خود ذخیره می‌کند <span class="n" dir="ltr">1</span>، و بازی فقط در صورتی که از نو شروع خواهد شد که روی دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> کلیک شود، <span class="emphasis">ضمن اینکه</span> بازی در حال حاضر فعال نباشد <span class="n" dir="ltr">2</span>. برای امتحان کردن این رفتار، بازی جدیدی را شروع کنید و مکرراً در جایی که دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> باید باشد، کلیک کنید. اگر همه چیز مطابق انتظار کار کند، نشان می‌دهد که کلیک کردن در ناحیه‌ی دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> تأثیر نامطلوبی بر انجام بازی ندارد.</p></div><div class="sect" id="ch14lev2sec6"><a class="bkmk" name="ch14lev2sec6"></a><h4>پنهان کردن نشانگر ماوس</h4>
<p class="noindent">ما می‌خواهیم که در آغاز نشانگر ماوس قابل مشاهده باشد تا بتوانیم بازی را شروع کنیم، ولی وقتی که بازی شروع شد، دیگر نشانگر ماوس مزاحم کار ما است. برای اصلاح این موضوع، وقتی که بازی فعال شد، آن را نامرئی می‌کنیم. این کار را می‌توانیم در پایان بلوک <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">if</span><span class="rlm">‏</span> در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_play_button()</span><span class="rlm">‏</span> انجام دهیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _check_play_button(self, mouse_pos):</span>
        <span class="ash">"""Start a new game when the player clicks Play."""</span>
        <span class="ash">button_clicked = self.play_button.rect.collidepoint(mouse_pos)</span>
        <span class="ash">if button_clicked and not self.stats.game_active:</span>
            <span class="ash">--<span class="it">snip</span>--</span>
            # Hide the mouse cursor.
            pygame.mouse.set_visible(False)</pre></div><a id="p285"></a><p>با دادن مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">False</span><span class="rlm">‏</span> به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">set_visible()</span><span class="rlm">‏</span>، نشانگر ماوس روی پنجره‌ی بازی پنهان می‌شود.</p><p>زمانی که بازی پایان یافت، دوباره نشانگر را ظاهر می‌کنیم تا بازیکن بتواند روی دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> کلیک کند و دور جدید بازی را شروع کند. کد لازم برای انجام این کار به‌صورت زیر است:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _ship_hit(self):</span>
        <span class="ash">"""Respond to ship being hit by alien."""</span>
        <span class="ash">if self.stats.ships_left &gt; 0:</span>
            <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash">else:</span>
            <span class="ash">self.stats.game_active = False</span>
            pygame.mouse.set_visible(True)</pre></div><p>همین که بازی غیرفعال شد، نشانگر را دوباره ظاهخر می‌کنیم، که این امر در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_ship_hit()</span><span class="rlm">‏</span> اتفاق می‌افتد. توجه به این قبیل جزئیات سبب می‌شود که بازی شما منظره‌ی حرفه‌ای‌تری داشته باشد، و به بازیکن امکان می‌دهد که روی بازی کردن تمرکز کند نه اینکه در فکر سر درآوردن از واسط کاربری باشد.</p><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<p class="tiy1"><span class="tiy" id="ch14_tiy01"><span class="tiy-num">۱۴-۱</span>. <span class="tiy-title">شروع کردن بازی با فشار دادن کلید <span class="rlm">‏</span><span class="key" dir="ltr">p</span><span class="rlm">‏</span></span>: </span> از آنجا که بازی <span class="emphasis">تهاجم بیگانگان</span> برای کنترل سفینه از ورودی صفحه‌کلید استفاده می‌کند، بد نیست که بتوانیم با فشار دادن یک کلید بازی را شروع کنیم. کدی بنویسید که بازیکن با فشار دادن کلید <span class="rlm">‏</span><span class="key" dir="ltr">p</span><span class="rlm">‏</span> بازی را شروع کند. بهتر است که مقداری از کد را از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_play_button()</span><span class="rlm">‏</span> به متدی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_start_game()</span><span class="rlm">‏</span> انتقال دهید، تا آن را هم از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_play_button()</span><span class="rlm">‏</span> و هم از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_keydown_events()</span><span class="rlm">‏</span> فراخوانی کنید.</p><p class="tiy1"><span class="tiy" id="ch14_tiy02"><span class="tiy-num">۱۴-۲</span>. <span class="tiy-title">تمرین هدف‌گیری</span>: </span> مستطیلی در کنار راست صفحه ایجاد کنید که با سرعت ثابتی بالا و پایین می‌رود. سپس سفینه‌ای را در سمت چپ صفحه قرار دهید که بازیکن می‌تواند آن را بالا و پایین ببرد و گلوله‌هایی را به طرف مستطیل متحرک طرف راست شلیک کند. یک دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> اضافه کنید که بازی را شروع می‌کند، و وقتی که تیر بازیکن سه بار به خطا رفت و به هدف اصابت نکرد، بازی تمام می‌شود و دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> دوباره ظاهر می‌شود. سپس بازیکن با کلیک کردن دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> می‌تواند بازی را دوباره شروع کند.</p></div></div></div><div class="sect" id="ch14lev1sec2"><a class="bkmk" name="ch14lev1sec2"></a><h3>رفتن به سطح بالاتر بازی</h3>
<p class="noindent">در بازی کنونی ما، وقتی که بازیکن تمام ناوگان بیگانه‌ها را ساقط کرد، به سطح جدیدی می‌رسد، ولی دشواری بازی تغییری نمی‌کند. برای اینکه هیجان بازی را بیشتر کنیم، هر بار که بازیکن تمام بیگانه‌ها را نابود کرد، دشواری بازی را بالاتر می‌بریم.</p><div class="sect" id="ch14lev2sec7"><a class="bkmk" name="ch14lev2sec7"></a><h4>تغییر دادن تنظیمات سرعت</h4>
<p class="noindent">ابتدا تغییراتی در کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Settings</span><span class="rlm">‏</span> ایجاد می‌کنیم تا تنظیمات بازی در دو گروه ایستا و پویا قرار گیرند. به این نکته هم توجه می‌کنیم که تنظیماتی که <a id="p286"></a>در حین بازی تغییر می‌کنند، هنگام دشروع کردن یک بازی جدید به حالت اول برگردانده شوند. متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> در فایل <span class="rlm">‏</span><span class="ident" dir="ltr">settings.py</span><span class="rlm">‏</span> به‌صورت زیر تغییر می‌کند:</p><div class="snippet"><div class="snippet-title" dir="ltr">settings.py</div><pre class="snippet" dir="ltr">    <span class="ash">def __init__(self):</span>
        """Initialize the game's static settings."""
        <span class="ash"># Screen settings</span>
        <span class="ash">self.screen_width = 1200</span>
        <span class="ash">self.screen_height = 800</span>
        <span class="ash">self.bg_color = (230, 230, 230)</span>
        <span class="ash"># Ship settings</span>
        <span class="ash">self.ship_limit = 3</span>
        <span class="ash"># Bullet settings</span>
        <span class="ash">self.bullet_width = 3</span>
        <span class="ash">self.bullet_height = 15</span>
        <span class="ash">self.bullet_color = 60, 60, 60</span>
        <span class="ash">self.bullets_allowed = 3</span>
        <span class="ash"># Alien settings</span>
        <span class="ash">self.fleet_drop_speed = 10</span>
        # How quickly the game speeds up
<span class="n" dir="ltr">1</span>        self.speedup_scale = 1.1
<span class="n" dir="ltr">2</span>        self.initialize_dynamic_settings()</pre></div><p>تنظیماتی را که ثابت می‌مانند باز هم در متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> مقداردهی اولیه می‌کنیم. در <span class="n" dir="ltr">1</span>، یک مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">speedup_scale</span><span class="rlm">‏</span> اضافه می‌کنیم که میزان افزایش سرعت بازی را کنترل می‌کند: مثلاً اگر مقدار آن ۲ باشد، به معنای این است که هر بار که بازیکن به سطح بالاتری می‌رسد، سرعت بازی دو برابر می‌شود؛ مقدار ۱ نشان‌دهنده‌ی آن است که سرعت بازی ثابت خواهد بود. به نظر من، مقدار ۱٫۱ مناسب است، به‌طوری که در هر سطح بازی مشکل‌تر می‌شود، ولی نه به اندازه‌ای که غیرممکن باشد. و سرانجام، متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">initialize_dynamic_settings()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم تا صفاتی را که در طول آبزی تغییر می‌کنند، مقداردهی کنیم <span class="n" dir="ltr">2</span>.</p><p>کد مربوط به مد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">initialize_dynamic_settings()</span><span class="rlm">‏</span> به‌صورت زیر است:</p><div class="snippet"><div class="snippet-title" dir="ltr">settings.py</div><pre class="snippet" dir="ltr">    def initialize_dynamic_settings(self):
        """Initialize settings that change throughout the game."""
        self.ship_speed = 1.5
        self.bullet_speed = 3.0
        self.alien_speed = 1.0
        # fleet_direction of 1 represents right; -1 represents left.
        self.fleet_direction = 1</pre></div><p>این متد مقادیر ابتدایی مربوط به سرعت سفینه، گلوله، و بیگانه‌ها را تعیین می‌کند. این سرعت‌ها را هر گاه بازیکن در بازی پیشرفت می‌کند، افزایش خواهیم داد، و هر گاه بازی جدیدی شروع می‌کند، به مقدار اولیه باز خواهیم گرداند. مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">fleet_direction</span><span class="rlm">‏</span> نیز در این متد تعیین می‌شود، چرا که می‌خواهیم که بیگانه‌ها در ابتدای بازی همیشه به طرف راست حرکت کنند. نیازی نیست که مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">fleet_drop_speed</span><span class="rlm">‏</span> را افزایش دهیم، زیرا وقتی که بیگانه‌ها در عرص صفحه سریع‌تر حرکت می‌کنند، سرعت پایین آمدن آن‌ها نیز بیشتر خواهد بود.</p><a id="p287"></a><p>برای اینکه هر بار که بازیکن به سطح جدیدی از بازی می‌رسد، سرعت سفینه، گلوله‌ها، و بیگانه‌ها را افزایش دهیم، متد جدیدی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">increase_speed()</span><span class="rlm">‏</span> می‌نویسیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">settings.py</div><pre class="snippet" dir="ltr">    def increase_speed(self):
        """Increase speed settings."""
        self.ship_speed *= self.speedup_scale
        self.bullet_speed *= self.speedup_scale
        self.alien_speed *= self.speedup_scale</pre></div><p>برای افزایش سرعت این عناصر بازی، پارامتر سرعت هر کدام از آن‌ها را در مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">speedup_scale</span><span class="rlm">‏</span> ضرب می‌کنیم.</p><p>وقتی که آخرین بیگانه با شلیک گلوله نابود شد، با فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">increase_speed()</span><span class="rlm">‏</span> در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_bullet_alien_collisions()</span><span class="rlm">‏</span>، سرعت بازی را افزایش می‌دهیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _check_bullet_alien_collisions(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash">if not self.aliens:</span>
            <span class="ash"># Destroy existing bullets and create new fleet.</span>
            <span class="ash">self.bullets.empty()</span>
            <span class="ash">self._create_fleet()</span>
            self.settings.increase_speed()</pre></div><p>با تغییر مقادیر تنظیمات سرعتی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">ship_speed</span><span class="rlm">‏</span>، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">alien_speed</span><span class="rlm">‏</span>، و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">bullet_speed</span><span class="rlm">‏</span>، سرعت تمام بازی افزایش می‌یابد!</p></div><div class="sect" id="ch14lev2sec8"><a class="bkmk" name="ch14lev2sec8"></a><h4>بازگرداندن سرعت به حالت اول</h4>
<p class="noindent">زمانی که بازیکن دور جدیدی از بازی را شروع می‌کند، لازم است که هرگونه تنظیمات تغییر یافته را به مقادیر اولیه بازگردانیم؛در غیر این صورت، دور جدید بازی با سرعت افزایش یافته‌ی دور قبلی شروع خواهد شد:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _check_play_button(self, mouse_pos):</span>
        <span class="ash">"""Start a new game when the player clicks Play."""</span>
        <span class="ash">button_clicked = self.play_button.rect.collidepoint(mouse_pos)</span>
        <span class="ash">if button_clicked and not self.stats.game_active:</span>
            # Reset the game settings.
            self.settings.initialize_dynamic_settings()
            <span class="ash">--<span class="it">snip</span>--</span></pre></div><p>حالا دیگر بازی <span class="emphasis">تهاجم بیگانگان</span> جالب‌تر شده است. هر بار که تمام بیگانه‌ها را نابود کردید، بازی سرعت می‌گیرد و کمی دشوارتر می‌شود. اگر بازی خیلی زود زیادی دشوار شد، بهتر است مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">settings.speedup_scale</span><span class="rlm">‏</span> را کاهش دهید. یا اینکه اگر بازی به‌قدر کافی چالشی نیست، این مقدار را کمی افزایش دهید. با افزایش دادن دشوار در مدت زمانی معقول، مقدار مناسب را پیدا کنید. یکی دو دور اول بازی باید راحت باشد، چند دور بعدی دشوار ولی شدنی باشد، و دورهای بعد از آن تقریباً در حد غیرممکنی دشوار باشد.</p><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<a id="p288"></a><p class="tiy1"><span class="tiy" id="ch14_tiy03"><span class="tiy-num">۱۴-۳</span>. <span class="tiy-title">تمرین هدف‌گیری چالشی</span>: </span> با برنامه‌ی مربوط به <span class="ref"><a href="c27-ch14.xhtml#ch14_tiy02">تمرین <span dir="ltr">۱۴-۲</span></a></span> (<span class="ref"><a href="c27-ch14.xhtml#p285">صفحه‌ی <span>۲۸۵</span></a></span>) شروع کنید. برنامه را به‌گونه‌ای تغییر دهید که با پیشرفت بازی، هدف سریع‌تر حرکت کند، و زمانی که بازیکن روی دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> کلیک می‌کند، هدف با سرعت اولیه شروع به حرکت کند.</p><p class="tiy1"><span class="tiy" id="ch14_tiy04"><span class="tiy-num">۱۴-۴</span>. <span class="tiy-title">سطوح دشواری</span>: </span> یک سری دکمه برای بازی <span class="emphasis">تهاجم بیگانگان</span> ایجاد کنید تا بازیکن بتواند سطح دشواری مناسب را برای بازی انتخاب کند. هر دکمه باید مقادیر مناسبی را به صفت‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Settings</span><span class="rlm">‏</span> اختصاص دهد تا سطح دشواری مورد نظر ایجاد شود.</p></div></div></div><div class="sect" id="ch14lev1sec3"><a class="bkmk" name="ch14lev1sec3"></a><h3>امتیازدهی</h3>
<p class="noindent">در اینجا یک سیستم امتیازدهی را پیاده‌سازی می‌کنیم تا امتیاز بازی را به‌صورت زنده پیگیری کنیم، و بالاترین نمره، سطح بازی، و تعداد سفینه‌های باقی‌مانده را نمایش دهیم.</p><p>امتیاز یکی از آمارهای بازی است، بنابراین، یک صفت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">score</span><span class="rlm">‏</span> را به کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">GameStats</span><span class="rlm">‏</span> اضافه می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">game_stats.py</div><pre class="snippet" dir="ltr"><span class="ash">class GameStats:</span>
    <span class="ash">--<span class="it">snip</span>--</span>
    <span class="ash">def reset_stats(self):</span>
        <span class="ash">"""Initialize statistics that can change during the game."""</span>
        <span class="ash">self.ships_left = self.ai_settings.ship_limit</span>
        self.score = 0</pre></div><p>برای اینکه هر بار که بازی از نو شروع می‌شود، امتیاز بازی را به حالت اول برگردانیم، مقداردهی اولیه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">score</span><span class="rlm">‏</span> را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">reset_stats()</span><span class="rlm">‏</span> انجام می‌دهیم، نه در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span>.</p><div class="sect" id="ch14lev2sec9"><a class="bkmk" name="ch14lev2sec9"></a><h4>نمایش دادن امتیاز</h4>
<p class="noindent">برای نمایش دادن امتیاز روی صفحه، ابتدا کلاس جدیدی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Scoreboard</span><span class="rlm">‏</span> ایجاد می‌کنیم. این کلاس فعلاً فقط امتیاز کنونی را نمایش خواهد داد، ولی نهایتاً از آن برای نمایش دادن بالاترین امتیاز، سطح بازی، و تعداد سفینه‌های باقی‌مانده نیز استفاده خواهیم کرد. بخش اول این کلاس به‌صورت زیر است؛ آن را در فایلی به نام <span class="rlm">‏</span><span class="ident" dir="ltr">scoreboard.py</span><span class="rlm">‏</span> ذخیره کنید:</p><div class="snippet"><div class="snippet-title" dir="ltr">scoreboard.py</div><pre class="snippet" dir="ltr">import pygame.font
class Scoreboard:
    """A class to report scoring information."""
<span class="n" dir="ltr">1</span>    def __init__(self, ai_game):
        """Initialize scorekeeping attributes."""
        self.screen = ai_game.screen
        self.screen_rect = self.screen.get_rect()
        self.settings = ai_game.settings
        self.stats = ai_game.stats
        # Font settings for scoring information.
<span class="n" dir="ltr">2</span>        self.text_color = (30, 30, 30)
<span class="n" dir="ltr">3</span>        self.font = pygame.font.SysFont(None, 48)
<a id="p289"></a>        # Prepare the initial score image.
<span class="n" dir="ltr">4</span>        self.prep_score()</pre></div><p>از آنجا که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Scoreboard</span><span class="rlm">‏</span> امتیاز را روی صفحه می‌نویسد، لذا ابتدا <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame.font</span><span class="rlm">‏</span> را ایمپورت می‌کنیم. سپس پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">ai_game</span><span class="rlm">‏</span> را به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> می‌دهیم، تا به اشیای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">settings</span><span class="rlm">‏</span>، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">screen</span><span class="rlm">‏</span>، و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">stats</span><span class="rlm">‏</span> دسترسی داشته باشد، چرا که برای گزارش‌دهی مقادیری که می‌خواهیم رهگیری کنیم، به آن‌ها نیاز دارد <span class="n" dir="ltr">1</span>. سپس رنگ متن را تعیین می‌کنیم <span class="n" dir="ltr">2</span>، و یک شیء فونت را نمونه‌سازی می‌کنیم <span class="n" dir="ltr">3</span>.</p><p>برای تبدیل متن مورد نظر به تصویر، متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_score()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم <span class="n" dir="ltr">4</span>، که تعریف آن به‌صورت زیر است:</p><div class="snippet"><div class="snippet-title" dir="ltr">scoreboard.py</div><pre class="snippet" dir="ltr">    def prep_score(self):
        """Turn the score into a rendered image."""
<span class="n" dir="ltr">1</span>        score_str = str(self.stats.score)
<span class="n" dir="ltr">2</span>        self.score_image = self.font.render(score_str, True,
                self.text_color, self.settings.bg_color)
        # Display the score at the top right of the screen.
<span class="n" dir="ltr">3</span>        self.score_rect = self.score_image.get_rect()
<span class="n" dir="ltr">4</span>        self.score_rect.right = self.screen_rect.right - 20
<span class="n" dir="ltr">5</span>        self.score_rect.top = 20</pre></div><p>در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_score()</span><span class="rlm">‏</span>، مقدار عددی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">stats.score</span><span class="rlm">‏</span> را به یک رشته تبدیل می‌کنیم <span class="n" dir="ltr">1</span>، و سپس این رشته را به متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">render()</span><span class="rlm">‏</span> می‌دهیم، که تصویر را ایجاد می‌کند <span class="n" dir="ltr">2</span>. برای اینکه امتیاز را به‌طور واضح روی صفحه نمایش دهیم، رنگ پس‌زمینه‌ی صفحه و رنگ متن را به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">render()</span><span class="rlm">‏</span> می‌دهیم.</p><p>محل نمایش امتیاز را در گوشیهی بالای راست صفحه قرار می‌دهیم، به‌طوری که هرچه امتیاز بالاتر برود و عرض اعداد بیشتر شود، این قسمت به طرف چپ گسترش می‌یابد. برای اینکه امتیاز همیشه با طرف راست صفحه هم‌ردیف باشد، یک <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">score_rect</span><span class="rlm">‏</span> ایجاد می‌کنیم <span class="n" dir="ltr">3</span>، و لبه‌ی راست آن را به فاصله‌ی ۲۰ پیکسل از ضلع راست صفحه قرار می‌دهیم <span class="n" dir="ltr">4</span>. سپس ضلع بالا را به فاصله‌ی ۲۰ پیکسل از بالای صفحه قرار می‌دهیم <span class="n" dir="ltr">5</span>.</p><p>سپس یک متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">show_score()</span><span class="rlm">‏</span> برای نمایش تصویر امتیاز ایجاد می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">scoreboard.py</div><pre class="snippet" dir="ltr">    def show_score(self):
        """Draw score to the screen."""
        self.screen.blit(self.score_image, self.score_rect)</pre></div><p>این متد تصویر امتیاز را روی صفحه در محلی که با <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">score_rect</span><span class="rlm">‏</span> مشخص شده است، ترسیم می‌کند.</p></div><div class="sect" id="ch14lev2sec10"><a class="bkmk" name="ch14lev2sec10"></a><h4>ساختن تابلوی امتیازات</h4>
<p class="noindent">برای نمایش امتیاز، یک نمونه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Scoreboard</span><span class="rlm">‏</span> در کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AlienInvasion</span><span class="rlm">‏</span> ایجاد می‌کنیم. ابتدا دستورالعمل‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">import</span><span class="rlm">‏</span> را کامل می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr"><span class="ash">--<span class="it">snip</span>--</span>
<span class="ash">from game_stats import GameStats</span>
from scoreboard import Scoreboard
<span class="ash">--<span class="it">snip</span>--</span></pre></div><a id="p290"></a><p>آنگاه یک نمونه از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Scoreboard</span><span class="rlm">‏</span> در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> ایجاد می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def __init__(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash">pygame.display.set_caption("Alien Invasion")</span>
        # Create an instance to store game statistics,
        #   and create a scoreboard.
        <span class="ash">self.stats = GameStats(self)</span>
        self.sb = Scoreboard(self)
        <span class="ash">--<span class="it">snip</span>--</span></pre></div><p>سپس تابلوی امتیازات را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_update_screen()</span><span class="rlm">‏</span> روی صفحه ترسیم می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _update_screen(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash">self.aliens.draw(self.screen)</span>
        # Draw the score information.
        self.sb.show_score()
        <span class="ash"># Draw the play button if the game is inactive.</span>
        <span class="ash">--<span class="it">snip</span>--</span></pre></div><p>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">show_score()</span><span class="rlm">‏</span> را درست قبل از ترسیم دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> فراخوانی می‌کنیم.</p><p>حالا وقتی که بازی را اجرا می‌کنید، باید در گوشه‌ی راست بالای صفحه یک عدد ۰ ظاهر شود. (فعلاً فقط می‌خواهیم مطمئن شویم که امتیاز در محل مناسب نشان داده می‌شود، تا بعد سیستم امتیازدهی را بیشتر توسعه دهیم.) <refFig xmlns="urn:dox:pycc">۱۴-۲</refFig> امتیاز را قبل از شروع بازی نشان می‌دهد.</p><figure class="fig" id="ch14_fig02"><img class="fig" src="images/ch14_fig02.jpg"/><figcaption class="fig">شکل ۱۴-۲: امتیاز در گوشه‌ی بالای راست صفحه نمایش داده می‌شود.</figcaption></figure><a id="p291"></a><p>حالا به هر بیگانه، مقدار امتیاز معینی اختصاص می‌دهیم.</p></div><div class="sect" id="ch14lev2sec11"><a class="bkmk" name="ch14lev2sec11"></a><h4>به‌روز کردن امتیاز با نابود شدن بیگانه‌ها</h4>
<p class="noindent">برای اینکه نمره‌ی امتیاز به‌طور زنده روی صفحه نمایش داده شود، مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">stats.score</span><span class="rlm">‏</span> را هرگاه یکی از بیگانه‌ها مورد اصابت قرار گرفت، روزآمد می‌کنیم و سپس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_score()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم تا تصویر امتیاز نیز روزآمد شود. ولی ابتدا باید مشخص کنیم که با ساقط شدن هر بیگانه، چه مقدار امتیاز به بازیکن تعلق می‌گیرد:</p><div class="snippet"><div class="snippet-title" dir="ltr">settings.py</div><pre class="snippet" dir="ltr">    <span class="ash">def initialize_dynamic_settings(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        # Scoring
        self.alien_points = 50</pre></div><p>به تدریج که بازی جلوتر می‌رود، مقدار امتیاز هر بیگانه را اضافه می‌کنیم. برای اینکه این مقدار امتیاز در شروع هر دور بازی به مقدار اولیه بازگردانده شود، مقداردهی آن را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">initialize_dynamic_settings()</span><span class="rlm">‏</span> انجام می‌دهیم.</p><p>هر گاه یک بیگانه نابود می‌شود، امتیاز را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_bullet_alien_collisions()</span><span class="rlm">‏</span> اضافه می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _check_bullet_alien_collisions(self):</span>
        <span class="ash">"""Respond to bullet-alien collisions."""</span>
        <span class="ash"># Remove any bullets and aliens that have collided.</span>
        <span class="ash">collisions = pygame.sprite.groupcollide(</span>
                <span class="ash">self.bullets, self.aliens, True, True)</span>
        if collisions:
            self.stats.score += self.settings.alien_points
            self.sb.prep_score()
        <span class="ash">--<span class="it">snip</span>--</span></pre></div><p>وقتی که گلوله به یک بیگانه اصابت می‌کند، پای‌گیم یک دیکشنری <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">collisions</span><span class="rlm">‏</span> برمی‌گرداند. اول وجود داشتن دیکشنری را وارسی می‌کنیم، و در صورتی که وجود داشته باشد، مقدار بیگانه را به امتیاز اضافه می‌کنیم. سپس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_score()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم تا تصویر جدیدی برای امتیاز روزآمد شده ایجاد کند.</p><p>حالا وقتی که بازی را اجرا می‌کنید، خواهید توانست امتیازات بیشتری جمع کنید!</p></div><div class="sect" id="ch14lev2sec12"><a class="bkmk" name="ch14lev2sec12"></a><h4>برگرداندن امتیاز به مقدار اولیه</h4>
<p class="noindent">در حال حاضر، ما فقط <span class="emphasis">بعد</span> از آنکه یک بیگانه مورد اصابت قرار گرفت، امتیاز جدید را آماده می‌کنیم، که البته در اکثر موارد مشکلی ایجاد نمی‌کند. ولی وقتی که دور جدید بازی شروع شود، همچنان امتیاز قدیمی را خواهیم دید، تا آنکه نخستین بیگانه در بازی جدید مورد اصابت قرار گیرد.</p><p>برای حل این مسئله، می‌توانیم هنگام شروع بازی جدید، امتیاز را برای نمایش آماده کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _check_play_button(self, mouse_pos):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash">if button_clicked and not self.stats.game_active:</span>
            <span class="ash">--<span class="it">snip</span>--</span>
            <span class="ash"># Reset the game statistics.</span>
            <span class="ash">self.stats.reset_stats()</span>
<a id="p292"></a>            <span class="ash">self.stats.game_active = True</span>
            self.sb.prep_score()
            <span class="ash">--<span class="it">snip</span>--</span></pre></div><p>هنگام شروع یک بازی جدید، پس از بازگرداندن آمار بازی به حالت اولیه، متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_score()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم. این کار، امتیاز ۰ را برای نمایش روی تابلوی امتیازات آماده می‌کند.</p></div><div class="sect" id="ch14lev2sec13"><a class="bkmk" name="ch14lev2sec13"></a><h4>امتیاز دادن به تمام شلیک‌های موفق</h4>
<p class="noindent">در کدی که تا اینجا نوشته‌ایم، ممکن است امتیاز مربوط به ساقط کردن برخی از بیگانه‌ها در نظر گرفته نشود. مثلاً اگر در یک دور حلقه دو گلوله به بیگانه‌ها اصابت کند یا اگر گلوله‌ی بسیار پهنی داشته باشیم که به چند بیگانه اصابت کند، بازیکن فقط امتیاز مربوط به یک بیگانه را خواهد گرفت. برای اصلاح این مسئله، باید نحوه‌ی شناسایی برخورد گلوله و بیگانه را اصلاح کنیم.</p><p>در متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_bullet_alien_collisions()</span><span class="rlm">‏</span>، هر گلوله‌ای که به یک بیگانه اصابت کند، به‌عنوان کلید در دیکشنری <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">collisions</span><span class="rlm">‏</span> وارد می‌شود. مقدار مربوط به هر گلوله، لیستی از بیگانه‌هایی است که با آن‌ها برخورد کرده است. یک حلقه روی مقادیر دیکشنری <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">collisions</span><span class="rlm">‏</span> تشکیل می‌دهیم تا امتیاز مربوط به تمام بیگانه‌های ساقط‌شده محاسبه شود:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr"><span class="ash">def _check_bullet_alien_collisions(self):</span>
    <span class="ash">--<span class="it">snip</span>--</span>
    <span class="ash">if collisions:</span>
<span class="n" dir="ltr">1</span>        for aliens in collisions.values():
            self.stats.score += self.settings.alien_points * len(aliens)
        <span class="ash">self.sb.prep_score()</span>
    <span class="ash">--<span class="it">snip</span>--</span></pre></div><p>اگر دیکشنری <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">collisions</span><span class="rlm">‏</span> تعریف شده باشد، روی تمام مقادیر دیکشنری حلقه تشکیل می‌دهیم. یادتان باشد که هر کدام از مقادیر، لیستی از بیگانه‌ها است که مورد اصابت یک گلوله قرار گرفته‌اند. ما ارزش امتیاز یک بیگانه را در تعداد بیگانه‌های موجود در لیست ضرب می‌کنیم و این مقدار را به امتیاز کنونی اضافه می‌کنیم. برای آزمایش کردن این مطلب، عرض گلوله را به ۳۰۰ پیکسل تغییر دهید و ببینید که به‌ازای هر بیگانه‌ای که مورد اصابت این گلوله‌های بسیار پهن قرار می‌گیرد، امتیاز به شما داده می‌شود؛ سپس عرض گلوله را به مقدار طبیعی آن بازگردانید.</p></div><div class="sect" id="ch14lev2sec14"><a class="bkmk" name="ch14lev2sec14"></a><h4>افزایش دادن مقدار امتیاز</h4>
<p class="noindent">از آنجا که هر گاه بازیکن به سطح جدیدی می‌رسد، بازی دشوارتر می‌شود، لذا باید برای بیگانه‌ها در سطح‌های بالاتر، امتیاز بیشتری در نظر گرفته شود. برای پیاده‌سازی این قابلیت، کد زیر را اضافه می‌کنیم تا مقدار امتیاز را با بالاتر رفتن سرعت بازی، افزایش دهیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">settings.py</div><pre class="snippet" dir="ltr"><span class="ash">class Settings:</span>
    <span class="ash">"""A class to store all settings for Alien Invasion."""</span>
    <span class="ash">def __init__(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash"># How quickly the game speeds up</span>
        <span class="ash">self.speedup_scale = 1.1</span>
<a id="p293"></a>        # How quickly the alien point values increase
<span class="n" dir="ltr">1</span>        self.score_scale = 1.5
        <span class="ash">self.initialize_dynamic_settings()</span>
    <span class="ash">def initialize_dynamic_settings(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
    <span class="ash">def increase_speed(self):</span>
        """Increase speed settings and alien point values."""
        <span class="ash">self.ship_speed *= self.speedup_scale</span>
        <span class="ash">self.bullet_speed *= self.speedup_scale</span>
        <span class="ash">self.alien_speed *= self.speedup_scale</span>
<span class="n" dir="ltr">2</span>        self.alien_points = int(self.alien_points * self.score_scale)</pre></div><p>متغیری به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">score_scale</span><span class="rlm">‏</span> اضافه می‌کنیم که نشان‌دهنده‌ی میزان افزایش امتیاز است <span class="n" dir="ltr">1</span>. افزایش اندکی در سرعت بازی (۱٫۱ برابر) سبب می‌شود که دشواری بازی خیلی زود افزایش یابد. ولی برای اینکه تفاوت در امتیازدهی مشهود باشد، لازم است که مقدار امتیاز به میزان بیشتری افزایش داده شود (۱٫۵ برابر). حالا وقتی که سرعت بازی را افزایش می‌دهیم، میزان امتیاز تیراندازی به بیگانه‌ها را نیز بیشتر می‌کنیم <span class="n" dir="ltr">2</span>. برای اینکه مقدار افزوده شده به امتیاز به‌صورت عدد صحیح باشد، از تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">int()</span><span class="rlm">‏</span> استفاده می‌کنیم.</p><p>برای اینکه مقدار امتیاز هر بیگانه را ببینید، یک دستور <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">print()</span><span class="rlm">‏</span> به متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">increase_speed()</span><span class="rlm">‏</span> در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Settings</span><span class="rlm">‏</span> اضافه کنید:</p><div class="snippet"><div class="snippet-title" dir="ltr">settings.py</div><pre class="snippet" dir="ltr">    <span class="ash">def increase_speed(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash">self.alien_points = int(self.alien_points * self.score_scale)</span>
        print(self.alien_points)</pre></div><p>با این کار، هر گاه به سطح جدیدی می‌رسید، مقدار امتیاز جدید در ترمینال نمایش داده خواهد شد.</p><div class="note"><h6 class="note-title">توجه</h6>
<p class="noindent">بعد از اینکه افزایش یافتن مقدار امتیاز را دیدید، حتماً فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">print()</span><span class="rlm">‏</span> فوق را حذف کنید، در غیر این صورت، ممکن است بر عملکرد بازی شما تأثیر بگذارد و موجب پرت شدن حواس بازیکن شود.</p></div></div><div class="sect" id="ch14lev2sec15"><a class="bkmk" name="ch14lev2sec15"></a><h4>گِرد کردن امتیاز</h4>
<p class="noindent">اکثر بازی‌های ویدئویی تیراندازی امتیاز را به‌صورت مضرب ۱۰ گزارش می‌کنند، پس ما هم بهتر است به همین صورت عمل کنیم. ضمن اینکه امتیاز را به‌گونه‌ای فرمت می‌کنیم که برای اعداد بزرگ، از کاما استفاده کند. این تغییر را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Scoreboard</span><span class="rlm">‏</span> اعمال می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">scoreboard.py</div><pre class="snippet" dir="ltr">    <span class="ash">def prep_score(self):</span>
        <span class="ash">"""Turn the score into a rendered image."""</span>
<span class="n" dir="ltr">1</span>        rounded_score = round(self.stats.score, -1)
<span class="n" dir="ltr">2</span>        score_str = "{:,}".format(rounded_score)
        <span class="ash">self.score_image = self.font.render(score_str, True,</span>
                <span class="ash">self.text_color, self.settings.bg_color)</span>
        <span class="ash">--<span class="it">snip</span>--</span></pre></div><a id="p294"></a><p>تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">round()</span><span class="rlm">‏</span> در حالت عادی یک عدد اعشاری را تا تعداد اعشار داده شده در آرگومان دوم گرد می‌کند. ولی اگر آرگومان دوم عددی منفی باشد، در آن صورت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">round()</span><span class="rlm">‏</span> مقدار داده‌شده را تا نزدیک‌ترین مضرب ۱۰، ۱۰۰، ۱۰۰۰، و غیره گرد خواهد کرد. بر این اساس، کد درج شده در <span class="n" dir="ltr">1</span> به پایتون می‌گوید که مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">stats.score</span><span class="rlm">‏</span> را تا نزدیک‌ترین مضرب ۱۰ گرد کند و آن را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rounded_score</span><span class="rlm">‏</span> ذخیره کند.</p><p>در <span class="n" dir="ltr">2</span>، دستور فرمت رشته به پایتون می‌گوید که هنگام تبدیل کردن عدد به رشته، آن را با کاما فرمت کند: مثلاً به جای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">1000000</span><span class="rlm">‏</span>، به‌صورت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">1,000,000</span><span class="rlm">‏</span> بنویسد. حالا وقتی که بازی را اجرا می‌کنید، امتیاز خود را به‌صورت گرد شده و فرمت شده خواهید دید، همان طور که در <refFig xmlns="urn:dox:pycc">۱۴-۳</refFig> نشان داده شده است.</p><figure class="fig" id="ch14_fig03"><img class="fig" src="images/ch14_fig03.jpg"/><figcaption class="fig">شکل ۱۴-۳: نمره‌ی گرد شده با جدا کننده‌ی کاما.</figcaption></figure></div><div class="sect" id="ch14lev2sec16"><a class="bkmk" name="ch14lev2sec16"></a><h4>بالاترین امتیازات</h4>
<p class="noindent">هر کدام از بازیکنان دوست دارند که از بالاترین امتیاز قبلی بازی جلو بزنند، ازاین‌رو بد نیست که بالاترین امتیاز را ثبت کنیم و آن را نمایش دهیم، تا بازیکن انگیزه‌ای برای تلاش بیشتر داشته باشد. بالاترین امتیاز را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">GameStats</span><span class="rlm">‏</span> ذخیره می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">game_stats.py</div><pre class="snippet" dir="ltr">    <span class="ash">def __init__(self, ai_game):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        # High score should never be reset.
        self.high_score = 0</pre></div><p>از آنجا که بالاترین امتیاز هرگز نباید دوباره به حالت اول بازگردانده شود، لذا مقداردهی اولیه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">high_score</span><span class="rlm">‏</span> را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> انجام می‌دهیم، نه در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">reset_stats()</span><span class="rlm">‏</span>.</p><a id="p295"></a><p>سپس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Scoreboard</span><span class="rlm">‏</span> را برای نمایش بالاترین امتیاز تغییر می‌دهیم. از متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> شروع می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">scoreboard.py</div><pre class="snippet" dir="ltr">    <span class="ash">def __init__(self, ai_game):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        # Prepare the initial score images.
        <span class="ash">self.prep_score()</span>
<span class="n" dir="ltr">1</span>        self.prep_high_score()</pre></div><p>بالاترین امتیاز جدا از امتیاز نمایش داده خواهد شد، لذا نیاز به متد جدیدی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_high_score()</span><span class="rlm">‏</span> داریم تا تصویر بالاترین امتیاز را آماده کنیم <span class="n" dir="ltr">1</span>.</p><p>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_high_score()</span><span class="rlm">‏</span> به‌صورت زیر است:</p><div class="snippet"><div class="snippet-title" dir="ltr">scoreboard.py</div><pre class="snippet" dir="ltr">    def prep_high_score(self):
        """Turn the high score into a rendered image."""
<span class="n" dir="ltr">1</span>        high_score = round(self.stats.high_score, -1)
        high_score_str = "{:,}".format(high_score)
<span class="n" dir="ltr">2</span>        self.high_score_image = self.font.render(high_score_str, True,
                self.text_color, self.settings.bg_color)
        # Center the high score at the top of the screen.
        self.high_score_rect = self.high_score_image.get_rect()
<span class="n" dir="ltr">3</span>        self.high_score_rect.centerx = self.screen_rect.centerx
<span class="n" dir="ltr">4</span>        self.high_score_rect.top = self.score_rect.top</pre></div><p>بالاترین امتیاز را تا نزدیک‌ترین مضرب ۱۰ گرد می‌کنیم و آن را با کاما فرمت می‌کنیم <span class="n" dir="ltr">1</span>. سپس توصیری از بالاترین امتیاز را آماده منیکم <span class="n" dir="ltr">2</span>، شیء <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> بالاترین امتیاز را از نظر افقی در وسط قرار می‌دهیم <span class="n" dir="ltr">3</span>، و مقدار صفت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">top</span><span class="rlm">‏</span> آن را هم‌مقدار با بالای تصویر امتیاز قرار می‌دهیم <span class="n" dir="ltr">4</span>.</p><p>حالا متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">show_score()</span><span class="rlm">‏</span> امتیاز کنونی را در گوشه‌ی بالای رساات صفحه درج می‌کند و بالاترین امتیاز را در وسط بالای صفحه نمایش می‌دهد:</p><div class="snippet"><div class="snippet-title" dir="ltr">scoreboard.py</div><pre class="snippet" dir="ltr">    <span class="ash">def show_score(self):</span>
        <span class="ash">"""Draw score to the screen."""</span>
        <span class="ash">self.screen.blit(self.score_image, self.score_rect)</span>
        self.screen.blit(self.high_score_image, self.high_score_rect)</pre></div><p>برای وارسی کردن بالاترین امتیاز، متد جدیدی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">check_high_score()</span><span class="rlm">‏</span> به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Scoreboard</span><span class="rlm">‏</span> اضافه می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">scoreboard.py</div><pre class="snippet" dir="ltr">    def check_high_score(self):
        """Check to see if there's a new high score."""
        if self.stats.score &gt; self.stats.high_score:
            self.stats.high_score = self.stats.score
            self.prep_high_score()</pre></div><p>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">check_high_score()</span><span class="rlm">‏</span> امتیاز کنونی را با بالاترین امتیاز مقایسه می‌کند. اگر امتیاز کنونی بزرگ‌تر باشد، مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">high_score</span><span class="rlm">‏</span> را تغییر می‌دهیم، و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_high_score()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم تا تصویر بالاترین امتیاز را آماده‌سازی کند.</p><a id="p296"></a><p>لازم است که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">check_high_score()</span><span class="rlm">‏</span> را هر بار که یک بیگانه مورد اصابت قرار می‌گیرد، پس از اصلاح کردن امتیاز در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_bullet_alien_collisions()</span><span class="rlm">‏</span> فراخوانی کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _check_bullet_alien_collisions(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash">if collisions:</span>
            <span class="ash">for aliens in collisions.values():</span>
                <span class="ash">self.stats.score += self.settings.alien_points * len(aliens)</span>
            <span class="ash">self.sb.prep_score()</span>
            self.sb.check_high_score()
        <span class="ash">--<span class="it">snip</span>--</span></pre></div><p>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">check_high_score()</span><span class="rlm">‏</span> را زمانی که دیکشنری <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">collisions</span><span class="rlm">‏</span> وجود داشته باشد، فراخوانی می‌کنیم، و این کار را پس از به‌روزرسانی امتیاز برای تمام بیگانه‌هایی که ساقط کرده‌ایم، انجام می‌دهیم.</p><p>نخستین بار که <span class="emphasis">تهاجم بیگانگان</span> را اجرا می‌کنید، امتیاز شما بالاترین امتیاز خواهد بود، بالاترین هم به‌عنوان امتیاز کنونی و هم به‌عنوان بالاترین امتیاز نمایش داده خواهد شد. ولی وقتی که بازی دوم را شروع می‌کنید، بالاترین امتیاز شما در وسط و امتیاز کنونی شما در سمت راست نمایش داده خواهد شد، مانند <refFig xmlns="urn:dox:pycc">۱۴-۴</refFig>.</p><figure class="fig" id="ch14_fig04"><img class="fig" src="images/ch14_fig04.jpg"/><figcaption class="fig">شکل ۱۴-۴: بالاترین امتیاز باز یدر وسط بالای صفحه نمایش داده می‌شود.</figcaption></figure></div><div class="sect" id="ch14lev2sec17"><a class="bkmk" name="ch14lev2sec17"></a><h4>نمایش دادن سطح بازی</h4>
<p class="noindent">برای نمایش دادن سطح بازی، ابتدا نیاز به یک صفت در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">GameStats</span><span class="rlm">‏</span> داریم که که نشان دهنده‌ی سطح کنونی بازی باشد. برای اینکه در آغاز هر دور بازی، سطح بازی به مقدار اولیه بازگردانده شود، مقداردهی اولیه را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">reset_stats()</span><span class="rlm">‏</span> انجام می‌دهیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">game_stats.py</div><pre class="snippet" dir="ltr">    <span class="ash">def reset_stats(self):</span>
        <span class="ash">"""Initialize statistics that can change during the game."""</span>
        <span class="ash">self.ships_left = self.settings.ship_limit</span>
<a id="p297"></a>        <span class="ash">self.score = 0</span>
        self.level = 1</pre></div><p>برای نمایش سطح کنونی بازی در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Scoreboard</span><span class="rlm">‏</span>، متد جدیدی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_level()</span><span class="rlm">‏</span> را از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> فراخوانی می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">scoreboard.py</div><pre class="snippet" dir="ltr">    <span class="ash">def __init__(self, ai_game):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash">self.prep_high_score()</span>
        self.prep_level()</pre></div><p>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_level()</span><span class="rlm">‏</span> به‌صورت زیر است:</p><div class="snippet"><div class="snippet-title" dir="ltr">scoreboard.py</div><pre class="snippet" dir="ltr">    def prep_level(self):
        """Turn the level into a rendered image."""
        level_str = str(self.stats.level)
<span class="n" dir="ltr">1</span>        self.level_image = self.font.render(level_str, True,
                self.text_color, self.settings.bg_color)
        # Position the level below the score.
        self.level_rect = self.level_image.get_rect()
<span class="n" dir="ltr">2</span>        self.level_rect.right = self.score_rect.right
<span class="n" dir="ltr">3</span>        self.level_rect.top = self.score_rect.bottom + 10</pre></div><p>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_level()</span><span class="rlm">‏</span> تصویری از مقدار ذخیره شده در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">stats.level</span><span class="rlm">‏</span> ایجاد می‌کند <span class="n" dir="ltr">1</span>، و به صفت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">right</span><span class="rlm">‏</span> تصویر، همان منقدار صفت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">right</span><span class="rlm">‏</span> امتیاز را اختصاص می‌دهد <span class="n" dir="ltr">2</span>. سپس مقدار صفت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">top</span><span class="rlm">‏</span> را ۱۰ پیکسل زیر لبه‌ی پایین تصویر امتیاز قرار می‌دهد، تا مقداری فضا بین امتیاز و سطح وجود داشته باشد <span class="n" dir="ltr">3</span>.</p><p>در ضمن، باید <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">show_score()</span><span class="rlm">‏</span> را نیز اصلاح کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">scoreboard.py</div><pre class="snippet" dir="ltr">    <span class="ash">def show_score(self):</span>
        """Draw scores and level to the screen."""
        <span class="ash">self.screen.blit(self.score_image, self.score_rect)</span>
        <span class="ash">self.screen.blit(self.high_score_image, self.high_score_rect)</span>
        self.screen.blit(self.level_image, self.level_rect)</pre></div><p>این سطر جدید، تصویر سطح بازی را روی صفحه ترسیم می‌کند.</p><p>در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_bullet_alien_collisions()</span><span class="rlm">‏</span>، مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">stats.level</span><span class="rlm">‏</span> را یکی اضافه می‌کنیم و تصویر سطح بازی را نوسازی می‌نماییم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _check_bullet_alien_collisions(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash">if not self.aliens:</span>
            <span class="ash"># Destroy existing bullets and create new fleet.</span>
            <span class="ash">self.bullets.empty()</span>
            <span class="ash">self._create_fleet()</span>
            <span class="ash">self.settings.increase_speed()</span>
            # Increase level.
            self.stats.level += 1
            self.sb.prep_level()</pre></div><a id="p298"></a><p>اگر تمام ناوگان نابود شده باشد، به مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">stats.level</span><span class="rlm">‏</span> یکی اضافه می‌کنیم و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_level()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم تا سطح جدید بازی به درستی روی صفحه نمایش داده شود.</p><p>برای اطمینان از اینکه تصویر سطح به درستی در آغاز بازی جدید به درستی نمایش داده شود، متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_level()</span><span class="rlm">‏</span> را زمانی هم که بازیکن روی دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> کلیک می‌کند، فراخوانی می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _check_play_button(self, mouse_pos):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash">if button_clicked and not self.stats.game_active:</span>
            <span class="ash">--<span class="it">snip</span>--</span>
            <span class="ash">self.sb.prep_score()</span>
            self.sb.prep_level()
            <span class="ash">--<span class="it">snip</span>--</span></pre></div><p>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_level()</span><span class="rlm">‏</span> را درست بعد از فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_score()</span><span class="rlm">‏</span>، فراخوانی می‌کنیم.</p><p>حالا خواهید توانست ببینید که چند سطح بازی را تا کنون تکمیل کرده‌اید، همان‌گونه که در <refFig xmlns="urn:dox:pycc">۱۴-۵</refFig> نشان داده شده است.</p><figure class="fig" id="ch14_fig05"><img class="fig" src="images/ch14_fig05.jpg"/><figcaption class="fig">شکل ۱۴-۵: سطح کنونی بازی درست زیر امتیاز کنونی نمایش داده می‌شود.</figcaption></figure><div class="note"><h6 class="note-title">توجه</h6>
<p class="noindent">در برخی از بازی‌های کلاسیک، امتیازها با برچسب یا عنوان نمایش داده می‌شود، مثلاً «امتیاز»، «بالاترین امتیاز»، و «سطح». ما این برچسب‌ها را حذف کرده‌ایم، چرا که وقتی بازی کنید، معنای هر عدد خودبه‌خود معلوم می‌شود. برای اینکه عنوان‌ها را هم بگذارید، آن را درست قبل از فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">font.render()</span><span class="rlm">‏</span> در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Scoreboard</span><span class="rlm">‏</span>، به رشته‌ی عدد مربوطه اضافه کنید.</p></div></div><div class="sect" id="ch14lev2sec18"><a class="bkmk" name="ch14lev2sec18"></a><h4>نمایش دادن تعداد سفینه‌ها</h4>
<p class="noindent">سرانجام، می‌خواهیم تعداد سفینه‌های باقی‌مانده‌ی بازیکن را هم نمایش دهیم، ولی این بار قصد داریم از نمایش تصویری استفاده کنیم. برای این منظور، سفینه‌ها را در گوشه‌ی بالای چپ <a id="p299"></a>صفحه ترسیم، تا مشخص شود که چه تعداد سفینه باقی مانده است، درست مانند چیزی که در بعضی بازی‌های کلاسیک نمایش داده می‌شود.</p><p>ابتدا، لازم است که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> را از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Sprite</span><span class="rlm">‏</span> مشتق کنیم، تا بتوانیم گروهی از سفینه‌ها ایجاد کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">ship.py</div><pre class="snippet" dir="ltr"><span class="ash">import pygame</span>
from pygame.sprite import Sprite

<span class="n" dir="ltr">1</span>class Ship(Sprite):
    <span class="ash">"""A class to manage the ship."""</span>

    <span class="ash">def __init__(self, ai_game):</span>
        <span class="ash">"""Initialize the ship and set its starting position."""</span>
<span class="n" dir="ltr">2</span>        super().__init__()
        <span class="ash">--<span class="it">snip</span>--</span></pre></div><p>در اینجا، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Sprite</span><span class="rlm">‏</span> را ایمپورت می‌کنیم، و توارث <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Sprite</span><span class="rlm">‏</span> را برقرار می‌کنیم <span class="n" dir="ltr">1</span>، و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">super()</span><span class="rlm">‏</span> را در ابتدای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> فراخوانی می‌کنیم <span class="n" dir="ltr">2</span>.</p><p>سپس، لازم است که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Scoreboard</span><span class="rlm">‏</span> را تغییر دهیم تا گروهی از سفینه‌ها برای نمایش ایجاد کنیم. دستورالعمل‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">import</span><span class="rlm">‏</span> لازم برای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Scoreboard</span><span class="rlm">‏</span> به‌صورت زیر است:</p><div class="snippet"><div class="snippet-title" dir="ltr">scoreboard.py</div><pre class="snippet" dir="ltr"><span class="ash">import pygame.font</span>
from pygame.sprite import Group

from ship import Ship</pre></div><p>از آنجا که می‌خواهیم گروهی از سفینه‌ها ایجاد کنیم، لذا کلاس‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Group</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> را ایمپورت می‌کنیم:</p><p>تغییرات <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> به‌صورت زیر است:</p><div class="snippet"><div class="snippet-title" dir="ltr">scoreboard.py</div><pre class="snippet" dir="ltr">    <span class="ash">def __init__(self, ai_game):</span>
        <span class="ash">"""Initialize scorekeeping attributes."""</span>
        self.ai_game = ai_game
        <span class="ash">self.screen = ai_game.screen</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash">self.prep_level()</span>
        self.prep_ships()</pre></div><p>نمونه‌ی بازی را به یک صفت اختصاص می‌دهیم، زیرا برای ایجاد سفینه‌ها به آن نیاز خواهیم داشت. متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_ships()</span><span class="rlm">‏</span> را پس از فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_level()</span><span class="rlm">‏</span>، فراخوانی می‌کنیم.</p><p>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_ships()</span><span class="rlm">‏</span> به‌صورت زیر است:</p><div class="snippet"><div class="snippet-title" dir="ltr">scoreboard.py</div><pre class="snippet" dir="ltr">    def prep_ships(self):
        """Show how many ships are left."""
<span class="n" dir="ltr">1</span>        self.ships = Group()
<span class="n" dir="ltr">2</span>        for ship_number in range(self.stats.ships_left):
            ship = Ship(self.ai_game)
<span class="n" dir="ltr">3</span>            ship.rect.x = 10 + ship_number * ship.rect.width
<span class="n" dir="ltr">4</span>            ship.rect.y = 10
<span class="n" dir="ltr">5</span>            self.ships.add(ship)</pre></div><a id="p300"></a><p>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_ships()</span><span class="rlm">‏</span> یک گروه خالی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.ships</span><span class="rlm">‏</span> ایجاد می‌کند، تا نمونه‌های سفینه در آن قرار گیرد <span class="n" dir="ltr">1</span>. برای پر کردن این گروه، حلقه برای هر کدام از سفینه‌های باقی‌مانده‌ی بازیکن یک بار اجرا می‌شود <span class="n" dir="ltr">2</span>. در داخل حلقه، سفینه‌ی جدیدی ایجاد می‌کنیم و مقدار مختصه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> سفینه را به‌گونه‌ای تعیین می‌کنیم که سفینه‌ها در کنار هم قرار گیرند در یک حاشیه‌ی ۱۰ پیکسلی در سمت چپ گروه سفینه‌ها وجود داشته باشد <span class="n" dir="ltr">3</span>. مقدار مختصه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> را به میزان ۱۰ پیکسل پایین‌تر از بالای صفحه قرار می‌دهیم به‌طوری که سفینه‌ها در گوشه‌ی بالای چپ صفحه نمایش داده شوند <span class="n" dir="ltr">4</span>. سپس هر سفینه‌ی جدید را به گروه <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">ships</span><span class="rlm">‏</span> اضافه می‌کنیم <span class="n" dir="ltr">5</span>.</p><p>حالا باید سفینه‌ها را روی صفحه ترسیم کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">scoreboard.py</div><pre class="snippet" dir="ltr">
    <span class="ash">def show_score(self):</span>
        """Draw scores, level, and ships to the screen."""
        <span class="ash">self.screen.blit(self.score_image, self.score_rect)</span>
        <span class="ash">self.screen.blit(self.high_score_image, self.high_score_rect)</span>
        <span class="ash">self.screen.blit(self.level_image, self.level_rect)</span>
        self.ships.draw(self.screen)</pre></div><p>برای نمایش سفینه‌ها روی صفحه، متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">draw()</span><span class="rlm">‏</span> را روی گروه فراخوانی می‌کنیم تا پای‌گیم هر کدام از سفینه‌ها را ترسیم کند.</p><p>برای اینکه به بازیکن نشان دهیم که در ابتدا چند سفینه دارد، هنگام شروع بازی جدید، متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_ships()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم. این کار را در متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_play_button()</span><span class="rlm">‏</span> در کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AlienInvasion</span><span class="rlm">‏</span> انجام می‌دهیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _check_play_button(self, mouse_pos):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash">if button_clicked and not self.stats.game_active:</span>
            <span class="ash">--<span class="it">snip</span>--</span>
            <span class="ash">self.sb.prep_score()</span>
            <span class="ash">self.sb.prep_level()</span>
            self.sb.prep_ships()
            <span class="ash">--<span class="it">snip</span>--</span></pre></div><p>هم‌چنین، زمانی که یک سفینه مورد اصابت قرار می‌گیرد، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_ships()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم تا تصویر سفینه‌ها نوسازی شود:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _ship_hit(self):</span>
        <span class="ash">"""Respond to ship being hit by alien."""</span>
        <span class="ash">if self.stats.ships_left &gt; 0:</span>
            # Decrement ships_left, and update scoreboard.
            <span class="ash">self.stats.ships_left -= 1</span>
            self.sb.prep_ships()
            <span class="ash">--<span class="it">snip</span>--</span></pre></div><p>فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_ships()</span><span class="rlm">‏</span> را پس از کاهش دادن مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">ships_left</span><span class="rlm">‏</span> انجام می‌دهیم، تا هر زمان که سفینه‌ای نابود می‌شود، تعداد صحیح سفینه‌ها نمایش داده شود.</p><p><refFig xmlns="urn:dox:pycc">۱۴-۶</refFig> سیستم کامل امتیازدهی را نشان می‌دهد که در آن تعداد سفینه‌های باقی‌مانده در قسمت بالای چپ صفحه نمایش داده می‌شود.</p><a id="p301"></a><figure class="fig" id="ch14_fig06"><img class="fig" src="images/ch14_fig06.jpg"/><figcaption class="fig">شکل ۱۴-۶: سیستم کامل امتیازدهی در بازی تهاجم بیگانگان.</figcaption></figure><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<p class="tiy1"><span class="tiy" id="ch14_tiy05"><span class="tiy-num">۱۴-۵</span>. <span class="tiy-title">بالاترین امتیاز تمام اوقات</span>: </span> هر بار که بازیکن بازی <span class="emphasis">تهاجم بیگانگان</span> را می‌بندد و دوباره باز می‌کند، بالاترین امتیاز به مقدار اولیه بازگردانده می‌شود. این مشکل را با نوشتن بالاترین امتیاز در یک فایل قبل از فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">sys.exit()</span><span class="rlm">‏</span> و خواندن آن در هنگام مقداردهی اولیه‌ی آن در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">GameStats</span><span class="rlm">‏</span>، برطرف کنید.</p><p class="tiy1"><span class="tiy" id="ch14_tiy06"><span class="tiy-num">۱۴-۶</span>. <span class="tiy-title">بازساخت</span>: </span> متدهایی را که بیش از یک کار انجام می‌دهند، پیدا کنید و آنها را بازساخت کنید تا کد شما سازمان‌دهی و کارایی بهتری داشته باشد. مثلاً، مقداری از کد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_bullet_alien_collisions()</span><span class="rlm">‏</span> را که هنگام نابود شدن ناوگان بیگانه‌ها، سطح جدیدی از بازی را آغاز می‌کند، به تابعی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">start_new_level()</span><span class="rlm">‏</span> منتقل کنید. هم‌چنین، چهار فراخوانی متد در متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Scoreboard</span><span class="rlm">‏</span> را به می‌توانید به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_images()</span><span class="rlm">‏</span> منتقل کنید تا متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> کوتاه‌تر شود. متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">prep_images()</span><span class="rlm">‏</span> می‌تواند به ساده‌تر کردن <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_play_button()</span><span class="rlm">‏</span> یا <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">start_game()</span><span class="rlm">‏</span> نیز در صورتی که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_play_button()</span><span class="rlm">‏</span> را قبلاً بازساخت کرده باشید، کمک کند.</p><div class="note"><h6 class="note-title">توجه</h6>
<p class="noindent">قبل از تلاش برای بازساخت پروژه، به <span class="ref"><a href="c40-appd.xhtml">ضمیمه‌ی ت</a></span> مراجعه کنید تا یاد بگیرید که اگر در حین بازساخت خطاهایی را وارد برنامه کردید، چگونه می‌توانید به حالت قبلی که درست کار می‌کرد، بازگردید.</p></div><a id="p302"></a><p class="tiy1"><span class="tiy" id="ch14_tiy07"><span class="tiy-num">۱۴-۷</span>. <span class="tiy-title">توسعه‌ی بازی</span>: </span> راهی برای توسعه دادن بازی <span class="rlm">‏</span><span class="lr" dir="ltr">تهاجم بیگانگان</span><span class="rlm">‏</span> پیدا کنید. مثلاً می‌توانید کدی بنویسید که بیگانه‌ها به سمت پایین به طرف سفینه گلوله شلیک کنند، یا سپرهایی اضافه کنید که سفینه پشت آن پنهان شود، که در این صورت با شلیک از دو طرف امکان نابود کردن آن وجود خواهد داشت. یا اینکه از چیزی مانند مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame.mixer</span><span class="rlm">‏</span> استفاده کنید تا جلوه‌های صوتی به برنامه اضافه کنید، مثلاً صدای انفجار یا تیراندازی.</p><p class="tiy1"><span class="tiy" id="ch14_tiy08"><span class="tiy-num">۱۴-۸</span>. <span class="tiy-title">شلیک جانبی، نسخه‌ی نهایی</span>: </span> تمام چیزهایی را که در این پروژه یاد گرفتید، برای توسعه‌ی بازی شلیک جانبی به کار بگیرید. دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> به آن اضافه کنید، سرعت بازی را به میزان مناسب افتاده‌اید، و یک سیستم امتیازدهی برای آن ایجاد کنید. حتماً کدتان را بازساخت کنید، و سعی کنید فراتر از آنچه در این فصل گفته شده، راه‌هایی برای سفارشی‌سازی بازی خود بیابید.</p></div></div></div><div class="sect" id="ch14lev1sec4"><a class="bkmk" name="ch14lev1sec4"></a><h3>خلاصه</h3>
<p class="noindent">در این فصل، نحوه‌ی پیاده‌سازی دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Play</span><span class="rlm">‏</span> برای شروع کردن بازی جدید، شناسایی رویدادهای ماوس، و مخفی کردن نشانگر ماوس در هنگام بازی فعال را یاد گرفتید. می‌توانید با استفاده از آنچه یاد گرفته‌اید، دکمه‌های دیگری را به بازی‌های خود اضافه کنید، مثلاً یک دکمه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">Help</span><span class="rlm">‏</span> برای نمایش دادن اطلاعاتی درباره‌ی نحوه‌ی انجام بازی. هم‌چنین، یاد گرفتید که چگونه با پیشرفت بازی، سرعت آن را افتاده‌اید، چگونه یک سیستم پیشرفته‌ی امتیازدهی را پیاده‌سازی کنید، و چگونه اطلاعات را به‌صورت متنی و غیرمتنی نمایش دهید.</p></div></div>
						<div class="row pager"><div class="col-md-5 text-center text-md-left pager-prev"><a href="c26-ch13.xhtml"><span xmlns="http://www.w3.org/1999/xhtml"><span>فصل ۱۳</span>: <span>بیگانه‌ها!</span></span></a></div><div class="col-md-2 text-center pager-title"><a href="c01-cover.xhtml">آغاز</a></div><div class="col-md-5 text-center text-md-right pager-next"><a href="c28-prj2.xhtml"><span xmlns="http://www.w3.org/1999/xhtml"><span>پروژه‌ی ۲</span>: <span>مصورسازی داده‌ها</span></span></a></div></div></main><aside class="col-md-2 order-md-first"><ul class="nav nav-pills flex-column"><li class="nav-item"><a class="nav-link" href="../">دوره‌ی فشرده‌ی پایتون</a></li><li class="nav-item"><a class="nav-link" href="c06-toc.xhtml">فهرست</a></li></ul></aside></div></div><div class="container"><div id="footer" class="row"><div class="col-sm-6"><p><span>© ۱۴۰۰، قاسم کیانی مقدم.</span></p></div><div class="col-sm-6"><p class="text-right"><span><a target="_blank" rel="me" href="https://linkedin.com/in/ghasemkiani" title="لینکدین"><span class="fab fa-linkedin"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://github.com/ghasemkiani" title="گیت‌هاب"><span class="fab fa-github"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://twitter.com/ghasemkiani" title="توئیتر"><span class="fab fa-twitter"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://facebook.com/ghasemkiani" title="فیس‌بوک"><span class="fab fa-facebook"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://telegram.me/ghasemkiani" title="تلگرام"><span class="fab fa-telegram"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://instagram.com/ghasem.kiani" title="اینستاگرام"><span class="fab fa-instagram"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://mastodon.social/@ghasemkiani" title="ماستودون"><span class="fab fa-mastodon"></span></a></span></p></div></div></div><script crossorigin="anonymous" src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"></script><script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut"></script><script crossorigin="anonymous" src="https://cdn.rtlcss.com/bootstrap/v4.0.0/js/bootstrap.min.js" integrity="sha384-54+cucJ4QbVb99v8dcttx/0JRx4FHMmhOWi4W+xrXpKcsKQodCBwAvu3xxkZAwsH"></script><script src="https://www.googletagmanager.com/gtag/js?id=undefined"></script><script src="data:application/javascript;charset=UTF-8;base64,KCh7aWR9KSA9PiB7DQoJd2luZG93LmRhdGFMYXllciA9IHdpbmRvdy5kYXRhTGF5ZXIgfHwgW107DQoJZnVuY3Rpb24gZ3RhZygpe2RhdGFMYXllci5wdXNoKGFyZ3VtZW50cyk7fQ0KCWd0YWcoImpzIiwgbmV3IERhdGUoKSk7DQoNCglndGFnKCJjb25maWciLCBpZCk7DQp9KSh7fSk7Cg=="></script></body></html>