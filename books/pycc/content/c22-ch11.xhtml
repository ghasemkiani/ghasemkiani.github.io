<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="fa" dir="rtl"><head><meta charset="utf-8"/><title>آزمایش کد</title><meta name="description" content="وب‌سایت قاسم کیانی مقدم"/><meta name="keywords" content="قاسم کیانی مقدم, وب‌سایت, وب‌سایت قاسم کیانی مقدم, کتاب, فارسی, کتاب فارسی, ترجمه, برنامه‌نویسی, جاوا, جاوا اسکریپت, پزشکی, طب اطفال"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="stylesheet" crossorigin="anonymous" href="https://cdn.rtlcss.com/bootstrap/v4.0.0/css/bootstrap.min.css" integrity="sha384-P4uhUIGk/q1gaD/NdgkBIl3a6QywJjlsFJFk7SPRdruoGddvRVSwv5qFnvZ73cpz"/><link rel="stylesheet" crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.7.1/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr"/><link rel="icon" href="../../../favicon.ico"/><style>@import url(https://fonts.googleapis.com/css?family=Droid+Sans);
@import url(https://fonts.googleapis.com/css?family=Droid+Serif);
@import url(https://fonts.googleapis.com/css?family=Droid+Arabic+Kufi);
@import url(https://fonts.googleapis.com/css?family=Droid+Arabic+Naskh);
html,body,input,textarea,select,option,h1,h2,h3,h4,h5,h6{font-family:Droid Arabic Naskh,Droid Serif;}
nav,.nav{font-family:Droid Arabic Kufi,Droid Sans;}
h1,h2,h3,h4,h5,h6{font-family:Droid Arabic Naskh,Droid Serif;}
#footer{margin-top:0.5rem;padding-top:0.5rem;border-top:#eeeeee solid thick;}</style><style>@import url(https://fonts.googleapis.com/css?family=Courier+Prime);
div.row.pager{margin-top:0.5em;padding:0.5em 0;border-top:solid #cccccc 2px;background-color:#dddddd;}
div.pager-prev{}
div.pager-title{}
div.pager-next{}</style><link rel="stylesheet" type="text/css" href="styles.css"/></head><body style="min-height:75rem;"><nav class="navbar navbar-expand-md navbar-dark bg-dark mb-4"><div class="container"><a class="navbar-brand" href="../../../">وب‌سایت قاسم کیانی مقدم</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#divNavBarToggle" aria-controls="divNavBarToggle" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div id="divNavBarToggle" class="collapse navbar-collapse"><ul class="navbar-nav mr-auto"><li class="nav-item active"><a class="nav-link" href="../../">کتاب‌ها<span class="sr-only"> (current)</span></a></li><li class="nav-item"><a class="nav-link" href="../../../essays/">مقالات</a></li><li class="nav-item"><a class="nav-link" href="../../../translation/">ترجمه</a></li><li class="nav-item"><a class="nav-link" href="../../../about/">درباره</a></li><li class="nav-item"><a class="nav-link" href="../../../contact/">تماس</a></li></ul></div></div></nav><div class="container"><div class="row"><main class="col-md-10 order-md-last">
					<div class="ch" id="ch11"><h2 class="ch-title"><a class="bkmk" name="ch11"></a><a class="rtoc" href="c06-toc.xhtml"><span class="ch-title-num">۱۱</span><br/><span class="ch-title-text">آزمایش کد</span></a></h2><img style="float:right;margin-left:0.5em;margin-bottom:0.25em;" alt="تصویر ابتدای فصل" src="images/ch.svg"/>
<a id="p209"></a><p class="noindent">وقتی که یک تابع یا کلاس می‌نویسید، می‌توانید آزمایش‌هایی نیز برای آن بنویسید. با آزمایش کردن، ثابت می‌شود که کد شما در پاسخ به ورودی‌هایی که برای دریافت آن‌ها طراحی شده است، همان‌طوری عمل می‌کند که انتظار می‌رود. وقتی که تست می‌نویسید، می‌توانید مطمئن باشید که زمانی که افراد بیشتری شروع به استفاده از برنامه‌ی شما کنند، باز هم کد شما عملکرد درستی خواهد داشت. علاوه بر این، خواهید توانست کدهای جدیدی را هم که می‌نویسید، آزمایش کنید، تا مطمئن شوید که کد جدید، رفتار قبلی برنامه را خراب نمی‌کند. هر برنامه‌نویسی گاه اشتباه می‌کند، بنابراین، هر برنامه‌نویسی باید کد خود را مکرراً آزمایش کند، و مشکلات را قبل از آنکه برنامه به دست کاربران برسد، شناسایی و اصلاح کند.</p><p>در این فصل، یاد می‌گیرید که چگونه کد را با استفاده از ابزارهای موجود در مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">unittest</span><span class="rlm">‏</span> پایتون آزمایش کنید. خواهید توانست یک تست ایجاد کنید و وارسی کنید که ورودی‌های خاصی منجر به خروجی‌های مورد نظر می‌شود. خواهید دید که قبول یا رد شدن تست چگونه نشان داده می‌شود، و خواهید فهمید که تست ردی نیز می‌تواند به بهبود کد شما کمک کند. نحوه‌ی آزمایش کردن توابع و کلاس‌ها را یاد خواهید گرفت و متوجه خواهید شد که برای یک پروژه چند تست باید بنویسید.</p><div class="sect" id="ch11lev1sec1"><a class="bkmk" name="ch11lev1sec1"></a><h3>آزمایش کردن یک تابع</h3>
<a id="p210"></a><p class="noindent">برای اینکه آزمایش کردن را یاد بگیریم، لازم است که برنامه‌ای برای آزمایش داشته باشیم. در اینجا تابع ساده‌ای داریم که نام و نام خانوادگی را می‌گیرد و نام کامل فرمت‌شده را برمی‌گرداند:</p><div class="snippet"><div class="snippet-title" dir="ltr">name_function.py</div><pre class="snippet" dir="ltr">def get_formatted_name(first, last):
    """Generate a neatly formatted full name."""
    full_name = f"{first} {last}"
    return full_name.title()</pre></div><p>تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> بین نام و نام خانوادگی یک اسپیس می‌گذارد و حرف اول آن‌ها را تبدیل به حروف بزرگ می‌کند و این نام کامل را برمی‌گرداند. برای بررسی اینکه <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> درست کار می‌کند، برنامه‌ای می‌نویسیم که از این تابع استفاده می‌کند. برنامه‌ی <span class="rlm">‏</span><span class="ident" dir="ltr">names.py</span><span class="rlm">‏</span> نام و نام خانوادگی را از کاربر می‌گیرد، سپس نام کامل را نمایش می‌دهد:</p><div class="snippet"><div class="snippet-title" dir="ltr">names.py</div><pre class="snippet" dir="ltr">from name_function import get_formatted_name

print("Enter 'q' at any time to quit.")
while True:
    first = input("\nPlease give me a first name: ")
    if first == 'q':
        break
    last = input("Please give me a last name: ")
    if last == 'q':
        break

    formatted_name = get_formatted_name(first, last)
    print(f"\tNeatly formatted name: {formatted_name}.")</pre></div><p>این برنامه، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> را از <span class="rlm">‏</span><span class="ident" dir="ltr">name_function.py</span><span class="rlm">‏</span> ایمپورت می‌کند. کاربر می‌تواند یک سری نام و نام خانوادگی را وارد کند، و نام‌های کامل ایجاد شده را مشاهده کند:</p><div class="snippet"><pre class="snippet" dir="ltr">
Enter 'q' at any time to quit.

Please give me a first name: <span class="bo">janis</span>
Please give me a last name: <span class="bo">joplin</span>
        Neatly formatted name: Janis Joplin.

Please give me a first name: <span class="bo">bob</span>
Please give me a last name: <span class="bo">dylan</span>
        Neatly formatted name: Bob Dylan.

Please give me a first name: <span class="bo">q</span></pre></div><p>می‌بینیم که نام‌های ایجاد شده در اینجا صحیح هستند. ولی فرض کنید می‌خواهیم <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> را تغییر می‌دهیم تا نام میانی را هم در نظر بگیرد. در عین حال، می‌خواهیم مطمئن شویم که عملکرد تابع در مواردی که فقط نام و نام خانوادگی داده شده است، به هم نخورد. می‌توانیم هر بار که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> را تغییر می‌دهیم، برای آزمایش کردن کد، <span class="rlm">‏</span><span class="ident" dir="ltr">names.py</span><span class="rlm">‏</span> را اجرا کنیم و نامی مانند <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Janis Joplin</span><span class="rlm">‏</span> را به آن بدهیم، ولی این کار پرزحمت خواهد بود. خوشبختانه، <a id="p211"></a>پایتون روش کارآمدی برای خودکار کردن آزمایش خروجی یک تابع دارد. اگر آزمایش <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> را خودکار کنیم، همیشه می‌توانیم مطمئن باشیم که تابع برای نوع نام‌هایی که برای آن‌ها آزمایش نوشته‌ایم، درست کار خواهد کرد.</p><div class="sect" id="ch11lev2sec1"><a class="bkmk" name="ch11lev2sec1"></a><h4>آزمون‌های واحد و موردهای آزمایشی</h4>
<p class="noindent">مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">unittest</span><span class="rlm">‏</span> از کتابخانه‌ی استاندارد پایتون ابزارهایی را برای آزمایش کردن کد فراهم می‌کند. یک <span class="emphasis">آزمون واحد</span> (<span class="emphasis"><span class="rlm">‏</span><span class="lr" dir="ltr">unit test</span><span class="rlm">‏</span></span>) وارسی می‌کند که یک جنبه‌ی خاص رفتار یک تابع صحیح باشد. یک <span class="emphasis">مورد آزمایشی</span> (<span class="emphasis"><span class="rlm">‏</span><span class="lr" dir="ltr">test case</span><span class="rlm">‏</span></span>) مجموعه‌ای از آزمون‌های واحد است که بر روی هم ثابت می‌کنند که یک تابع در دامنه‌ی موقعیت‌هایی که مورد نظر شما است، همان‌گونه که انتظار می‌رود، رفتار می‌کند. در یک مورد آزمایشی خوب، باید تمام انواع مختلف ورودی که ممکن است تابع دریافت کند، در نظر گرفته شود، و آزمایش‌هایی برای هر کدام از این موقعیت‌ها داشته باشد. مورد آزمایشی با <span class="emphasis">پوشش کامل</span> زمانی است که دامنه‌ی کاملی از آزمون‌های واحد داشته باشد که تمام روش‌های ممکن استفاده از تابع را پوشش دهد. نیل به پوشش کامل در یک پروژه‌ی بزرگ ممکن است کار دشواری باشد. معمولاً کافی است که آزمون‌هایی برای رفتارهای بحرانی کد بنویسید، و سپس در صورتی که پروژه به‌تدریج مورد استفاده‌ی گسترده قرار گرفت، در جهت پوشش کامل حرکت کنید.</p></div><div class="sect" id="ch11lev2sec2"><a class="bkmk" name="ch11lev2sec2"></a><h4>قبول شدن آزمون</h4>
<p class="noindent">مدتی وقت لازم است تا به دستور نحوی مربوط به نوشتن موردهای آزمایشی عادت کنید، ولی وقتی که مورد آزمایشی را روبه‌راه کردید، به آسانی می‌توانید آزمون‌های واحد بیشتری برای توابعتان به آن اضافه کنید. برای اینکه یک مورد آزمایشی برای یک تابع بنویسید، مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">unittest</span><span class="rlm">‏</span> را به همراه تابعی که می‌خواهید آزمایش کنید، ایمپورت کنید. سپس کلاسی ایجاد کنید که از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">unittest.TestCase</span><span class="rlm">‏</span> مشتق می‌شود، و یک سری متد برای آزمایش کردن جنبه‌های مختلف رفتار تابع مورد نظر بنویسید.</p><p>در اینجا یک مورد آزمایشی می‌بینید که دارای یک متد است که بررسی می‌کند تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> وقتی که نام و نام خانوادگی به آن داده شود، درست کار می‌کند:</p><div class="snippet"><div class="snippet-title" dir="ltr">test_name_function.py</div><pre class="snippet" dir="ltr">import unittest
from name_function import get_formatted_name

<span class="n" dir="ltr">1</span>class NamesTestCase(unittest.TestCase):
    """Tests for 'name_function.py'."""

    def test_first_last_name(self):
        """Do names like 'Janis Joplin' work?"""
<span class="n" dir="ltr">2</span>        formatted_name = get_formatted_name('janis', 'joplin')
<span class="n" dir="ltr">3</span>        self.assertEqual(formatted_name, 'Janis Joplin')

<span class="n" dir="ltr">4</span>if __name__ == '__main__':
    unittest.main()</pre></div><p>ابتدا <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">unittest</span><span class="rlm">‏</span> و تابع مورد نظرمان یعنی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> را ایمپورت می‌کنیم. در <span class="n" dir="ltr">1</span>، کلاسی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">NamesTestCase</span><span class="rlm">‏</span> ایجاد می‌کنیم، که حاوی یک سری آزمون واحد برای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> خواهد بود. نام کلاس را هر چیزی خواستید، می‌توانید بگذارید، ولی بهتر است که نام آن در ارتباط با تابعی باشد که می‌خواهید آزمایش کنید، و بهتر است کلمه‌ی <span class="emphasis"><span class="rlm">‏</span><span class="lr" dir="ltr">Test</span><span class="rlm">‏</span></span> در نام آن وجود داشته باشد. این کلاس باید از کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">unittest.TestCase</span><span class="rlm">‏</span> ارث ببرد، تا پایتون بداند که تست‌هایی را که می‌نویسید، چگونه اجرا کند.</p><a id="p212"></a><p>کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">NamesTestCase</span><span class="rlm">‏</span> حاوی یک متد است که یک جنبه از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> را آزمایش می‌کند. نام این متد را <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">test_first_last_name()</span><span class="rlm">‏</span> گذاشته‌ایم، زیرا می‌خواهیم بررسی کنیم که وقتی فقط نام و نام خانوادگی داده شود، تابع درست فرمت می‌کند. وقتی که فایل <span class="emphasis">test_name_function.py</span> را اجرا کنیم، هر متدی که با <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">test_</span><span class="rlm">‏</span> شروع شود، به‌طور خودکار اجرا خواهد شد. در داخل این متد تست، تابعی را که می‌خواهیم آزمایش کنیم، فراخوانی می‌کنیم. در این مثال، تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> را با آرگومان‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">'janis'</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">'joplin'</span><span class="rlm">‏</span> فراخوانی می‌کنیم، و نتیجه‌ی آن را به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">formatted_name</span><span class="rlm">‏</span> اختصاص می‌دهیم <span class="n" dir="ltr">2</span>.</p><p>در <span class="n" dir="ltr">3</span>، از یکی از مفیدترین ویژگی‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">unittest</span><span class="rlm">‏</span> استفاده می‌کنیم: یکی از متدهای <span class="emphasis"><span class="rlm">‏</span><span class="lr" dir="ltr">assert</span><span class="rlm">‏</span></span>. متدهای <span class="rlm">‏</span><span class="lr" dir="ltr">assert</span><span class="rlm">‏</span> تحقیق می‌کنند که نتیجه‌ای که به دست آورده‌اید، با نتیجه‌ای که انتظار آن را داشته‌اید، مطابقت دارد. در این مورد، از آنجا که می‌دانیم که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> باید نام کامل را با فرمت صحیح از نظر حروف کوچک و بزرگ و اضافه کردن اسپیس برگرداند، لذا انتظار داریم که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">formatted_name</span><span class="rlm">‏</span> مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Janis Joplin</span><span class="rlm">‏</span> داشته باشد. برای وارسی اینکه این موضوع صحت دارد یا نه، از متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">assertEqual()</span><span class="rlm">‏</span> در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">unittest</span><span class="rlm">‏</span> استفاده می‌کنیم و به آن آرگومان‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">formatted_name</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">'Janis Joplin'</span><span class="rlm">‏</span> می‌دهیم. سطر زیر:</p><div class="snippet"><pre class="snippet" dir="ltr">self.assertEqual(formatted_name, 'Janis Joplin')</pre></div><p>می‌گوید که «مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">formatted_name</span><span class="rlm">‏</span> را با رشته‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">'Janis Joplin'</span><span class="rlm">‏</span> مقایسه کن. اگر همان طور که انتظار می‌رود، با هم برابر هستند، که هیچ. ولی اگر با هم انطباق ندارند، به من خبر بده!»</p><p>ما می‌خواهیم این فایل را به‌طور مستقیم اجرا کنیم، ولی باید در نظر داشت که بسیاری از فریم‌ورک‌های تست، فایل‌های تست شما را قبل از اجرای آن‌ها ایمپورت می‌کنند. وقتی که فایلی ایمپورت می‌شود، تفسیرگر پایتون آن فایل را اجرا می‌کند. بلوک <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">if</span><span class="rlm">‏</span> در <span class="n" dir="ltr">4</span> متغیر ویژه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__name__</span><span class="rlm">‏</span> را وارسی می‌کند، که متغیری است که هنگام اجرای برنامه، مقدار داده می‌شود. اگر این فایل به‌عنوان برنامه‌ی اصلی در حال اجرا باشد، به متغیر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__name__</span><span class="rlm">‏</span>، مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">'__main__'</span><span class="rlm">‏</span> داده می‌شود. در این حالت، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">unittest.main()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم، که مورد آزمایشی را اجرا می‌کند. وقتی که فریم‌ورک تست این فایل را ایمپورت می‌کند، مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__name__</span><span class="rlm">‏</span> برابر با <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">'__main__'</span><span class="rlm">‏</span> نخواهد بود، و لذا این بلوک کد اجرا نخواهد شد.</p><p>وقتی که <span class="rlm">‏</span><span class="ident" dir="ltr">test_name_function.py</span><span class="rlm">‏</span> را اجرا می‌کنیم، خروجی زیر را دریافت می‌کنیم:</p><div class="snippet"><pre class="snippet" dir="ltr">.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK</pre></div><p>نقطه در سطر اول خروجی نشان‌دهنده‌ی آن است که فقط یک آزمون قبول شده است. سطر بعدی بیان می‌کند که پایتون یک آزمون را اجرا کرده است، و اجرای آن کمتر از ۰٫۰۰۱ ثانیه وقت برده است. و نهایتاً، عبارت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">OK</span><span class="rlm">‏</span> نشان می‌دهد که تمام آزمون‌های واحد در این مورد آزمایشی قبول شده‌اند.</p><p>این خروجی نشان می‌دهد که تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> فعلاً برای تمام مواردی که نام و نام خانوادگی به آن داده شود، درست کار می‌کند، مگر آنکه تابع را تغییر دهیم. زمانی که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> را تغییر می‌دهیم، می‌توانیم این تست را دوباره اجرا کنیم. اگر مورد آزمایشی موفق بود، خواهیم دانست که تابع هنوز هم برای اسم‌هایی مانند <span class="rlm">‏</span><span class="lr" dir="ltr">Janis Joplin</span><span class="rlm">‏</span> درست کار می‌کند.</p></div><div class="sect" id="ch11lev2sec3"><a class="bkmk" name="ch11lev2sec3"></a><h4>رد شدن آزمون</h4>
<p class="noindent">رد شدن آزمون چگونه است؟ تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> را تغییر می‌دهیم تا نام میانی را هم در نظر بگیرد، ولی این کار را طوری انجام می‌دهیم که تابع برای مواردی که فقط نام و نام خانوادگی به آن داده شده است، مانند <span class="rlm">‏</span><span class="lr" dir="ltr">Janis Joplin</span><span class="rlm">‏</span> دچار مشکل شود.</p><a id="p213"></a><p>در اینجا نسخه‌ی جدید <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> را می‌بینید که نیاز به آرگومان نام میانی نیز دارد:</p><div class="snippet"><div class="snippet-title" dir="ltr">name_function.py</div><pre class="snippet" dir="ltr">def get_formatted_name(first, middle, last):
    <span class="ash">"""Generate a neatly formatted full name."""</span>
    full_name = f"{first} {middle} {last}"
    <span class="ash">return full_name.title()</span></pre></div><p>این نسخه از تابع برای افرادی که نام میانی دارند، قابل استفاده خواهد بود، ولی وقتی که آن را آزمایش می‌کنیم، می‌بینیم که برای مواردی که فغقط نام و نام خانوادگی داده شده است، دچار مشکل می‌شود. این بار، با اجرا کردن فایل <span class="rlm">‏</span><span class="lr" dir="ltr">test_name_function.py</span><span class="rlm">‏</span>، خروجی زیر را دریافت می‌کنیم:</p><div class="snippet"><pre class="snippet" dir="ltr"><span class="n" dir="ltr">1</span>E
======================================================================
<span class="n" dir="ltr">2</span>ERROR: test_first_last_name (__main__.NamesTestCase)
----------------------------------------------------------------------
<span class="n" dir="ltr">3</span>Traceback (most recent call last):
  File "test_name_function.py", line 8, in test_first_last_name
    formatted_name = get_formatted_name('janis', 'joplin')
TypeError: get_formatted_name() missing 1 required positional argument: 'last'

----------------------------------------------------------------------
<span class="n" dir="ltr">4</span>Ran 1 test in 0.000s

<span class="n" dir="ltr">5</span>FAILED (errors=1)</pre></div><p>در اینجا اطلاعات زیادی داده شده است، چرا که وقتی یک آزمون رد می‌شود، چیزهای زیادی را باید بدانید. نخستین موردی که در خروجی داده شده است، یک حرف <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">E</span><span class="rlm">‏</span> است <span class="n" dir="ltr">1</span>، که نشان‌دهنده‌ی آن است که یک آزمون واحد در مورد آزمایشی منجر به خطا شده است. بعد، می‌بینیم که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">test_first_last_name()</span><span class="rlm">‏</span> در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">NamesTestCase</span><span class="rlm">‏</span> موجب بروز خطا شده است <span class="n" dir="ltr">2</span>. در موردی که مورد آزمایشی شامل آزمون‌های واحد متعدد است، خیلی مهم است که بدانیم کدام آزمون رد شده است. در <span class="n" dir="ltr">3</span>، خروجی استاندارد رهگیری خطا را می‌بینیم، که که
ارزش می‌کند که فراخوانی تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name('janis', 'joplin')</span><span class="rlm">‏</span> دیگر درست کار نمی‌کند، چرا که آرگومان موقعیتی لازم به آن داده نشده است.</p><p>هم‌چنین، می‌بینیم که یک آزمون واحد اجرا شده است <span class="n" dir="ltr">4</span>. و بالاخره، پیام دیگری نیز می‌بینیم که نشان می‌دهد که مورد آزمایشی کلاً رد شده است، و هنگام اجرای مورد آزمایشی، یک خطا بروز کرده است <span class="n" dir="ltr">5</span>. این اطلاعات در پایان خروجی ظاهر شده است، بنابراین، فوراً آن را مشاهده می‌کنید؛ نیازی نیست که لیست طولانی خروجی را به طرف بالا اسکرول کنید تا ببینید چند آزمون با شکست مواجه شده است.</p></div><div class="sect" id="ch11lev2sec4"><a class="bkmk" name="ch11lev2sec4"></a><h4>چگونگی پاسخ به رد شدن یک آزمون</h4>
<p class="noindent">زمانی که یک آزمون رد می‌شود، چه می‌کنید؟ به فرض اینکه شما شرط‌های درستی را وارسی کرده باشید، قبول شدن آزمون به معنای آن است که تابع درست عمل می‌کند، و رد شدن آزمون بدان معنا است که خطایی در کد جدیدی که نوشته‌اید، وجود دارد. بنابراین، وقتی که آزمون رد می‌شود، نباید آزمون را تغییر دهید. بلکه باید کدی را که باعث رد شدن آزمون شده است، اصلاح کنید. تغییراتی را که در تابع داده‌اید، بررسی کنید، و ببینید که این تغییرات از چه رو موجب به هم خوردن رفتار مطلوب شده است.</p><p>در اینجا، تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> ابتدا دو پارامتر می‌گرفت: نام و نام خانوادگی. حالا نیاز به نام، نام میانی، و <a id="p214"></a>نام خانوادگی دارد. اضافه شدن این پارامتر اجباری نام میانی موجب به هم خوردن رفتار مطلوب <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> شده است. بهترین گزینه آن است که نام میانی اختیاری باشد. وقتی که این کار انجام شود، آزمون ما برای نام‌هایی مانند <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Janis Joplin</span><span class="rlm">‏</span> دوباره قبول خواهد شد، و خواهیم توانست نام میانی را هم در نظر بگیریم. پس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> را به‌گونه‌ای تغییر می‌دهیم که نام میانی اختیاری باشد، و بعد مورد آزمایشی را دوباره اجرا می‌کنیم. اگر قبول شود، در ادامه تلاش خواهیم کرد کاری کنیم که تابع نام میانی را هم به درستی فرمت کند.</p><p>برای اینکه نام میانی اختیاری باشد، پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">middle</span><span class="rlm">‏</span> را در تعریف تابع به آخر لیست پارامترها منتقل می‌کنیم و یک مقدار پیش‌فرض به آن می‌دهیم. هم‌چنین، یک دستورالعمل <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">if</span><span class="rlm">‏</span> اضافه می‌کنیم که بسته به اینکه نام میانی داده شده باشد یا نه، نام کامل را به درستی ایجاد می‌کند:</p><div class="snippet"><div class="snippet-title" dir="ltr">name_function.py</div><pre class="snippet" dir="ltr">def get_formatted_name(first, last, middle=''):
    <span class="ash">"""Generate a neatly formatted full name."""</span>
    if middle:
        full_name = f"{first} {middle} {last}"
    else:
        full_name = f"{first} {last}"
    <span class="ash">return full_name.title()</span></pre></div><p>در این نسخه‌ی جدید <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span>، نام میانی اختیاری است. اگر نام میانی به تابع داده شده باشد، نام کامل حاوی نام، نام میانی، و نام خانوادگی خواهد بود. در غیر این صورت، نام کامل فقط متشکل از نام و نام خانوادگی خواهد بود. حالا انتظار می‌رود که تابع برای هر دو نوع ورودی درست کار کند. برای اینکه ببینیم آیا تابع هنوز هم برای نام‌هایی مانند <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Janis Joplin</span><span class="rlm">‏</span> درست کار می‌کند، <span class="rlm">‏</span><span class="ident" dir="ltr">test_name_function.py</span><span class="rlm">‏</span> را دوباره اجرا می‌کنیم:</p><div class="snippet"><pre class="snippet" dir="ltr">.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK</pre></div><p>حالا مورد آزمایشی قبول می‌شود. این خیلی خوب است؛ نشان می‌دهد که تابع دوباره برای نام‌هایی مانند <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Janis Joplin</span><span class="rlm">‏</span> درست کار می‌کند، بدون آنکه لازم باشد که تابع را به‌طور دستی امتحان کنیم. اصلاح کردن این تابع کار آسانی بود، چرا که رد شدن آزمون به ما کمک کرد که مشخص کنیم که کد جدید موجب خراب شدن رفتار موجود شده است.</p></div><div class="sect" id="ch11lev2sec5"><a class="bkmk" name="ch11lev2sec5"></a><h4>اضافه کردن آزمون‌های جدید</h4>
<p class="noindent">اکنون که می‌دانیم که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> دوباره برای نام‌های ساده درست کار می‌کند، آزمون دیگری می‌نویسیم برای افرادی که نام میانی هم دارند. برای این منظور، متد دیگری به کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">NamesTestCase</span><span class="rlm">‏</span> اضافه می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">test_name_function.py</div><pre class="snippet" dir="ltr"><span class="ash">--<span class="it">snip</span>--</span>

<span class="ash">class NamesTestCase(unittest.TestCase):</span>
    <span class="ash">"""Tests for 'name_function.py'."""</span>

    <span class="ash">def test_first_last_name(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>

<a id="p215"></a>    def test_first_last_middle_name(self):
        """Do names like 'Wolfgang Amadeus Mozart' work?"""
<span class="n" dir="ltr">1</span>        formatted_name = get_formatted_name(
            'wolfgang', 'mozart', 'amadeus')
        self.assertEqual(formatted_name, 'Wolfgang Amadeus Mozart')

<span class="ash">if __name__ == '__main__':</span>
    <span class="ash">unittest.main()</span></pre></div><p>نام این متد جدید را <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">test_first_last_middle_name()</span><span class="rlm">‏</span> می‌گذاریم. نام متد باید با <span class="emphasis">test_</span> شروع شود، تا اینکه زمانی که <span class="rlm">‏</span><span class="ident" dir="ltr">test_name_function.py</span><span class="rlm">‏</span> را اجرا می‌کنیم، به‌طور خودکار اجرا شود. متد را به‌گونه‌ای نام‌گذاری می‌کنیم که معلوم باشد که کدام رفتار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> را می‌خواهیم آزمایش کنیم. در نتیجه، اگر آزمون رد شود، فوراً می‌فهمیم که چه نوع نام‌هایی دچار مشکل شده‌اند. اشکالی ندارد که در کلاس‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">TestCase</span><span class="rlm">‏</span> شما، نام متدها طولانی باشد. مهم این است که نام متدها گویا باشد، تا اگر آزمون‌ها رد شدند، بتوانید مفهوم خروجی را درک کنید، و با توجه به اینکه پایتون این متدها را به‌صورت خودکار فراخوانی می‌کند، لذا هرگز نیازی نخواهد بود که شما خودتان این متدها را فراخوانی کنید.</p><p>برای این آزمایش، تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_formatted_name()</span><span class="rlm">‏</span> را با نام، نام میانی، و نام خانوادگی فراخوانی می‌کنیم <span class="n" dir="ltr">1</span>، و سپس با استفاده از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">assertEqual()</span><span class="rlm">‏</span>، وارسی می‌کنیم که نام کامل بازگردانده شده، با نام کامل مورد انتظار ما (شامل نام، نام میانی، و نام خانوادگی) مطابقت دارد. وقتی که دوباره را اجرا کنیم، هر دو آزمون قبول می‌شوند:</p><div class="snippet"><pre class="snippet" dir="ltr">..
----------------------------------------------------------------------
Ran 2 tests in 0.000s

OK</pre></div><p>عالی است! اکنون می‌دانیم که تابع برای نام‌هایی مانند <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Janis Joplin</span><span class="rlm">‏</span> همچنان کار می‌کند، و از طرف دیگر، می‌توانیم مطمئن باشیم که برای نام‌هایی مانند <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Wolfgang Amadeus Mozart</span><span class="rlm">‏</span> نیز کار خواهد کرد.</p><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<p class="tiy1"><span class="tiy" id="ch11_tiy01"><span class="tiy-num">۱۱-۱</span>. <span class="tiy-title">شهر، کشور</span>: </span> تابعی بنویسید که دو پارامتر می‌گیرد: نام یک شهر و نام یک کشور. این تابع یک رشته به‌صورت <span class="it">City, Country</span> برگرداند، مثلاً <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Santiago, Chile</span><span class="rlm">‏</span>. تابع را در مدولی به نام <span class="rlm">‏</span><span class="ident" dir="ltr">city_functions.py</span><span class="rlm">‏</span> ذخیره کنید.</p><p>فایلی به نام <span class="rlm">‏</span><span class="ident" dir="ltr">test_cities.py</span><span class="rlm">‏</span> ایجاد کنید که تابع فوق را آزمایش می‌کند (دقت کنید که باید <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">unittest</span><span class="rlm">‏</span> و تابع مذکور را ایمپورت کنید). متدی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">test_city_country()</span><span class="rlm">‏</span> بنویسید و تحقیق کنید که وقتی تابع شما با مقادیری همچون <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">'santiago'</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">'chile'</span><span class="rlm">‏</span> فراخوانی می‌شود، رشته‌ی صحیح حاصل می‌شود. <span class="rlm">‏</span><span class="ident" dir="ltr">test_cities.py</span><span class="rlm">‏</span> را اجرا کنید، و اطمینان حاصل کنید که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">test_city_country()</span><span class="rlm">‏</span> قبول می‌شود.</p><a id="p216"></a><p class="tiy1"><span class="tiy" id="ch11_tiy02"><span class="tiy-num">۱۱-۲</span>. <span class="tiy-title">جمعیت</span>: </span> تابع فوق را به‌گونه‌ای تغییر دهید که نیاز به پارامتر سومی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">population</span><span class="rlm">‏</span> داشته باشد. حالا این تابع رشته‌ای به‌صورت <span class="it">City, Country – population xxx</span> برگرداند، مثلاً <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Santiago, Chile – population 5000000</span><span class="rlm">‏</span>. دوباره <span class="rlm">‏</span><span class="ident" dir="ltr">test_cities.py</span><span class="rlm">‏</span> را اجرا کنید. مطمئن شوید که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">test_city_country()</span><span class="rlm">‏</span> این بار رد می‌شود.</p><p>تابع را طوری تغییر دهید که پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">population</span><span class="rlm">‏</span> اختیاری باشد. دوباره <span class="rlm">‏</span><span class="ident" dir="ltr">test_cities.py</span><span class="rlm">‏</span> را اجرا کنید و مطمئن شوید که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">test_city_country()</span><span class="rlm">‏</span> دوباره قبول می‌شود.</p><p>تست دیگری به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">test_city_country_population()</span><span class="rlm">‏</span> بنویسید که فراخوانی تابع با مقادیر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">'santiago'</span><span class="rlm">‏</span>، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">'chile'</span><span class="rlm">‏</span>، و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">'population=5000000'</span><span class="rlm">‏</span> را بررسی می‌کند. دوباره <span class="rlm">‏</span><span class="ident" dir="ltr">test_cities.py</span><span class="rlm">‏</span> را اجرا کنید، و دقت کنید که آزمون جدید هم قبول شود.</p></div></div></div><div class="sect" id="ch11lev1sec2"><a class="bkmk" name="ch11lev1sec2"></a><h3>آزمایش کردن یک کلاس</h3>
<p class="noindent">در بخش اول این فصل، آزمون‌هایی برای یک تابع نوشتید. حالا می‌خواهید آزمایش‌هایی برای یک کلاس بنویسید. شما از کلاس در برنامه‌هایتان زیاد استفاده خواهید کرد، بنابراین، بد نیست بتوانید ثابت کنید که کلاس‌هایتان درست کار می‌کنند. اگر برای کلاسی که روی آن کار می‌کنید، آزمون‌های قبول شده‌ای داشته باشید، می‌توانید مطمئن باشید که بهبودهایی که در آن کلاس ایجاد کنید، باعث خراب شدن رفتار فعلی آن نخواهد شد.</p><div class="sect" id="ch11lev2sec6"><a class="bkmk" name="ch11lev2sec6"></a><h4>انواع مختلف متدهای <span class="rlm">‏</span><span class="lr" dir="ltr">assert</span><span class="rlm">‏</span></h4>
<p class="noindent">پایتون چندین متد مختلف <span class="rlm">‏</span><span class="lr" dir="ltr">assert</span><span class="rlm">‏</span> در کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">unittest.TestCase</span><span class="rlm">‏</span> دارد. همان گونه که قبلاً گفته شد، متدهای <span class="rlm">‏</span><span class="lr" dir="ltr">assert</span><span class="rlm">‏</span> وارسی می‌کنند که شرطی که فکر می‌کنید در نقطه‌ی خاصی از کد شما باید صحیح باشد، واقعاً صحیح هست یا نه. اگر همان طور که انتظار دارید، شرط مورد نظر صحیح باشد، فرض شما درباره‌ی رفتار آن بخش از برنامه تأیید می‌شود؛ می‌توانید مطمئن باشید که خطایی وجود ندارد. اما اگر شرطی که به گمان شما باید برقرار باشد، صحیح نباشد، پایتون یک خطا ایجاد می‌کند.</p><p><refTab xmlns="urn:dox:pycc">۱۱-۱</refTab> شش متد پراستفاده‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">assert</span><span class="rlm">‏</span> را نشان می‌دهد. با استفاده از این متدها می‌توانید تحقیق کنید که مقادیر برگشتی با مقادیر مورد انتظار برابرند یا اینکه برابر نیستند، مقادیر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">True</span><span class="rlm">‏</span> یا <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">False</span><span class="rlm">‏</span> هستند، و اینکه در یک لیست داده شده هستند (<span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">in</span><span class="rlm">‏</span>) یا اینکه نیستند (<span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">not in</span><span class="rlm">‏</span>). از این متدها فقط در کلاسی که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">unittest.TestCase</span><span class="rlm">‏</span> مشتق شده باشد، می‌توان استفاده کرد. بر این اساس، نگاه ببینیم چگونه می‌توانیم از یکی از این متدها برای تست کردن یک کلاس واقعی استفاده کنیم.</p><p><span class="strong">جدول ۱۱-۱:</span> متدهای <span class="rlm">‏</span><span class="lr" dir="ltr">assert</span><span class="rlm">‏</span> موجود در مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">unittest</span><span class="rlm">‏</span></p><table xmlns="urn:dox:pycc">
<tr>
<td style="vertical-align: top;" class="table-h">
<p xmlns="http://www.w3.org/1999/xhtml"><span class="strong">متد</span></p></td><td style="vertical-align: top;" class="table-h">
<p xmlns="http://www.w3.org/1999/xhtml"><span class="strong">کاربرد</span></p></td></tr><tr>
<td style="vertical-align: top;" class="table-b">
<p xmlns="http://www.w3.org/1999/xhtml"><span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">assertEqual(a, b)</span><span class="rlm">‏</span></p></td><td style="vertical-align: top;" class="table-b">
<p xmlns="http://www.w3.org/1999/xhtml">بررسی اینکه <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">a == b</span><span class="rlm">‏</span></p></td></tr><tr>
<td style="vertical-align: top;" class="table-b">
<p xmlns="http://www.w3.org/1999/xhtml"><span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">assertNotEqual(a, b)</span><span class="rlm">‏</span></p></td><td style="vertical-align: top;" class="table-b">
<p xmlns="http://www.w3.org/1999/xhtml">بررسی اینکه <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">a != b</span><span class="rlm">‏</span></p></td></tr><tr>
<td style="vertical-align: top;" class="table-b">
<p xmlns="http://www.w3.org/1999/xhtml"><span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">assertTrue(x)</span><span class="rlm">‏</span></p></td><td style="vertical-align: top;" class="table-b">
<p xmlns="http://www.w3.org/1999/xhtml">بررسی اینکه <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">x</span><span class="rlm">‏</span>، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">True</span><span class="rlm">‏</span> است</p></td></tr><tr>
<td style="vertical-align: top;" class="table-b">
<p xmlns="http://www.w3.org/1999/xhtml"><span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">assertFalse(x)</span><span class="rlm">‏</span></p></td><td style="vertical-align: top;" class="table-b">
<p xmlns="http://www.w3.org/1999/xhtml">بررسی اینکه <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">x</span><span class="rlm">‏</span>، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">False</span><span class="rlm">‏</span> است</p></td></tr><tr>
<td style="vertical-align: top;" class="table-b">
<p xmlns="http://www.w3.org/1999/xhtml"><span class="rlm">‏</span><span class="lr" dir="ltr"><span class="literal">assertIn(</span><span class="it">item, list</span><span class="literal">)</span></span><span class="rlm">‏</span></p></td><td style="vertical-align: top;" class="table-b">
<p xmlns="http://www.w3.org/1999/xhtml">بررسی اینکه <span class="it">item</span> در <span class="it">list</span> است</p></td></tr><tr>
<td style="vertical-align: top;" class="table-ba">
<p xmlns="http://www.w3.org/1999/xhtml"><span class="rlm">‏</span><span class="lr" dir="ltr"><span class="literal">assertNotIn(</span><span class="it">item, list</span><span class="literal">)</span></span><span class="rlm">‏</span></p></td><td style="vertical-align: top;" class="table-ba">
<p xmlns="http://www.w3.org/1999/xhtml">بررسی اینکه <span class="it">item</span> در <span class="it">list</span> نیست</p></td></tr></table></div><div class="sect" id="ch11lev2sec7"><a class="bkmk" name="ch11lev2sec7"></a><h4>کلاسی برای آزمایش</h4>
<a id="p217"></a><p class="noindent">آزمایش کردن کلاس مانند آزمایش کردن تابع است—اکثر کاری که می‌کنید، در ارتباط با آزمایش کردن رفتار متدهای کلاس است. ولی تفاوت‌های چندی هست، ازاین‌رو، در اینجا کلاسی برای آزمایش کردن می‌نویسیم. کلاسی را در نظر بگیرید که امکان انجام نظرسنجی‌های ناشناس را فراهم می‌کند:</p><div class="snippet"><div class="snippet-title" dir="ltr">survey.py</div><pre class="snippet" dir="ltr">class AnonymousSurvey:
    """Collect anonymous answers to a survey question."""

<span class="n" dir="ltr">1</span>    def __init__(self, question):
        """Store a question, and prepare to store responses."""
        self.question = question
        self.responses = []

<span class="n" dir="ltr">2</span>    def show_question(self):
        """Show the survey question."""
        print(self.question)

<span class="n" dir="ltr">3</span>    def store_response(self, new_response):
        """Store a single response to the survey."""
        self.responses.append(new_response)

<span class="n" dir="ltr">4</span>    def show_results(self):
        """Show all the responses that have been given."""
        print("Survey results:")
        for response in self.responses:
            print(f"- {response}")</pre></div><p>این کلاس با سؤال نظرسنجی که شما طرح کرده‌اید، شروع می‌شود <span class="n" dir="ltr">1</span>، و شامل یک لیست خالی برای قرار دادن پاسخ‌ها است. این کلاس متدهایی برای نمایش دادن پرسش نظرسنجی <span class="n" dir="ltr">2</span>، افزودن یک پاسخ به لیست پاسخ‌ها <span class="n" dir="ltr">3</span>، و نمایش دادن تمام پاسخ‌های ذخیره شده در لیست <span class="n" dir="ltr">4</span> است. برای ایجاد یک نمونه از این کلاس، تنها کاری که باید بکنید، این است که یک پرسش به آن بدهید. وقتی که یک نمونه ایجاد کردید که معرف یک نظرسنجی خاص است، پرسش نظرسنجی را با استفاده از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">show_question()</span><span class="rlm">‏</span> نمایش می‌دهید، پاسخ را با استفاده از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">store_response()</span><span class="rlm">‏</span> ذخیره می‌کنید، و نتایج را با استفاده از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">show_results()</span><span class="rlm">‏</span> نمایش می‌دهید.</p><p>برای نشان دادن اینکه کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AnonymousSurvey</span><span class="rlm">‏</span> درست عمل می‌کند، برنامه‌ای با استفاده از این کلاس می‌نویسیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">language_survey.py</div><pre class="snippet" dir="ltr">from survey import AnonymousSurvey

# Define a question, and make a survey.
question = "What language did you first learn to speak?"
my_survey = AnonymousSurvey(question)

# Show the question, and store responses to the question.
my_survey.show_question()
print("Enter 'q' at any time to quit.\n")
while True:
    response = input("Language: ")
    if response == 'q':
        break
    my_survey.store_response(response)

<a id="p218"></a># Show the survey results.
print("\nThank you to everyone who participated in the survey!")
my_survey.show_results()</pre></div><p>این برنامه پرسشی را تعریف می‌کند (<span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">"What language did you first learn to speak?"</span><span class="rlm">‏</span>)، و با آن پرسش، یک <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AnonymousSurvey</span><span class="rlm">‏</span> ایجاد می‌نماید. برنامه با فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">show_question()</span><span class="rlm">‏</span>، پرسش را نمایش می‌دهد، و درخواست پاسخ می‌کند. با دریافت هر پاسخ، آن را ذخیره می‌کند. وقتی که همه‌ی پاسخ‌ها وارد شد (یعنی کاربر برای خروج، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">q</span><span class="rlm">‏</span> وارد کرد)، متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">show_results()</span><span class="rlm">‏</span> نتایج نظرسنجی را نمایش می‌دهد:</p><div class="snippet"><pre class="snippet" dir="ltr">What language did you first learn to speak?
Enter 'q' at any time to quit.

Language: <span class="bo">English</span>
Language: <span class="bo">Spanish</span>
Language: <span class="bo">English</span>
Language: <span class="bo">Mandarin</span>
Language: <span class="bo">q</span>

Thank you to everyone who participated in the survey!
Survey results:
- English
- Spanish
- English
- Mandarin</pre></div><p>این کلاس برای یک نظرسنجی ساده‌ی بدون درج نام قابل استفاده است. ولی فرض کنید می‌خواهیم کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AnonymousSurvey</span><span class="rlm">‏</span> و مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">survey</span><span class="rlm">‏</span> را که این کلاس در آن قرار گرفته است، بهتر کنیم. می‌توانیم اجازه بدهیم که هر کاربر بیشتر از یک پاسخ وارد کند. می‌توانیم متدی بنویسیم که فقط پاسخ‌های یکتا را نمایش می‌دهد و مشخص می‌کند که هر پاسخ چند بار وارد شده است. می‌توانیم کلاس دیگری نیز برای مدیریت نظرسنجی‌های بدون نام بنویسیم.</p><p>این خطر وجود دارد که پیاده‌سازی این تغییرات بر رفتار کنونی کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AnonymousSurvey</span><span class="rlm">‏</span> تأثیر بگذارد. به‌عنوان مثال، امکان دارد که وقتی بخواهیم کاری کنیم که هر کاربر بتواند چندین پاسخ وارد کند، به‌طور تصادفی نحوه‌ی رسیدگی به پاسخ‌های منفرد را تغییر دهیم. برای اطمینان از اینکه در حین توسعه‌ی مدول، رفتار کنونی آن به هم نمی‌خورد، می‌توانیم آزمون‌هایی برای این کلاس بنویسیم.</p></div><div class="sect" id="ch11lev2sec8"><a class="bkmk" name="ch11lev2sec8"></a><h4>آزمایش کردن کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AnonymousSurvey</span><span class="rlm">‏</span></h4>
<p class="noindent">در اینجا آزمونی می‌نویسیم که یک جنبه از رفتار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AnonymousSurvey</span><span class="rlm">‏</span> را بررسی می‌کند. این آزمون بررسی می‌کند که یک پاسخ منفرد پرسش نظرسنجی، درست ذخیره شده است. از متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">assertIn()</span><span class="rlm">‏</span> استفاده می‌کنیم، تا بررسی کنیم که پاس مورد نظر در لیست پاسخ‌های ذخیره شده وجود دارد:</p><div class="snippet"><div class="snippet-title" dir="ltr">test_survey.py</div><pre class="snippet" dir="ltr">import unittest
from survey import AnonymousSurvey

<span class="n" dir="ltr">1</span>class TestAnonymousSurvey(unittest.TestCase):
    """Tests for the class AnonymousSurvey"""
<a id="p219"></a><span class="n" dir="ltr">2</span>    def test_store_single_response(self):
        """Test that a single response is stored properly."""
        question = "What language did you first learn to speak?"
<span class="n" dir="ltr">3</span>        my_survey = AnonymousSurvey(question)
        my_survey.store_response('English')
<span class="n" dir="ltr">4</span>        self.assertIn('English', my_survey.responses)

if __name__ == '__main__':
    unittest.main()</pre></div><p>در ابتدا، مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">unittest</span><span class="rlm">‏</span> و کلاس مورد نظر یعنی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AnonymousSurvey</span><span class="rlm">‏</span>، را ایمپورت می‌کنیم. نام این مورد آزمایشی را <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">TestAnonymousSurvey</span><span class="rlm">‏</span> می‌گذاریم، که باز از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">unittest.TestCase</span><span class="rlm">‏</span> ارث می‌برد <span class="n" dir="ltr">1</span>. اولین متد تست بررسی می‌کند که وقتی پاسخ پرسش نظرسنجی را ذخیره می‌کنیم، پاسخ نهایتاً در لیست پاسخ‌های نظرسنجی قرار می‌گیرد. نام گویا و مناسب این متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">test_store_single_response()</span><span class="rlm">‏</span> است <span class="n" dir="ltr">2</span>. اگر این آزمون رد شود، از روی نام متد که در خروجی آزمون رد شده نمایش داده می‌شود، خواهیم فهمید که مشکل در ذخیره کردن یک پاسخ منفرد به نظرسنجی بوده است.</p><p>برای آزمایش کردن رفتار کلاس، لازم است که نمونه‌ای از کلاس بسازیم. در <span class="n" dir="ltr">3</span>، نمونه‌ای از کلاس به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">my_survey</span><span class="rlm">‏</span> با پرسش <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">"What language did you first learn to speak?"</span><span class="rlm">‏</span> ایجاد می‌کنیم. یک پاسخ را، که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">English</span><span class="rlm">‏</span>  است، با استفاده از متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">store_response()</span><span class="rlm">‏</span> ذخیره می‌کنیم. سپس با بررسی اینکه <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">English</span><span class="rlm">‏</span> در لیست <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">my_survey.responses</span><span class="rlm">‏</span> وجود دارد، تأیید می‌کنیم که پاسخ به درستی ذخیره شده است <span class="n" dir="ltr">4</span>.</p><p>وقتی که <span class="rlm">‏</span><span class="ident" dir="ltr">test_survey.py</span><span class="rlm">‏</span> را اجرا می‌کنیم، آزمون قبول می‌شود:</p><div class="snippet"><pre class="snippet" dir="ltr">.
----------------------------------------------------------------------
Ran 1 test in 0.001s

OK</pre></div><p>این خیلی خوب است، ولی یک نظرسنجی وقتی مفید است که بیش از یک پاسخ ایجاد کند. در اینجا بررسی می‌کنیم که این کلاس می‌تواند سه پاسخ را به درستی ذخیره کند. برای انجام این کار، متد دیگری به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">TestAnonymousSurvey</span><span class="rlm">‏</span> اضافه می‌کنیم:</p><div class="snippet"><pre class="snippet" dir="ltr"><span class="ash">import unittest</span>
<span class="ash">from survey import AnonymousSurvey</span>

<span class="ash">class TestAnonymousSurvey(unittest.TestCase):</span>
    <span class="ash">"""Tests for the class AnonymousSurvey"""</span>

    <span class="ash">def test_store_single_response(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>

    def test_store_three_responses(self):
        """Test that three individual responses are stored properly."""
        question = "What language did you first learn to speak?"
        my_survey = AnonymousSurvey(question)
<span class="n" dir="ltr">1</span>        responses = ['English', 'Spanish', 'Mandarin']
        for response in responses:
            my_survey.store_response(response)

<span class="n" dir="ltr">2</span>        for response in responses:
<a id="p220"></a>            self.assertIn(response, my_survey.responses)

<span class="ash">if __name__ == '__main__':</span>
    <span class="ash">unittest.main()</span></pre></div><p>نام این متد جدید را <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">test_store_three_responses()</span><span class="rlm">‏</span> می‌گذاریم. درست مانند متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">test_store_single_response()</span><span class="rlm">‏</span>، در اینجا هم ابتدا یک شیء نظرسنجی ایجاد می‌کنیم. لیستی حاوی سه پاسخ متفاوت تعریف می‌کنیم <span class="n" dir="ltr">1</span>، و سپس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">store_response()</span><span class="rlm">‏</span> را برای هر کدام از این پاسخ‌ها فراخوانی می‌کنیم. وقتی که پاسخ‌ها ذخیره شدند، حلقه‌ی دیگری می‌نویسیم و تأیید می‌کنیم که هر کدام از پاسخ‌ها اکنون در لیست <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">my_survey.responses</span><span class="rlm">‏</span> وجود دارد <span class="n" dir="ltr">2</span>.</p><p>وقتی که دوباره <span class="rlm">‏</span><span class="ident" dir="ltr">test_survey.py</span><span class="rlm">‏</span> را اجرا می‌کنیم، هر دو آزمون (برای پاسخ منفرد و برای سه پاسخ) قبول می‌شوند:</p><div class="snippet"><pre class="snippet" dir="ltr">..
----------------------------------------------------------------------
Ran 2 tests in 0.000s

OK</pre></div><p>بسیار عالی است. اما این آزمون‌ها کمی تکراری است، بنابراین، از یک ویژگی دیگر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">unittest</span><span class="rlm">‏</span> استفاده می‌کنیم تا آن‌ها را کارآمدتر کنیم.</p></div><div class="sect" id="ch11lev2sec9"><a class="bkmk" name="ch11lev2sec9"></a><h4>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">setUp()</span><span class="rlm">‏</span></h4>
<p class="noindent">در <span class="rlm">‏</span><span class="ident" dir="ltr">test_survey.py</span><span class="rlm">‏</span>، در هر کدام از متدهای آزمون، نمونه‌ی جدیدی از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AnonymousSurvey</span><span class="rlm">‏</span> ایجاد کردیم. کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">unittest.TestCase</span><span class="rlm">‏</span> متدی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">setUp()</span><span class="rlm">‏</span> دارد که به شما امکان می‌دهد که اشیا را یک بار ایجاد کنید و سپس از آن‌ها در هر کدام از متدهای آزمونتان استفاده کنید. وقتی که متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">setUp()</span><span class="rlm">‏</span> را در یک کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">TestCase</span><span class="rlm">‏</span> تعریف می‌کنید، پایتون متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">setUp()</span><span class="rlm">‏</span> را قبل از اجرا کردن هر کدام از متدهایی که با <span class="emphasis"><span class="rlm">‏</span><span class="lr" dir="ltr">test_</span><span class="rlm">‏</span></span> شروع می‌شوند، اجرا می‌کند. بعد، هر کدام از اشیایی که در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">setUp()</span><span class="rlm">‏</span> ایجاد می‌شوند، در متد تست شما نیز در دسترس خواهند بود.</p><p>در اینجا از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">setUp()</span><span class="rlm">‏</span> استفاده می‌کنیم و یک نمونه‌ی نظرسنجی و مجموعه‌ای از پاسخ‌ها ایجاد می‌کنیم تا در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">test_store_single_response()</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">test_store_three_responses()</span><span class="rlm">‏</span> از آن‌ها استفاده کنیم:</p><div class="snippet"><pre class="snippet" dir="ltr"><span class="ash">import unittest</span>
<span class="ash">from survey import AnonymousSurvey</span>

<span class="ash">class TestAnonymousSurvey(unittest.TestCase):</span>
    <span class="ash">"""Tests for the class AnonymousSurvey."""</span>

    def setUp(self):
        """
        Create a survey and a set of responses for use in all test methods.
        """
        question = "What language did you first learn to speak?"
<span class="n" dir="ltr">1</span>        self.my_survey = AnonymousSurvey(question)
<span class="n" dir="ltr">2</span>        self.responses = ['English', 'Spanish', 'Mandarin']

    <span class="ash">def test_store_single_response(self):</span>
        <span class="ash">"""Test that a single response is stored properly."""</span>
        self.my_survey.store_response(self.responses[0])
        self.assertIn(self.responses[0], self.my_survey.responses)

<a id="p221"></a>    <span class="ash">def test_store_three_responses(self):</span>
        <span class="ash">"""Test that three individual responses are stored properly."""</span>
        for response in self.responses:
            self.my_survey.store_response(response)
        for response in self.responses:
            self.assertIn(response, self.my_survey.responses)

<span class="ash">if __name__ == '__main__':</span>
    <span class="ash">unittest.main()</span></pre></div><p>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">setUp()</span><span class="rlm">‏</span> دو کار انجام می‌دهد: یکی اینکه یک نمونه‌ی نظرسنجی ایجاد می‌کند <span class="n" dir="ltr">1</span>، و دیگر اینکه لیستی از پاسخ‌ها ایجاد می‌نماید <span class="n" dir="ltr">2</span>. هر کدام از این‌ها با پیشوند <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self</span><span class="rlm">‏</span> نوشته شده است، تا اینکه در جاهای دیگر کلاس هم بتوان از آن‌ها استفاده کرد. با این روش، دو متد تست ساده‌تر می‌شوند، چون دیگر لازم نیست که یک نمونه‌ی نظرسنجی یا لیست پاسخ‌ها را ایجاد کنند. متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">test_store_single_response()</span><span class="rlm">‏</span> بررسی می‌کند که نخستین پاسخ موجود در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.responses</span><span class="rlm">‏</span>—یعنی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.responses[0]</span><span class="rlm">‏</span>—به درستی ذخیره می‌شود، و متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">test_store_three_responses()</span><span class="rlm">‏</span> بررسی می‌کند که هر سه پاسخ موجود در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.responses</span><span class="rlm">‏</span> را می‌توان به درستی ذخیره کرد.</p><p>وقتی که <span class="rlm">‏</span><span class="ident" dir="ltr">test_survey.py</span><span class="rlm">‏</span> را دوباره اجرا می‌کنیم، باز هم هر دو آزمون قبول می‌شوند. وقتی که بخواهیم <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AnonymousSurvey</span><span class="rlm">‏</span> را توسعه دهیم تا هر نفر بتواند پاسخ‌های متعدد وارد کند، این آزمون‌ها بسیار مفید خواهد بود. پس از آنکه کد را تغییر دادید تا پاسخ‌های متعدد را قبول کند، می‌توانید این تست‌ها را اجرا کنید تا مطمئن شوید که توانایی ذخیره کردن پاسخ منفرد یا پاسخ‌های متعدد دچار اشکال نشده است.</p><p>وقتی که کلاس‌های خودتان از آزمایش می‌کنید، استفاده از متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">setUp()</span><span class="rlm">‏</span> می‌تواند نوشتن متدهای تست را آسان‌تر کند. در متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">setUp()</span><span class="rlm">‏</span> یک مجموعه از نمونه‌ها و صفت‌ها ایجاد می‌کنید، و سپس از آن نمونه‌ها در تمام متدهای تست استفاده می‌کنید. این خیلی راحت‌تر از آن است که مجموعه‌ی جدیدی از نمونه‌ها و صفت‌ها را در هر متد تست ایجاد کنید.</p><div class="note"><h6 class="note-title">توجه</h6>
<p class="noindent">وقتی که یک مورد آزمایشی در حال اجرا است، پایتون برای هر آزمون واحد که تکمیل می‌شود، یک کاراکتر نمایش می‌دهد. برای آزمون‌های قبول شده یک نقطه نمایش می‌دهد، برای آزمونی که منجر به خطا می‌شود، یک <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">E</span><span class="rlm">‏</span> نمایش می‌دهد، و برای آزمونی که <span class="rlm">‏</span><span class="lr" dir="ltr">assert</span><span class="rlm">‏</span> رد شده دارد، یک <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">F</span><span class="rlm">‏</span> نمایش می‌دهد. بدین خاطر است که هنگام اجرای موردهای آزمایشی مختلف، تعداد نقطه‌های متفاوتی می‌بینید. در صورتی که یک مورد آزمایشی تعداد زیادی آزمون واحد داشته باشد و اجرای آن مدت زیادی طول بکشد، با دیدن این نتایج می‌توانید بفهمید که چند آزمون قبول شده است.</p></div><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<p class="tiy1"><span class="tiy" id="ch11_tiy03"><span class="tiy-num">۱۱-۳</span>. <span class="tiy-title">کارمند</span>: </span> کلاسی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Employee</span><span class="rlm">‏</span> بنویسید. متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> باید نام و نام خانوادگی و حقوق سالیانه را بگیرد، و هر کدام از این‌ها را به‌عنوان صفت شیء ذخیره کند. متدی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">give_raise()</span><span class="rlm">‏</span> بنویسید که به‌طور پیش‌فرض مبلغ ۵٬۰۰۰ دلار به حقوق اضافه می‌کند، ولی می‌توانید نیز مقدار ترفیع متفاوتی به آن بدهید.</p><p>یک مورد آزمایشی برای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Employee</span><span class="rlm">‏</span> بنویسید. دو متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">test_give_default_raise()</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">test_give_custom_raise()</span><span class="rlm">‏</span> در آن بنویسید. از متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">setUp()</span><span class="rlm">‏</span> استفاده کنید، تا مجبور نباشید برای هر کدام از متدهای تست، یک نمونه‌ی جدید کارمند ایجاد کنید. مورد آزمایشی را اجرا کنید، و دقت کنید که هر دو آزمون قبول شوند.</p></div></div></div><div class="sect" id="ch11lev1sec3"><a class="bkmk" name="ch11lev1sec3"></a><h3>خلاصه</h3>
<a id="p222"></a><p class="noindent">در این فصل، نوشتن آزمایش برای توابع و کلاس‌ها را با استفاده از بازارهای مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">unittest</span><span class="rlm">‏</span> یاد گرفتید. اول یک کلاس می‌نویسید که از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">unittest.TestCase</span><span class="rlm">‏</span> مشتق می‌شود، و سپس متدهای تست می‌نویسید که رفتارهای خاصی را که متدها و کلاس‌ها باید از خود نشان دهند، بررسی می‌کنند. با متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">setUp()</span><span class="rlm">‏</span> آشنا شدید که با استفاده از آن می‌توانید نمونه‌ها و صفت‌های کلاس را به‌صورت کارآمدی تعیین کنید تا تمام متدهای تست کلاس بتوانند از آن‌ها استفاده کنند.</p><p>تست کردن مبحث مهمی است که خیلی از مبتدیان آن را یاد نمی‌گیرند. لازم نیست برای تمام پروژه‌های ساده‌ای که به‌عنوان یک مبتدی می‌نویسید، تست بنویسید. ولی به محض اینکه شروع به کار بر روی پروژه‌هایی کردید که به کار برنامه‌نویسی زیادی نیاز دارند، ضروری است که رفتارهای مهم توابع و کلاس‌هایتان را تست کنید. به این طریق، می‌توانید مطمئن باشید که قسمت‌هایی جدید که اضافه می‌کنید، قسمت‌های قبلی را خراب نمی‌کند، و لذا خواهید توانست با آزادی عمل بیشتری کدتان را بهبود بخشید. اگر به‌طور تصادفی قابلیت موجود را خراب کردید، فوراً متوجه خواهید شد، و خواهید توانست به آسانی اشکال را برطرف کنید. پاسخ دادن به یک آزمون رد شده خیلی راحت‌تر از پاسخ‌گویی به گزارش اشکال از یک کاربر ناراضی است.</p><p>اگر پروژه‌های شما از ابتدا حاوی تعدادی تست باشد، برنامه‌نویسان دیگر احترام بیشتری برای آن قایل خواهند شد. آن‌ها با راحتی بیشتری با کد شما کار خواهند کرد و تمایل بیشتری خواهند داشت که در پروژه‌ها با شما همکاری کنند. اگر می‌خواهید به پروژه‌ای که برنامه‌نویسان دیگر مشغول کار بر روی آن هستند، کمک کنید، لازم خواهد بود که نشان دهید که کد شما در تست‌های موجود قبول می‌شود، و معمولاً لازم است که تست‌هایی نیز برای رفتار جدیدی که به پروژه اضافه می‌کنید، بنویسید.</p><p>سعی کنید با تست‌ها بیشتر کار کنید تا با فرایند آزمایش کردن کد به خوبی آشنا شوید. تست‌هایی برای رفتارهای بحرانی توابع و کلاس‌هایتان بنویسید، ولی نیازی نیست که در راه‌حل‌ها اولیه‌ی پروژه، هدفتان پوشش کامل باشد، مگر اینکه دلیل خاصی برای این کار وجود داشته باشد.</p></div></div>
				<div class="row pager"><div class="col-md-5 text-center text-md-left pager-prev"><a href="c21-ch10.xhtml"><span xmlns="http://www.w3.org/1999/xhtml"><span>فصل ۱۰</span>: <span>فایل‌ها و استثناها</span></span></a></div><div class="col-md-2 text-center pager-title"><a href="c01-cover.xhtml">آغاز</a></div><div class="col-md-5 text-center text-md-right pager-next"><a href="c23-p2.xhtml"><span xmlns="http://www.w3.org/1999/xhtml"><span>بخش ۲</span>: <span>پروژه‌ها</span></span></a></div></div></main><aside class="col-md-2 order-md-first"><ul class="nav nav-pills flex-column"><li class="nav-item"><a class="nav-link" href="../">دوره‌ی فشرده‌ی پایتون</a></li><li class="nav-item"><a class="nav-link" href="c06-toc.xhtml">فهرست</a></li></ul></aside></div></div><div class="container"><div id="footer" class="row"><div class="col-sm-6"><p><span>© ۱۴۰۰، قاسم کیانی مقدم.</span></p></div><div class="col-sm-6"><p class="text-right"><span><a target="_blank" rel="me" href="https://linkedin.com/in/ghasemkiani" title="لینکدین"><span class="fab fa-linkedin"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://github.com/ghasemkiani" title="گیت‌هاب"><span class="fab fa-github"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://twitter.com/ghasemkiani" title="توئیتر"><span class="fab fa-twitter"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://facebook.com/ghasemkiani" title="فیس‌بوک"><span class="fab fa-facebook"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://telegram.me/ghasemkiani" title="تلگرام"><span class="fab fa-telegram"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://instagram.com/ghasem.kiani" title="اینستاگرام"><span class="fab fa-instagram"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://mastodon.social/@ghasemkiani" title="ماستودون"><span class="fab fa-mastodon"></span></a></span></p></div></div></div><script crossorigin="anonymous" src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"></script><script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut"></script><script crossorigin="anonymous" src="https://cdn.rtlcss.com/bootstrap/v4.0.0/js/bootstrap.min.js" integrity="sha384-54+cucJ4QbVb99v8dcttx/0JRx4FHMmhOWi4W+xrXpKcsKQodCBwAvu3xxkZAwsH"></script><script src="https://www.googletagmanager.com/gtag/js?id=UA-135468998-1"></script><script src="data:application/javascript;charset=UTF-8;base64,KCh7aWR9KSA9PiB7Cgl3aW5kb3cuZGF0YUxheWVyID0gd2luZG93LmRhdGFMYXllciB8fCBbXTsKCWZ1bmN0aW9uIGd0YWcoKXtkYXRhTGF5ZXIucHVzaChhcmd1bWVudHMpO30KCWd0YWcoImpzIiwgbmV3IERhdGUoKSk7CgoJZ3RhZygiY29uZmlnIiwgaWQpOwp9KSh7ImlkIjoiVUEtMTM1NDY4OTk4LTEifSk7Cg=="></script></body></html>