<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="fa" dir="rtl"><head><meta charset="utf-8"/><title>کلاس</title><meta name="description" content="وب‌سایت قاسم کیانی مقدم"/><meta name="keywords" content="قاسم کیانی مقدم, وب‌سایت, وب‌سایت قاسم کیانی مقدم, کتاب, فارسی, کتاب فارسی, ترجمه, برنامه‌نویسی, جاوا, جاوا اسکریپت, پزشکی, طب اطفال"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="stylesheet" crossorigin="anonymous" href="https://cdn.rtlcss.com/bootstrap/v4.0.0/css/bootstrap.min.css" integrity="sha384-P4uhUIGk/q1gaD/NdgkBIl3a6QywJjlsFJFk7SPRdruoGddvRVSwv5qFnvZ73cpz"/><link rel="stylesheet" crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.7.1/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr"/><link rel="icon" href="../../../favicon.ico"/><style>@import url(https://fonts.googleapis.com/css?family=Droid+Sans);
@import url(https://fonts.googleapis.com/css?family=Droid+Serif);
@import url(https://fonts.googleapis.com/css?family=Droid+Arabic+Kufi);
@import url(https://fonts.googleapis.com/css?family=Droid+Arabic+Naskh);
html,body,input,textarea,select,option,h1,h2,h3,h4,h5,h6{font-family:Droid Arabic Naskh,Droid Serif;}
nav,.nav{font-family:Droid Arabic Kufi,Droid Sans;}
h1,h2,h3,h4,h5,h6{font-family:Droid Arabic Naskh,Droid Serif;}
#footer{margin-top:0.5rem;padding-top:0.5rem;border-top:#eeeeee solid thick;}</style><style>@import url(https://fonts.googleapis.com/css?family=Courier+Prime);
div.row.pager{margin-top:0.5em;padding:0.5em 0;border-top:solid #cccccc 2px;background-color:#dddddd;}
div.pager-prev{}
div.pager-title{}
div.pager-next{}</style><link rel="stylesheet" type="text/css" href="styles.css"/></head><body style="min-height: 75rem;"><nav class="navbar navbar-expand-md navbar-dark bg-dark mb-4"><div class="container"><a class="navbar-brand" href="../../../">وب‌سایت قاسم کیانی مقدم</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#divNavBarToggle" aria-controls="divNavBarToggle" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div id="divNavBarToggle" class="collapse navbar-collapse"><ul class="navbar-nav mr-auto"><li class="nav-item active"><a class="nav-link" href="../../">کتاب‌ها<span class="sr-only"> (current)</span></a></li><li class="nav-item"><a class="nav-link" href="../../../essays/">مقالات</a></li><li class="nav-item"><a class="nav-link" href="../../../translation/">ترجمه</a></li><li class="nav-item"><a class="nav-link" href="../../../about/">درباره</a></li><li class="nav-item"><a class="nav-link" href="../../../contact/">تماس</a></li></ul></div></div></nav><div class="container"><div class="row"><main class="col-md-10 order-md-last">
					<article class="ch" id="ch009"><h2 class="ch-title"><a class="rtoc" href="c06-toc.xhtml"><span class="ch-title-num">۹</span><br/><span class="ch-title-text">کلاس</span></a></h2><img style="float: right; margin-left: 0.5em; margin-bottom: 0.25em;" alt="تصویر ابتدای فصل" src="images/ch.svg"/>
<a id="p157"></a><p class="noindent"><span class="emphasis">برنامه‌نویسی شیءگرا</span> یکی از کارآمدترین رویکردها برای نوشتن نرم‌افزار است. در این رویکرد، شما <span class="emphasis">کلاس‌هایی</span> می‌نویسید که معرف چیزها و موقعیت‌هایی در دنیای واقعی هستند، و بر اساس این کلاس‌ها، <span class="emphasis">اشیایی</span> ایجاد می‌کنید. وقتی که یک کلاس می‌نویسید، رفتاری عمومی را تعریف می‌کنید که دسته‌ای از اشیا می‌توانند داشته باشند. وقتی که هر کدام اشیا را از آن کلاس ایجاد می‌کنید، شیء ایجاد شده به‌طور خودکار به آن رفتار عمومی مجهز می‌شود؛ سپس می‌توانید به هر شیء صفاتی را که می‌خواهید، بدهید. شگفت‌انگیز خواهید شد وقتی ببینید که چه خوب می‌توان موقعیت‌های دنیای واقعی را با برنامه‌نویسی شیءگرا مدل‌سازی کرد.</p><p>به ساختن شیء از کلاس <span class="emphasis">نمونه‌سازی</span> می‌گویند، و شما با <span class="emphasis">نمونه‌هایی</span> از کلاس کار می‌کنید. در این فصل، نوشتن کلاس و ایجاد کردن نمونه‌هایی از کلاس‌ها را یاد خواهید گرفت. نوع اطلاعاتی را که می‌توان در نمونه‌ی کلاس ذخیره کرد، مشخص خواهید کرد، و عمل‌هایی را که روی آن نمونه‌ها می‌توان انجام داد، تعریف خواهید کرد. هم‌چنین، کلاس‌هایی خواهید نوشت که قابلیت‌های یک کلاس موجود را بسط می‌دهند، به‌طوری که <a id="p158"></a>کلاس‌های مشابه بتوانند به‌طور مؤثری کد مشترک داشته باشند. کلاس‌های خود را در مدول ذخیره خواهید کرد و کلاس‌هایی را که برنامه‌نویسان دیگر نوشته‌اند، به برنامه‌های خود ایمپورت خواهید کرد.</p><p>فهمیدن برنامه‌نویسی شیءگرا به شما کمک خواهد کرد که دنیا را مانند یک برنامه‌نویس ببینید. به شما کمک خواهد کرد که واقعاً کدتان را بفهمید، نه به این صورت که در هر سطر آن چه اتفاقی می‌افتد، بلکه به این صورت که مفاهیم بزرگ‌تر آن را درک کنید. شناخت منطق کلاس‌ها شما را آموزش خواهد داد که به‌طور منطقی فکر کنید، تا بتوانید تقریباً برای حل هر مسئله‌ای که با آن برخورد می‌کنید، برنامه بنویسید.</p><p>در ضمن به تدریج که به سراغ چالش‌های هرچه پیچیده‌تر می‌روید، استفاده از کلاس کار را برای شما و دیگر برنامه‌نویسانی که با آنها کار می‌کنید، راحت‌تر خواهد کرد. وقتی که شما و برنامه‌نویسان دیگر بر اساس نوع منطق یکسانی کد بنویسید، خواهید توانست کار یکدیگر را درک کنید. برنامه‌های شما برای همکارانتان معنی‌دار خواهد شد، به‌طوری که همه خواهند توانست کار بیشتری را انجام دهند.</p><div class="sect" id="ch09lev1sec1"><h3>ایجاد کردن و استفاده از یک کلاس</h3>
<p class="noindent">تقریباً هر چیزی را می‌توان با استفاده از کلاس مدل‌سازی کرد. برای شروع، کلاس ساده‌ای را به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span> در نظر می‌گیریم که نشان‌دهنده‌ی یک سگ است— البته نه یک سگ مشخص، بلکه هر سگی. درباره ی سگ‌های خانگی چه می‌دانیم؟ خوب، همگی آنها دارای نام و سن هستند. این را هم می‌دانیم که اکثر سگ‌ها می‌نشیند و می‌غلتند. این دو ویژگی (نام و سن) و این دو رفتار (نشستن و غلتیدن) را در کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span> قرار خواهیم داد، زیرا در بین اکثر سگ‌ها مشترک است. این کلاس به پایتون خواهد گفت که چگونه شیئی را که معرف یک سگ است، بسازد. پس از نوشتن این کلاس، با استفاده از آن نمونه‌هایی ایجاد خواهیم کرد که هر کدام از آنها نشان‌دهنده‌ی یک سگ خاص است.</p><div class="sect" id="ch09lev2sec1"><h4>ایجاد کردن کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span></h4>
<p class="noindent">در هر نمونه‌ی ایجاد شده از کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span>، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">name</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">age</span><span class="rlm">‏</span> را ذخیره می‌کنیم، و به هر سگ توانایی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">sit()</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">roll_over()</span><span class="rlm">‏</span> را می‌دهیم:</p><div class="snippet-title" dir="ltr">dog.py</div><pre class="snippet" dir="ltr"><span class="n" dir="ltr">1</span>class Dog:
<span class="n" dir="ltr">2</span>    """A simple attempt to model a dog."""

<span class="n" dir="ltr">3</span>    def __init__(self, name, age):
        """Initialize name and age attributes."""
<span class="n" dir="ltr">4</span>        self.name = name
        self.age = age

<span class="n" dir="ltr">5</span>    def sit(self):
        """Simulate a dog sitting in response to a command."""
        print(f"{self.name} is now sitting.")

    def roll_over(self):
        """Simulate rolling over in response to a command."""
        print(f"{self.name} rolled over!")</pre><p>اینجا چیزهای زیادی هست که باید یاد بگیرید، ولی نگران نباشید. این ساختار را در سرتاسر این کتاب شاهد خواهید بود و فرصت کافی خواهید داشت که به آن عادت کنید. در <span class="n" dir="ltr">1</span>، <a id="p159"></a>کلاسی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span> تعریف می‌کنیم. بنا به قرارداد، نام کلاس‌ها در پایتون با حروف بزرگ شروع می‌شود. در تعریف این کلاس پرانتز استفاده نشده است، چرا که این کلاس را از صفر ایجاد می‌کنیم. در <span class="n" dir="ltr">2</span>، یک رشته‌ی مستندات نوشته‌ایم که توضیح می‌دهد این کلاس چه کاری انجام می‌دهد.
</p><div class="sect" id="ch09lev3sec1"><h5>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span></h5>
<p class="noindent">تابعی که بخشی از یک کلاس است، <span class="emphasis">مِتُد</span> نامیده می‌شود. تمام چیزهایی که درباره‌ی توابع یاد گرفته‌اید، برای متدها نیز مصداق دارد؛ فعلاً تنها تفاوت عملی آن‌ها در نحوه‌ی فراخواندن متدها است. متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span> در <span class="n" dir="ltr">3</span> متد ویژه‌ای است که که پایتون هر زمان نمونه‌ی جدیدی بر اساس کلالس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span> ایجاد می‌کنید، آن را فراخوانی می‌کند. اول و آخر نام این متد دو زیرخط قرار گرفته است، که این قرارداد در پایتون برای آن است که نام متدهای پیش‌فرض با نام متدهای شما تداخل پیدا نکند. دقت کنید که دو زیرخط اول و دو زیرخط آخر را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span> فراموش نکنید. اگر فقط یک زیرخط بگذارید، این متد در هنگام استفاده از کلاس به‌طور خودکار فراخوانی نخواهد شد، و منجر به خطاهایی خواهد شد که شناسایی آن‌ها مشکل است.</p><p>ما برای متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span> سه پارامتر تعریف کرده‌ایم: <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self</span><span class="rlm">‏</span>، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">name</span><span class="rlm">‏</span>، و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">age</span><span class="rlm">‏</span>. پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self</span><span class="rlm">‏</span> در تعریف متد لازم است، و همیشه باید پارامتر اول باشد، قبل از پارامترهای دیگر. علت اینکه این پارامتر باید در تعریف متد گنجانده شود، این است که بعداً که پایتون متد را برای ایجاد نمونه‌ی جدیدی از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span> فراخوانی می‌کند، در فراخوانی متد به‌طور خودکار آرگومان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self</span><span class="rlm">‏</span> را به آن خواهد داد. هر فراخوانی متد که مربوط به یک نمونه است، به‌طور خودکار آرگومان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self</span><span class="rlm">‏</span> را با آن می‌دهد، که اشاره‌ای به خود آن نمونه است؛ به این ترتیب، نمونه‌ی مورد نظر، دسترسی به صفات و متدهای تعریف شده در کلاس خواهد داشت. وقتی که نمونه‌ای از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span> ایجاد می‌کنیم، پایتون متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span> از کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span> را فراخوانی می‌کند. ما به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog()</span><span class="rlm">‏</span> آرگومان‌های نام و سن می‌دهیم؛ مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self</span><span class="rlm">‏</span> به‌طور خودکار داده می‌شود، لذا نیازی نیست که ما آن را به متد بدهیم. هر گاه بخواهیم نمونه‌ای از کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span> ایجاد کنیم، فقط برای دو پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">name</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">age</span><span class="rlm">‏</span> به آن مقدار خواهیم داد.</p><p>دو متغیر تعریف شده در <span class="n" dir="ltr">4</span> هر کدام پیشوند <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self</span><span class="rlm">‏</span> دارند. هر متغیری که با پیشوند <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self</span><span class="rlm">‏</span> تعریف شود، در دسترس هر کدام از متدهای کلاس خواهد بود، و هم‌چنین، هر گاه نمونه‌ای از کلاس ایجاد کنیم، قادر به دسترسی به این متغیرها خواهیم بود. سطر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self.name = name</span><span class="rlm">‏</span> مقدار مربوط به پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">name</span><span class="rlm">‏</span> را می‌گیرد و آن را به متغیر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">name</span><span class="rlm">‏</span> اختصاص می‌دهد که به نمونه‌ی ایجاد شده متصل است. در سطر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self.age = age</span><span class="rlm">‏</span> نیز همین اتفاق می‌افتد. متغیرهایی که در سرتاسر نمونه قابل دسترسی هستند، <span class="emphasis">صفت</span> نامیده می‌شوند.</p><p>در کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span>، دو متد دیگر نیز تعریف شده است: <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">sit()</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">roll_over()</span><span class="rlm">‏</span> <span class="n" dir="ltr">5</span>. 
The  class has two other methods defined:  and  . Because these methods don’t need additional information to run, we just define them to have one parameter, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self</span><span class="rlm">‏</span>. The instances we create later will have access to these methods. In other words, they’ll be able to sit and roll over. For now, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">sit()</span><span class="rlm">‏</span> and <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">roll_over()</span><span class="rlm">‏</span> don’t do much. They simply print a message saying the dog is sitting or rolling over. But the concept can be extended to realistic situations: if this class were part of an actual computer game, these methods would contain code to make an animated dog sit and roll over. If this class was written to control a robot, these methods would direct movements that cause a robotic dog to sit and roll over.
</p></div></div><div class="sect" id="ch09lev2sec2"><h4>Making an Instance from a Class</h4>
<a id="p160"></a><p class="noindent">
Think of a class as a set of instructions for how to make an instance. The class <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span> is a set of instructions that tells Python how to make individual instances representing specific dogs.
</p><p>
Let’s make an instance representing a specific dog:</p><pre class="snippet" dir="ltr"><span class="ash">class Dog:</span>
    <span class="ash">--<span class="it">snip</span>--</span>

<span class="n" dir="ltr">1</span>my_dog = Dog('Willie', 6)

<span class="n" dir="ltr">2</span>print(f"My dog's name is {my_dog.name}.")
<span class="n" dir="ltr">3</span>print(f"My dog is {my_dog.age} years old.")</pre><p>
The <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span> class we’re using here is the one we just wrote in the previous example. At <span class="n" dir="ltr">1</span> we tell Python to create a dog whose name is <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'Willie'</span><span class="rlm">‏</span> and whose age is <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">6</span><span class="rlm">‏</span>. When Python reads this line, it calls the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span> method in <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span> with the arguments <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'Willie'</span><span class="rlm">‏</span> and <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">6</span><span class="rlm">‏</span>. The <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span> method creates an instance representing this particular dog and sets the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">name</span><span class="rlm">‏</span> and <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">age</span><span class="rlm">‏</span> attributes using the values we provided. Python then returns an instance representing this dog. We assign that instance to the variable <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">my_dog</span><span class="rlm">‏</span>. The naming convention is helpful here: we can usually assume that a capitalized name like <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span> refers to a class, and a lowercase name like <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">my_dog</span><span class="rlm">‏</span> refers to a single instance created from a class.
</p><div class="sect" id="ch09lev3sec2"><h5>Accessing Attributes</h5>
<p class="noindent">
To access the attributes of an instance, you use dot notation. At <span class="n" dir="ltr">2</span> we access the value of <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">my_dog</span><span class="rlm">‏</span>’s attribute <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">name</span><span class="rlm">‏</span> by writing:
</p><pre class="snippet" dir="ltr">my_dog.name</pre><p>
Dot notation is used often in Python. This syntax demonstrates how Python finds an attribute’s value. Here Python looks at the instance <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">my_dog</span><span class="rlm">‏</span> and then finds the attribute <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">name</span><span class="rlm">‏</span> associated with <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">my_dog</span><span class="rlm">‏</span>. This is the same attribute referred to as <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self.name</span><span class="rlm">‏</span> in the class <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span>. At <span class="n" dir="ltr">3</span> we use the same approach to work with the attribute <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">age</span><span class="rlm">‏</span>.
</p><p>
The output is a summary of what we know about <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">my_dog</span><span class="rlm">‏</span>:
</p><pre class="snippet" dir="ltr">My dog's name is Willie.
My dog is 6 years old.</pre></div><div class="sect" id="ch09lev3sec3"><h5>Calling Methods</h5>
<p class="noindent">
After we create an instance from the class <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span>, we can use dot notation to call any method defined in <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span>. Let’s make our dog sit and roll over:
</p><pre class="snippet" dir="ltr"><span class="ash">class Dog:</span>
    <span class="ash">--<span class="it">snip</span>--</span>

<a id="p161"></a><span class="ash">my_dog = Dog('Willie', 6)</span>
my_dog.sit()
my_dog.roll_over()</pre><p>
To call a method, give the name of the instance (in this case, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">my_dog</span><span class="rlm">‏</span>) and the method you want to call, separated by a dot. When Python reads <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">my_dog.sit()</span><span class="rlm">‏</span>, it looks for the method <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">sit()</span><span class="rlm">‏</span> in the class <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span> and runs that code. Python interprets the line <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">my_dog.roll_over()</span><span class="rlm">‏</span> in the same way.
</p><p>
Now Willie does what we tell him to:</p><pre class="snippet" dir="ltr">Willie is now sitting.
Willie rolled over!</pre><p>
This syntax is quite useful. When attributes and methods have been given appropriately descriptive names like <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">name</span><span class="rlm">‏</span>, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">age</span><span class="rlm">‏</span>, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">sit()</span><span class="rlm">‏</span>, and <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">roll_over()</span><span class="rlm">‏</span>, we can easily infer what a block of code, even one we’ve never seen before, is supposed to do.
</p></div><div class="sect" id="ch09lev3sec4"><h5>Creating Multiple Instances</h5>
<p class="noindent">
You can create as many instances from a class as you need. Let’s create a second dog called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">your_dog</span><span class="rlm">‏</span>:
</p><pre class="snippet" dir="ltr"><span class="ash">class Dog:</span>
    <span class="ash">--<span class="it">snip</span>--</span>

my_dog = Dog('Willie', 6)
your_dog = Dog('Lucy', 3)

print(f"My dog's name is {my_dog.name}.")
print(f"My dog is {my_dog.age} years old.")
my_dog.sit()

print(f"\nYour dog's name is {your_dog.name}.")
print(f"Your dog is {your_dog.age} years old.")
your_dog.sit()</pre><p>
In this example we create a dog named Willie and a dog named Lucy. Each dog is a separate instance with its own set of attributes, capable of the same set of actions:</p><pre class="snippet" dir="ltr">My dog's name is Willie.
My dog is 6 years old.
Willie is now sitting.

Your dog's name is Lucy.
Your dog is 3 years old.
Lucy is now sitting.</pre><p>
Even if we used the same name and age for the second dog, Python would still create a separate instance from the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span> class. You can make <a id="p162"></a> as many instances from one class as you need, as long as you give each instance a unique variable name or it occupies a unique spot in a list or dictionary.
</p><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<p class="tiy1"><span class="tiy" id="ch009_tiy001"><span class="tiy-num">۹-۱</span>. <span class="tiy-title">۹-۱. Restaurant:</span>: </span>
Make a class called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Restaurant</span><span class="rlm">‏</span>. The <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span> method for <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Restaurant</span><span class="rlm">‏</span> should store two attributes: a <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">restaurant_name</span><span class="rlm">‏</span> and a <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">cuisine_type</span><span class="rlm">‏</span>. Make a method called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">describe_restaurant()</span><span class="rlm">‏</span> that prints these two pieces of information, and a method called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">open_restaurant()</span><span class="rlm">‏</span> that prints a message indicating that the restaurant is open.
</p><p>
Make an instance called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">restaurant</span><span class="rlm">‏</span> from your class. Print the two attributes individually, and then call both methods.
</p><p class="tiy1"><span class="tiy" id="ch009_tiy002"><span class="tiy-num">۹-۲</span>. <span class="tiy-title">۹-۲. Three Restaurants:</span>: </span>
Start with your class from <span class="ref"><a href="c20-ch09.xhtml#ch009_tiy001">تمرین <span dir="ltr">۹-۱</span></a></span>. Create three different instances from the class, and call <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">describe_restaurant()</span><span class="rlm">‏</span> for each instance.
</p><p class="tiy1"><span class="tiy" id="ch009_tiy003"><span class="tiy-num">۹-۳</span>. <span class="tiy-title">۹-۳. Users:</span>: </span>
Make a class called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">User</span><span class="rlm">‏</span>. Create two attributes called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">first_name</span><span class="rlm">‏</span> and <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">last_name</span><span class="rlm">‏</span>, and then create several other attributes that are typically stored in a user profile. Make a method called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">describe_user()</span><span class="rlm">‏</span> that prints a summary of the user’s information. Make another method called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">greet_user()</span><span class="rlm">‏</span> that prints a personalized greeting to the user.
</p><p>
Create several instances representing different users, and call both methods for each user.</p></div></div></div></div><div class="sect" id="ch09lev1sec2"><h3>Working with Classes and Instances</h3>
<p class="noindent">
You can use classes to represent many real-world situations. Once you write a class, you’ll spend most of your time working with instances created from that class. One of the first tasks you’ll want to do is modify the attributes associated with a particular instance. You can modify the attributes of an instance directly or write methods that update attributes in specific ways.</p><div class="sect" id="ch09lev2sec3"><h4>The Car Class</h4>
<p class="noindent">
Let’s write a new class representing a car. Our class will store information about the kind of car we’re working with, and it will have a method that summarizes this information:</p><div class="snippet-title" dir="ltr">car.py</div><pre class="snippet" dir="ltr">
class Car:
    """A simple attempt to represent a car."""

<span class="n" dir="ltr">1</span>    def __init__(self, make, model, year):
        """Initialize attributes to describe a car."""
        self.make = make
<a id="p163"></a>        self.model = model
        self.year = year

<span class="n" dir="ltr">2</span>    def get_descriptive_name(self):
        """Return a neatly formatted descriptive name."""
        long_name = f"{self.year} {self.manufacturer} {self.model}"
        return long_name.title()

<span class="n" dir="ltr">3</span>my_new_car = Car('audi', 'a4', 2019)
print(my_new_car.get_descriptive_name())</pre><p>
At <span class="n" dir="ltr">1</span> in the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> class, we define the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span> method with the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self</span><span class="rlm">‏</span> parameter first, just like we did before with our <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Dog</span><span class="rlm">‏</span> class. We also give it three other parameters: <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">make</span><span class="rlm">‏</span>, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">model</span><span class="rlm">‏</span>, and <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">year</span><span class="rlm">‏</span>. The <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span> method takes in these parameters and assigns them to the attributes that will be associated with instances made from this class. When we make a new <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> instance, we’ll need to specify a make, model, and year for our instance.
</p><p>
At <span class="n" dir="ltr">2</span> we define a method called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">get_descriptive_name()</span><span class="rlm">‏</span> that puts a car’s <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">year</span><span class="rlm">‏</span>, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">make</span><span class="rlm">‏</span>, and <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">model</span><span class="rlm">‏</span> into one string neatly describing the car. This will spare us from having to print each attribute’s value individually. To work with the attribute values in this method, we use <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self.make</span><span class="rlm">‏</span>, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self.model</span><span class="rlm">‏</span>, and <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self.year</span><span class="rlm">‏</span>. At <span class="n" dir="ltr">3</span> we make an instance from the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> class and assign it to the variable <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">my_new_car</span><span class="rlm">‏</span>. Then we call <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">get_descriptive_name()</span><span class="rlm">‏</span> to show what kind of car we have:
</p><pre class="snippet" dir="ltr">2019 Audi A4</pre><p>
To make the class more interesting, let’s add an attribute that changes over time. We’ll add an attribute that stores the car’s overall mileage.</p></div><div class="sect" id="ch09lev2sec4"><h4>Setting a Default Value for an Attribute</h4>
<p class="noindent">
When an instance is created, attributes can be defined without being passed in as parameters. These attributes can be defined in the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span> method, where they are assigned a default value.
</p><p>
Let’s add an attribute called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">odometer_reading</span><span class="rlm">‏</span> that always starts with a value of ۰. We’ll also add a method <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">read_odometer()</span><span class="rlm">‏</span> that helps us read each car’s odometer:
</p><pre class="snippet" dir="ltr"><span class="ash">class Car:</span>

    <span class="ash">def __init__(self, make, model, year):</span>
        <span class="ash">"""Initialize attributes to describe a car."""</span>
        <span class="ash">self.make = make</span>
        <span class="ash">self.model = model</span>
        <span class="ash">self.year = year</span>
<span class="n" dir="ltr">1</span>        self.odometer_reading = 0

    <span class="ash">def get_descriptive_name(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>

<a id="p164"></a><span class="n" dir="ltr">2</span>    def read_odometer(self):
        """Print a statement showing the car's mileage."""
        print(f"This car has {self.odometer_reading} miles on it.")

<span class="ash">my_new_car = Car('audi', 'a4', 2019)</span>
<span class="ash">print(my_new_car.get_descriptive_name())</span>
my_new_car.read_odometer()</pre><p>
This time when Python calls the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span> method to create a new instance, it stores the make, model, and year values as attributes like it did in the previous example. Then Python creates a new attribute called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">odometer_reading</span><span class="rlm">‏</span> and sets its initial value to ۰ <span class="n" dir="ltr">1</span>. We also have a new method called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">read_odometer()</span><span class="rlm">‏</span> at <span class="n" dir="ltr">2</span> that makes it easy to read a car’s mileage.
</p><p>
Our car starts with a mileage of ۰:</p><pre class="snippet" dir="ltr">2019 Audi A4
This car has 0 miles on it.</pre><p>
Not many cars are sold with exactly ۰ miles on the odometer, so we need a way to change the value of this attribute.</p></div><div class="sect" id="ch09lev2sec5"><h4>Modifying Attribute Values</h4>
<p class="noindent">
You can change an attribute’s value in three ways: you can change the value directly through an instance, set the value through a method, or increment the value (add a certain amount to it) through a method. Let’s look at each of these approaches.</p><div class="sect" id="ch09lev3sec5"><h5>Modifying an Attribute’s Value Directly</h5>
<p class="noindent">
The simplest way to modify the value of an attribute is to access the attribute directly through an instance. Here we set the odometer reading to ۲۳ directly:</p><pre class="snippet" dir="ltr"><span class="ash">class Car:</span>
    <span class="ash">--<span class="it">snip</span>--</span>

<span class="ash">my_new_car = Car('audi', 'a4', 2019)</span>
<span class="ash">print(my_new_car.get_descriptive_name())</span>

<span class="n" dir="ltr">1</span>my_new_car.odometer_reading = 23
my_new_car.read_odometer()</pre><p>
At <span class="n" dir="ltr">1</span> we use dot notation to access the car’s <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">odometer_reading</span><span class="rlm">‏</span> attribute and set its value directly. This line tells Python to take the instance <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">my_new_car</span><span class="rlm">‏</span>, find the attribute <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">odometer_reading</span><span class="rlm">‏</span> associated with it, and set the value of that attribute to ۲۳:
</p><pre class="snippet" dir="ltr">2019 Audi A4
This car has 23 miles on it.</pre><a id="p165"></a><p>
Sometimes you’ll want to access attributes directly like this, but other times you’ll want to write a method that updates the value for you.
</p></div><div class="sect" id="ch09lev3sec6"><h5>Modifying an Attribute’s Value Through a Method</h5>
<p class="noindent">
It can be helpful to have methods that update certain attributes for you. Instead of accessing the attribute directly, you pass the new value to a method that handles the updating internally.</p><p>
Here’s an example showing a method called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">update_odometer()</span><span class="rlm">‏</span>:
</p><pre class="snippet" dir="ltr"><span class="ash">class Car:</span>
    <span class="ash">--<span class="it">snip</span>--</span>

<span class="n" dir="ltr">1</span>    def update_odometer(self, mileage):
        """Set the odometer reading to the given value."""
        self.odometer_reading = mileage

<span class="ash">my_new_car = Car('audi', 'a4', 2019)</span>
<span class="ash">print(my_new_car.get_descriptive_name())</span>

<span class="n" dir="ltr">2</span>my_new_car.update_odometer(23)
my_new_car.read_odometer()</pre><p>
The only modification to <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> is the addition of <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">update_odometer()</span><span class="rlm">‏</span> at <span class="n" dir="ltr">1</span>. This method takes in a mileage value and assigns it to <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self.odometer_reading</span><span class="rlm">‏</span>. At <span class="n" dir="ltr">2</span> we call <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">update_odometer()</span><span class="rlm">‏</span> and give it <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">23</span><span class="rlm">‏</span> as an argument (corresponding to the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">mileage</span><span class="rlm">‏</span> parameter in the method definition). It sets the odometer reading to ۲۳, and <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">read_odometer()</span><span class="rlm">‏</span> prints the reading:
</p><pre class="snippet" dir="ltr">2019 Audi A4
This car has 23 miles on it.</pre><p>
We can extend the method <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">update_odometer()</span><span class="rlm">‏</span> to do additional work every time the odometer reading is modified. Let’s add a little logic to make sure no one tries to roll back the odometer reading:
</p><pre class="snippet" dir="ltr"><span class="ash">class Car:</span>
    <span class="ash">--<span class="it">snip</span>--</span>

    <span class="ash">def update_odometer(self, mileage):</span>
        """
        Set the odometer reading to the given value.
        Reject the change if it attempts to roll the odometer back.
        """
<span class="n" dir="ltr">1</span>        if mileage &gt;= self.odometer_reading:
            <span class="ash">self.odometer_reading = mileage</span>
        else:
<span class="n" dir="ltr">2</span>            print("You can't roll back an odometer!")</pre><p>
Now <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">update_odometer()</span><span class="rlm">‏</span> checks that the new reading makes sense before modifying the attribute. If the new mileage, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">mileage</span><span class="rlm">‏</span>, is greater than or equal <a id="p166"></a>to the existing mileage, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self.odometer_reading</span><span class="rlm">‏</span>, you can update the odometer reading to the new mileage <span class="n" dir="ltr">1</span>. If the new mileage is less than the existing mileage, you’ll get a warning that you can’t roll back an odometer <span class="n" dir="ltr">2</span>.
</p></div><div class="sect" id="ch09lev3sec7"><h5>Incrementing an Attribute’s Value Through a Method</h5>
<p class="noindent">
Sometimes you’ll want to increment an attribute’s value by a certain amount rather than set an entirely new value. Say we buy a used car and put ۱۰۰ miles on it between the time we buy it and the time we register it. Here’s a method that allows us to pass this incremental amount and add that value to the odometer reading:</p><pre class="snippet" dir="ltr"><span class="ash">class Car:</span>
    <span class="ash">--<span class="it">snip</span>--</span>

    <span class="ash">def update_odometer(self, mileage):</span>
        <span class="ash">--<span class="it">snip</span>--</span>

<span class="n" dir="ltr">1</span>    def increment_odometer(self, miles):
        """Add the given amount to the odometer reading."""
        self.odometer_reading += miles

<span class="n" dir="ltr">2</span>my_used_car = Car('subaru', 'outback', 2015)
print(my_used_car.get_descriptive_name())

<span class="n" dir="ltr">3</span>my_used_car.update_odometer(23_500)
my_used_car.read_odometer()

<span class="n" dir="ltr">4</span>my_used_car.increment_odometer(100)
my_used_car.read_odometer()</pre><p>
The new method <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">increment_odometer()</span><span class="rlm">‏</span> at <span class="n" dir="ltr">1</span> takes in a number of miles, and adds this value to <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self.odometer_reading</span><span class="rlm">‏</span>. At <span class="n" dir="ltr">2</span> we create a used car, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">my_used_car</span><span class="rlm">‏</span>. We set its odometer to ۲۳٬۵۰۰ by calling <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">update_odometer()</span><span class="rlm">‏</span> and passing it <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">23_500</span><span class="rlm">‏</span> at <span class="n" dir="ltr">3</span>. At <span class="n" dir="ltr">4</span> we call <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">increment_odometer()</span><span class="rlm">‏</span> and pass it <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">100</span><span class="rlm">‏</span> to add the ۱۰۰ miles that we drove between buying the car and registering it:
</p><pre class="snippet" dir="ltr">2015 Subaru Outback
This car has 23500 miles on it.
This car has 23600 miles on it.</pre><p>
You can easily modify this method to reject negative increments so no one uses this function to roll back an odometer.</p><div class="note"><h6 class="note-title">توجه</h6>
<p class="noindent">
You can use methods like this to control how users of your program update values such as an odometer reading, but anyone with access to the program can set the odometer reading to any value by accessing the attribute directly. Effective security takes extreme attention to detail in addition to basic checks like those shown here.</p></div><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<a id="p167"></a><p class="tiy1"><span class="tiy" id="ch009_tiy004"><span class="tiy-num">۹-۴</span>. <span class="tiy-title">۹-۴. Number Served:</span>: </span>
Start with your program from <span class="ref"><a href="c20-ch09.xhtml#ch009_tiy001">تمرین <span dir="ltr">۹-۱</span></a></span> (<span class="ref"><a href="c20-ch09.xhtml#p162">صفحه‌ی <span>۱۶۲</span></a></span>). Add an attribute called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">number_served</span><span class="rlm">‏</span> with a default value of ۰. Create an instance called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">restaurant</span><span class="rlm">‏</span> from this class. Print the number of customers the restaurant has served, and then change this value and print it again.
</p><p>
Add a method called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">set_number_served()</span><span class="rlm">‏</span> that lets you set the number of customers that have been served. Call this method with a new number and print the value again.
</p><p>
Add a method called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">increment_number_served()</span><span class="rlm">‏</span> that lets you increment the number of customers who’ve been served. Call this method with any number you like that could represent how many customers were served in, say, a day of business.
</p><p class="tiy1"><span class="tiy" id="ch009_tiy005"><span class="tiy-num">۹-۵</span>. <span class="tiy-title">۹-۵. Login Attempts:</span>: </span>
Add an attribute called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">login_attempts</span><span class="rlm">‏</span> to your <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">User</span><span class="rlm">‏</span> class from <span class="ref"><a href="c20-ch09.xhtml#ch009_tiy003">تمرین <span dir="ltr">۹-۳</span></a></span> (<span class="ref"><a href="c20-ch09.xhtml#p162">صفحه‌ی <span>۱۶۲</span></a></span>). Write a method called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">increment_login_attempts()</span><span class="rlm">‏</span> that increments the value of <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">login_attempts</span><span class="rlm">‏</span> by ۱. Write another method called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">reset_login_attempts()</span><span class="rlm">‏</span> that resets the value of <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">login_attempts</span><span class="rlm">‏</span> to ۰.
</p><p>
Make an instance of the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">User</span><span class="rlm">‏</span> class and call <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">increment_login_attempts()</span><span class="rlm">‏</span> several times. Print the value of <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">login_attempts</span><span class="rlm">‏</span> to make sure it was incremented properly, and then call <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">reset_login_attempts()</span><span class="rlm">‏</span>. Print <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">login_attempts</span><span class="rlm">‏</span> again to make sure it was reset to ۰.
</p></div></div></div></div><div class="sect" id="ch09lev1sec3"><h3>Inheritance</h3>
<p class="noindent">
You don’t always have to start from scratch when writing a class. If the class you’re writing is a specialized version of another class you wrote, you can use <span class="emphasis">inheritance</span>. When one class <span class="emphasis">inherits</span> from another, it takes on the attributes and methods of the first class. The original class is called the <span class="emphasis">parent class</span>, and the new class is the <span class="emphasis">child class</span>. The child class can inherit any or all of the attributes and methods of its parent class, but it’s also free to define new attributes and methods of its own.
</p><div class="sect" id="ch09lev2sec6"><h4>The __init__() Method for a Child Class</h4>
<p class="noindent">
When you’re writing a new class based on an existing class, you’ll often want to call the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span> method from the parent class. This will initialize any attributes that were defined in the parent <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span> method and make them available in the child class.
</p><p>
As an example, let’s model an electric car. An electric car is just a specific kind of car, so we can base our new <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> class on the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> class we wrote earlier. Then we’ll only have to write code for the attributes and behavior specific to electric cars.
</p><a id="p168"></a><p>
Let’s start by making a simple version of the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> class, which does everything the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> class does:
</p><div class="snippet-title" dir="ltr">electric_car.py</div><pre class="snippet" dir="ltr"><span class="n" dir="ltr">1</span><span class="ash">class Car:</span>
    <span class="ash">"""A simple attempt to represent a car."""</span>

    <span class="ash">def __init__(self, make, model, year):</span>
        <span class="ash">self.make = make</span>
        <span class="ash">self.model = model</span>
        <span class="ash">self.year = year</span>
        <span class="ash">self.odometer_reading = 0</span>

    <span class="ash">def get_descriptive_name(self):</span>
        <span class="ash">long_name = f"{self.year} {self.manufacturer} {self.model}"</span>
        <span class="ash">return long_name.title()</span>

    <span class="ash">def read_odometer(self):</span>
        <span class="ash">print(f"This car has {self.odometer_reading} miles on it.")</span>

    <span class="ash">def update_odometer(self, mileage):</span>
        <span class="ash">if mileage &gt;= self.odometer_reading:</span>
            <span class="ash">self.odometer_reading = mileage</span>
        <span class="ash">else:</span>
            <span class="ash">print("You can't roll back an odometer!")</span>

    <span class="ash">def increment_odometer(self, miles):</span>
        <span class="ash">self.odometer_reading += miles</span>

<span class="n" dir="ltr">2</span>class ElectricCar(Car):
    """Represent aspects of a car, specific to electric vehicles."""

<span class="n" dir="ltr">3</span>    def __init__(self, make, model, year):
        """Initialize attributes of the parent class."""
<span class="n" dir="ltr">4</span>        super().__init__(make, model, year)

<span class="n" dir="ltr">5</span>my_tesla = ElectricCar('tesla', 'model s', 2019)
print(my_tesla.get_descriptive_name())</pre><p>
At <span class="n" dir="ltr">1</span> we start with <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span>. When you create a child class, the parent class must be part of the current file and must appear before the child class in the file. At <span class="n" dir="ltr">2</span> we define the child class, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span>. The name of the parent class must be included in parentheses in the definition of a child class. The <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span> method at <span class="n" dir="ltr">3</span> takes in the information required to make a <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> instance.
</p><p>
The <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">super()</span><span class="rlm">‏</span> function at <span class="n" dir="ltr">4</span> is a special function that allows you to call a method from the parent class. This line tells Python to call the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span> method from <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span>, which gives an <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> instance all the attributes defined in that method. The name <span class="emphasis">super</span> comes from a convention of calling the parent class a <span class="emphasis">superclass</span> and the child class a <span class="emphasis">subclass</span>.
</p><a id="p169"></a><p>
We test whether inheritance is working properly by trying to create an electric car with the same kind of information we’d provide when making a regular car. At <span class="n" dir="ltr">5</span> we make an instance of the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> class and assign it to <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">my_tesla</span><span class="rlm">‏</span>. This line calls the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span> method defined in <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span>, which in turn tells Python to call the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span> method defined in the parent class <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span>. We provide the arguments <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'tesla'</span><span class="rlm">‏</span>, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">'model s'</span><span class="rlm">‏</span>, and <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">2019</span><span class="rlm">‏</span>.
</p><p>
Aside from <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span>, there are no attributes or methods yet that are particular to an electric car. At this point we’re just making sure the electric car has the appropriate <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> behaviors:
</p><pre class="snippet" dir="ltr">2019 Tesla Model S</pre><p>
The <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> instance works just like an instance of <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span>, so now we can begin defining attributes and methods specific to electric cars.
</p></div><div class="sect" id="ch09lev2sec7"><h4>Defining Attributes and Methods for the Child Class</h4>
<p class="noindent">
Once you have a child class that inherits from a parent class, you can add any new attributes and methods necessary to differentiate the child class from the parent class.</p><p>
Let’s add an attribute that’s specific to electric cars (a battery, for example) and a method to report on this attribute. We’ll store the battery size and write a method that prints a description of the battery:</p><pre class="snippet" dir="ltr"><span class="ash">class Car:</span>
    <span class="ash">--<span class="it">snip</span>--</span>

<span class="ash">class ElectricCar(Car):</span>
    <span class="ash">"""Represent aspects of a car, specific to electric vehicles."""</span>

    <span class="ash">def __init__(self, make, model, year):</span>
        """
        Initialize attributes of the parent class.
        Then initialize attributes specific to an electric car.
        """
        <span class="ash">super().__init__(make, model, year)</span>

        self.battery_size = 75

<span class="n" dir="ltr">2</span>    def describe_battery(self):
        """Print a statement describing the battery size."""
        print(f"This car has a {self.battery_size}-kWh battery.")

<span class="ash">my_tesla = ElectricCar('tesla', 'model s', 2019)</span>
<span class="ash">print(my_tesla.get_descriptive_name())</span>
my_tesla.describe_battery()</pre><p>
At <span class="n" dir="ltr">1</span> we add a new attribute <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self.battery_size</span><span class="rlm">‏</span> and set its initial value to, say, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">75</span><span class="rlm">‏</span>. This attribute will be associated with all instances created from the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> class but won’t be associated with any instances of <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span>. We also <a id="p170"></a>add a method called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">describe_battery()</span><span class="rlm">‏</span> that prints information about the battery at <span class="n" dir="ltr">2</span>. When we call this method, we get a description that is clearly specific to an electric car:
</p><pre class="snippet" dir="ltr">2019 Tesla Model S
This car has a 75-kWh battery.</pre><p>
There’s no limit to how much you can specialize the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> class. You can add as many attributes and methods as you need to model an electric car to whatever degree of accuracy you need. An attribute or method that could belong to any car, rather than one that’s specific to an electric car, should be added to the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> class instead of the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> class. Then anyone who uses the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> class will have that functionality available as well, and the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> class will only contain code for the information and behavior specific to electric vehicles.
</p></div><div class="sect" id="ch09lev2sec8"><h4>Overriding Methods from the Parent Class</h4>
<p class="noindent">
You can override any method from the parent class that doesn’t fit what you’re trying to model with the child class. To do this, you define a method in the child class with the same name as the method you want to override in the parent class. Python will disregard the parent class method and only pay attention to the method you define in the child class.</p><p>
Say the class <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> had a method called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">fill_gas_tank()</span><span class="rlm">‏</span>. This method is meaningless for an all-electric vehicle, so you might want to override this method. Here’s one way to do that:
</p><pre class="snippet" dir="ltr">class ElectricCar(Car):
    <span class="ash">--<span class="it">snip</span>--</span>

    def fill_gas_tank(self):
        """Electric cars don't have gas tanks."""
        print("This car doesn't need a gas tank!")</pre><p>
Now if someone tries to call <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">fill_gas_tank()</span><span class="rlm">‏</span> with an electric car, Python will ignore the method <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">fill_gas_tank()</span><span class="rlm">‏</span> in <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> and run this code instead. When you use inheritance, you can make your child classes retain what you need and override anything you don’t need from the parent class.
</p></div><div class="sect" id="ch09lev2sec9"><h4>Instances as Attributes</h4>
<p class="noindent">
When modeling something from the real world in code, you may find that you’re adding more and more detail to a class. You’ll find that you have a growing list of attributes and methods and that your files are becoming lengthy. In these situations, you might recognize that part of one class can be written as a separate class. You can break your large class into smaller classes that work together.</p><p>
For example, if we continue adding detail to the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> class, we might notice that we’re adding many attributes and methods specific to <a id="p171"></a> the car’s battery. When we see this happening, we can stop and move those attributes and methods to a separate class called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Battery</span><span class="rlm">‏</span>. Then we can use a <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Battery</span><span class="rlm">‏</span> instance as an attribute in the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> class:
</p><pre class="snippet" dir="ltr"><span class="ash">class Car:</span>
    <span class="ash">--<span class="it">snip</span>--</span>

<span class="n" dir="ltr">1</span>class Battery:
    """A simple attempt to model a battery for an electric car."""

<span class="n" dir="ltr">2</span>    def __init__(self, battery_size=75):
        """Initialize the battery's attributes."""
        self.battery_size = battery_size

<span class="n" dir="ltr">3</span>    def describe_battery(self):
        """Print a statement describing the battery size."""
        print(f"This car has a {self.battery_size}-kWh battery.")


<span class="ash">class ElectricCar(Car):</span>
    <span class="ash">"""Represent aspects of a car, specific to electric vehicles."""</span>

    <span class="ash">def __init__(self, make, model, year):</span>
        <span class="ash">"""</span>
        <span class="ash">Initialize attributes of the parent class.</span>
        <span class="ash">Then initialize attributes specific to an electric car.</span>
        <span class="ash">"""</span>
        <span class="ash">super().__init__(make, model, year)</span>
<span class="n" dir="ltr">4</span>        self.battery = Battery()


<span class="ash">my_tesla = ElectricCar('tesla', 'model s', 2019)</span>

<span class="ash">print(my_tesla.get_descriptive_name())</span>
my_tesla.battery.describe_battery()</pre><p>
At <span class="n" dir="ltr">1</span> we define a new class called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Battery</span><span class="rlm">‏</span> that doesn’t inherit from any other class. The <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span> method at <span class="n" dir="ltr">2</span> has one parameter, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">battery_size</span><span class="rlm">‏</span>, in addition to <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self</span><span class="rlm">‏</span>. This is an optional parameter that sets the battery’s size to ۷۵ if no value is provided. The method <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">describe_battery()</span><span class="rlm">‏</span> has been moved to this class as well <span class="n" dir="ltr">3</span>.
</p><p>
In the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> class, we now add an attribute called self.battery <span class="n" dir="ltr">4</span>. This line tells Python to create a new instance of <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Battery</span><span class="rlm">‏</span> (with a default size of ۷۵, because we’re not specifying a value) and assign that instance to the attribute <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">self.battery</span><span class="rlm">‏</span>. This will happen every time the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span> method is called; any <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> instance will now have a <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Battery</span><span class="rlm">‏</span> instance created automatically.
</p><p>
We create an electric car and assign it to the variable <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">my_tesla</span><span class="rlm">‏</span>. When we want to describe the battery, we need to work through the car’s <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">battery</span><span class="rlm">‏</span> attribute:
</p><pre class="snippet" dir="ltr">my_tesla.battery.describe_battery()</pre><a id="p172"></a><p>
This line tells Python to look at the instance <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">my_tesla</span><span class="rlm">‏</span>, find its <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">battery</span><span class="rlm">‏</span> attribute, and call the method <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">describe_battery()</span><span class="rlm">‏</span> that’s associated with the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Battery</span><span class="rlm">‏</span> instance stored in the attribute.
</p><p>
The output is identical to what we saw previously:</p><pre class="snippet" dir="ltr">2019 Tesla Model S
This car has a 75-kWh battery.</pre><p>
This looks like a lot of extra work, but now we can describe the battery in as much detail as we want without cluttering the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> class. Let’s add another method to <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Battery</span><span class="rlm">‏</span> that reports the range of the car based on the battery size:
</p><pre class="snippet" dir="ltr"><span class="ash">class Car:</span>
    <span class="ash">--<span class="it">snip</span>--</span>

<span class="ash">class Battery:</span>
    <span class="ash">--<span class="it">snip</span>--</span>

<span class="n" dir="ltr">1</span>    def get_range(self):
        """Print a statement about the range this battery provides."""
        if self.battery_size == 75:
            range = 260
        elif self.battery_size == 100:
            range = 315

        print(f"This car can go about {range} miles on a full charge.")

<span class="ash">class ElectricCar(Car):</span>
    <span class="ash">--<span class="it">snip</span>--</span>

<span class="ash">my_tesla = ElectricCar('tesla', 'model s', 2019)</span>
<span class="ash">print(my_tesla.get_descriptive_name())</span>
<span class="ash">my_tesla.battery.describe_battery()</span>
<span class="n" dir="ltr">2</span>my_tesla.battery.get_range()</pre><p>
The new method <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">get_range()</span><span class="rlm">‏</span> at <span class="n" dir="ltr">1</span> performs some simple analysis. If the battery’s capacity is ۷۵ kWh, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">get_range()</span><span class="rlm">‏</span> sets the range to ۲۶۰ miles, and if the capacity is ۱۰۰ kWh, it sets the range to ۳۱۵ miles. It then reports this value. When we want to use this method, we again have to call it through the car’s <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">battery</span><span class="rlm">‏</span> attribute at <span class="n" dir="ltr">2</span>.
</p><p>
The output tells us the range of the car based on its battery size:</p><pre class="snippet" dir="ltr">2019 Tesla Model S
This car has a 75-kWh battery.
This car can go about 260 miles on a full charge.</pre></div><div class="sect" id="ch09lev2sec10"><h4>Modeling Real-World Objects</h4>
<a id="p173"></a><p class="noindent">
As you begin to model more complicated things like electric cars, you’ll wrestle with interesting questions. Is the range of an electric car a property of the battery or of the car? If we’re only describing one car, it’s probably fine to maintain the association of the method <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">get_range()</span><span class="rlm">‏</span> with the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Battery</span><span class="rlm">‏</span> class. But if we’re describing a manufacturer’s entire line of cars, we probably want to move <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">get_range()</span><span class="rlm">‏</span> to the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> class. The <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">get_range()</span><span class="rlm">‏</span> method would still check the battery size before determining the range, but it would report a range specific to the kind of car it’s associated with. Alternatively, we could maintain the association of the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">get_range()</span><span class="rlm">‏</span> method with the battery but pass it a parameter such as <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">car_model</span><span class="rlm">‏</span>. The <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">get_range()</span><span class="rlm">‏</span> method would then report a range based on the battery size and car model.
</p><p>
This brings you to an interesting point in your growth as a programmer. When you wrestle with questions like these, you’re thinking at a higher logical level rather than a syntax-focused level. You’re thinking not about Python, but about how to represent the real world in code. When you reach this point, you’ll realize there are often no right or wrong approaches to modeling real-world situations. Some approaches are more efficient than others, but it takes practice to find the most efficient representations. If your code is working as you want it to, you’re doing well! Don’t be discouraged if you find you’re ripping apart your classes and rewriting them several times using different approaches. In the quest to write accurate, efficient code, everyone goes through this process.</p><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<a id="p174"></a><p class="tiy1"><span class="tiy" id="ch009_tiy006"><span class="tiy-num">۹-۶</span>. <span class="tiy-title">۹-۶. Ice Cream Stand:</span>: </span>
An ice cream stand is a specific kind of restaurant. Write a class called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">IceCreamStand</span><span class="rlm">‏</span> that inherits from the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Restaurant</span><span class="rlm">‏</span> class you wrote in <span class="ref"><a href="c20-ch09.xhtml#ch009_tiy001">تمرین <span dir="ltr">۹-۱</span></a></span> (<span class="ref"><a href="c20-ch09.xhtml#p162">صفحه‌ی <span>۱۶۲</span></a></span>) or <span class="ref"><a href="c20-ch09.xhtml#ch009_tiy004">تمرین <span dir="ltr">۹-۴</span></a></span> (<span class="ref"><a href="c20-ch09.xhtml#p167">صفحه‌ی <span>۱۶۷</span></a></span>). Either version of the class will work; just pick the one you like better. Add an attribute called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">flavors</span><span class="rlm">‏</span> that stores a list of ice cream flavors. Write a method that displays these flavors. Create an instance of <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">IceCreamStand</span><span class="rlm">‏</span>, and call this method.
</p><p class="tiy1"><span class="tiy" id="ch009_tiy007"><span class="tiy-num">۹-۷</span>. <span class="tiy-title">۹-۷. Admin:</span>: </span>
An administrator is a special kind of user. Write a class called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Admin</span><span class="rlm">‏</span> that inherits from the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">User</span><span class="rlm">‏</span> class you wrote in <span class="ref"><a href="c20-ch09.xhtml#ch009_tiy003">تمرین <span dir="ltr">۹-۳</span></a></span> (<span class="ref"><a href="c20-ch09.xhtml#p162">صفحه‌ی <span>۱۶۲</span></a></span>) or <span class="ref"><a href="c20-ch09.xhtml#ch009_tiy005">تمرین <span dir="ltr">۹-۵</span></a></span> (<span class="ref"><a href="c20-ch09.xhtml#p167">صفحه‌ی <span>۱۶۷</span></a></span>). Add an attribute, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">privileges</span><span class="rlm">‏</span>, that stores a list of strings like <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">"can add post"</span><span class="rlm">‏</span>, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">"can delete post"</span><span class="rlm">‏</span>, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">"can ban user"</span><span class="rlm">‏</span>, and so on. Write a method called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">show_privileges()</span><span class="rlm">‏</span> that lists the administrator’s set of privileges. Create an instance of <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Admin</span><span class="rlm">‏</span>, and call your method.
</p><p class="tiy1"><span class="tiy" id="ch009_tiy008"><span class="tiy-num">۹-۸</span>. <span class="tiy-title">۹-۸. Privileges:</span>: </span>
Write a separate <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Privileges</span><span class="rlm">‏</span> class. The class should have one attribute, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">privileges</span><span class="rlm">‏</span>, that stores a list of strings as described in <span class="ref"><a href="c20-ch09.xhtml#ch009_tiy007">تمرین <span dir="ltr">۹-۷</span></a></span>. Move the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">show_privileges()</span><span class="rlm">‏</span> method to this class. Make a <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Privileges</span><span class="rlm">‏</span> instance as an attribute in the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Admin</span><span class="rlm">‏</span> class. Create a new instance of <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Admin</span><span class="rlm">‏</span> and use your method to show its privileges.
</p><p class="tiy1"><span class="tiy" id="ch009_tiy009"><span class="tiy-num">۹-۹</span>. <span class="tiy-title">۹-۹. Battery Upgrade:</span>: </span>
Use the final version of <span class="emphasis">electric_car.py</span> from this section. Add a method to the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Battery</span><span class="rlm">‏</span> class called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">upgrade_battery()</span><span class="rlm">‏</span>. This method should check the battery size and set the capacity to ۱۰۰ if it isn’t already. Make an electric car with a default battery size, call <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">get_range()</span><span class="rlm">‏</span> once, and then call <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">get_range()</span><span class="rlm">‏</span> a second time after upgrading the battery. You should see an increase in the car’s range.
</p></div></div></div><div class="sect" id="ch09lev1sec4"><h3>Importing Classes</h3>
<p class="noindent">
As you add more functionality to your classes, your files can get long, even when you use inheritance properly. In keeping with the overall philosophy of Python, you’ll want to keep your files as uncluttered as possible. To help, Python lets you store classes in modules and then import the classes you need into your main program.</p><div class="sect" id="ch09lev2sec11"><h4>Importing a Single Class</h4>
<p class="noindent">
Let’s create a module containing just the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> class. This brings up a subtle naming issue: we already have a file named <span class="emphasis">car.py</span> in this chapter, but this module should be named <span class="emphasis">car.py</span> because it contains code representing a car. We’ll resolve this naming issue by storing the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> class in a module named <span class="emphasis">car.py</span>, replacing the <span class="emphasis">car.py</span> file we were previously using. From now on, any program that uses this module will need a more specific filename, such as <span class="emphasis">my_car.py</span>. Here’s <span class="emphasis">car.py</span> with just the code from the class <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span>:
</p><div class="snippet-title" dir="ltr">car.py</div><pre class="snippet" dir="ltr"><span class="n" dir="ltr">1</span>"""A class that can be used to represent a car."""

<span class="ash">class Car:</span>
    <span class="ash">"""A simple attempt to represent a car."""</span>

    <span class="ash">def __init__(self, make, model, year):</span>
        <span class="ash">"""Initialize attributes to describe a car."""</span>
        <span class="ash">self.make = make</span>
        <span class="ash">self.model = model</span>
        <span class="ash">self.year = year</span>
        <span class="ash">self.odometer_reading = 0</span>

    <span class="ash">def get_descriptive_name(self):</span>
        <span class="ash">"""Return a neatly formatted descriptive name."""</span>
        <span class="ash">long_name = f"{self.year} {self.manufacturer} {self.model}"</span>
        <span class="ash">return long_name.title()</span>

    <span class="ash">def read_odometer(self):</span>
        <span class="ash">"""Print a statement showing the car's mileage."""</span>
        <span class="ash">print(f"This car has {self.odometer_reading} miles on it.")</span>

<a id="p175"></a>    <span class="ash">def update_odometer(self, mileage):</span>
        <span class="ash">"""</span>
        <span class="ash">Set the odometer reading to the given value.</span>
<br xmlns="urn:dox:pycc"></br>        <span class="ash">Reject the change if it attempts to roll the odometer back.</span>
        <span class="ash">"""</span>
        <span class="ash">if mileage &gt;= self.odometer_reading:</span>
            <span class="ash">self.odometer_reading = mileage</span>
        <span class="ash">else:</span>
            <span class="ash">print("You can't roll back an odometer!")</span>

    <span class="ash">def increment_odometer(self, miles):</span>
        <span class="ash">"""Add the given amount to the odometer reading."""</span>
        <span class="ash">self.odometer_reading += miles</span></pre><p>
At <span class="n" dir="ltr">1</span> we include a module-level docstring that briefly describes the contents of this module. You should write a docstring for each module you create.
</p><p>
Now we make a separate file called <span class="emphasis">my_car.py</span>. This file will import the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> class and then create an instance from that class:
</p><div class="snippet-title" dir="ltr">my_car.py</div><pre class="snippet" dir="ltr"><span class="n" dir="ltr">1</span>from car import Car

my_new_car = Car('audi', 'a4', 2019)
print(my_new_car.get_descriptive_name())

my_new_car.odometer_reading = 23
my_new_car.read_odometer()</pre><p>
The <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">import</span><span class="rlm">‏</span> statement at <span class="n" dir="ltr">1</span> tells Python to open the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">car</span><span class="rlm">‏</span> module and import the class <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span>. Now we can use the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> class as if it were defined in this file. The output is the same as we saw earlier:
</p><pre class="snippet" dir="ltr">2019 Audi A4
This car has 23 miles on it.</pre><p>
Importing classes is an effective way to program. Picture how long this program file would be if the entire <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> class were included. When you instead move the class to a module and import the module, you still get all the same functionality, but you keep your main program file clean and easy to read. You also store most of the logic in separate files; once your classes work as you want them to, you can leave those files alone and focus on the higher-level logic of your main program.
</p></div><div class="sect" id="ch09lev2sec12"><h4>Storing Multiple Classes in a Module</h4>
<p class="noindent">
You can store as many classes as you need in a single module, although each class in a module should be related somehow. The classes <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Battery</span><span class="rlm">‏</span> and <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> both help represent cars, so let’s add them to the module <span class="emphasis">car.py</span>.
</p><a id="p176"></a><div class="snippet-title" dir="ltr">car.py</div><pre class="snippet" dir="ltr">"""A set of classes used to represent gas and electric cars."""

<span class="ash">class Car:</span>
    <span class="ash">--<span class="it">snip</span>--</span>

<span class="ash">class Battery:</span>
    <span class="ash">"""A simple attempt to model a battery for an electric car."""</span>

    <span class="ash">def __init__(self, battery_size=70):</span>
        <span class="ash">"""Initialize the battery's attributes."""</span>
        <span class="ash">self.battery_size = battery_size</span>

    <span class="ash">def describe_battery(self):</span>
        <span class="ash">"""Print a statement describing the battery size."""</span>
        <span class="ash">print(f"This car has a {self.battery_size}-kWh battery.")</span>


    <span class="ash">def get_range(self):</span>
        <span class="ash">"""Print a statement about the range this battery provides."""</span>
        <span class="ash">if self.battery_size == 75:</span>
            <span class="ash">range = 260</span>
        <span class="ash">elif self.battery_size == 100:</span>
            <span class="ash">range = 315</span>


        <span class="ash">print(f"This car can go about {range} miles on a full charge.")</span>

<span class="ash">class ElectricCar(Car):</span>
    <span class="ash">"""Models aspects of a car, specific to electric vehicles."""</span>

    <span class="ash">def __init__(self, make, model, year):</span>
        <span class="ash">"""</span>
        <span class="ash">Initialize attributes of the parent class.</span>
        <span class="ash">Then initialize attributes specific to an electric car.</span>
        <span class="ash">"""</span>
        <span class="ash">super().__init__(make, model, year)</span>
        <span class="ash">self.battery = Battery()</span></pre><p>
Now we can make a new file called <span class="emphasis">my_electric_car.py</span>, import the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> class, and make an electric car:
</p><div class="snippet-title" dir="ltr">my_electric_car.py</div><pre class="snippet" dir="ltr">from car import ElectricCar

my_tesla = ElectricCar('tesla', 'model s', 2019)

print(my_tesla.get_descriptive_name())
my_tesla.battery.describe_battery()
my_tesla.battery.get_range()</pre><p>
This has the same output we saw earlier, even though most of the logic is hidden away in a module:</p><pre class="snippet" dir="ltr">2019 Tesla Model S
This car has a 75-kWh battery.
This car can go about 260 miles on a full charge.</pre></div><div class="sect" id="ch09lev2sec13"><h4>Importing Multiple Classes from a Module</h4>
<a id="p177"></a><p class="noindent">
You can import as many classes as you need into a program file. If we want to make a regular car and an electric car in the same file, we need to import both classes, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> and <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span>:
</p><div class="snippet-title" dir="ltr">my_cars.py</div><pre class="snippet" dir="ltr"><span class="n" dir="ltr">1</span>from car import Car, ElectricCar

<span class="n" dir="ltr">2</span>my_beetle = Car('volkswagen', 'beetle', 2019)
print(my_beetle.get_descriptive_name())

<span class="n" dir="ltr">3</span>my_tesla = ElectricCar('tesla', 'roadster', 2019)
print(my_tesla.get_descriptive_name())</pre><p>
You import multiple classes from a module by separating each class with a comma <span class="n" dir="ltr">1</span>. Once you’ve imported the necessary classes, you’re free to make as many instances of each class as you need.
</p><p>
In this example we make a regular Volkswagen Beetle at <span class="n" dir="ltr">2</span> and an electric Tesla Roadster at <span class="n" dir="ltr">3</span>:
</p><pre class="snippet" dir="ltr">2019 Volkswagen Beetle
2019 Tesla Roadster</pre></div><div class="sect" id="ch09lev2sec14"><h4>Importing an Entire Module</h4>
<p class="noindent">
You can also import an entire module and then access the classes you need using dot notation. This approach is simple and results in code that is easy to read. Because every call that creates an instance of a class includes the module name, you won’t have naming conflicts with any names used in the current file.</p><p>
Here’s what it looks like to import the entire <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">car</span><span class="rlm">‏</span> module and then create a regular car and an electric car:
</p><div class="snippet-title" dir="ltr">my_cars.py</div><pre class="snippet" dir="ltr"><span class="n" dir="ltr">1</span>import car

<span class="n" dir="ltr">2</span>my_beetle = car.Car('volkswagen', 'beetle', 2019)
<span class="ash">print(my_beetle.get_descriptive_name())</span>

<span class="n" dir="ltr">3</span>my_tesla = car.ElectricCar('tesla', 'roadster', 2019)
<span class="ash">print(my_tesla.get_descriptive_name())</span></pre><p>
At <span class="n" dir="ltr">1</span> we import the entire <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">car</span><span class="rlm">‏</span> module. We then access the classes we need through the <span class="it">module_name.ClassName</span> syntax. At <span class="n" dir="ltr">2</span> we again create a Volkswagen Beetle, and at <span class="n" dir="ltr">3</span> we create a Tesla Roadster.
</p></div><div class="sect" id="ch09lev2sec15"><h4>Importing All Classes from a Module</h4>
<p class="noindent">
You can import every class from a module using the following syntax:</p><pre class="snippet" dir="ltr">from <span class="it">module_name</span> import *</pre><a id="p178"></a><p>
This method is not recommended for two reasons. First, it’s helpful to be able to read the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">import</span><span class="rlm">‏</span> statements at the top of a file and get a clear sense of which classes a program uses. With this approach it’s unclear which classes you’re using from the module. This approach can also lead to confusion with names in the file. If you accidentally import a class with the same name as something else in your program file, you can create errors that are hard to diagnose. I show this here because even though it’s not a recommended approach, you’re likely to see it in other people’s code at some point.
</p><p>
If you need to import many classes from a module, you’re better off importing the entire module and using the <span class="it">module_name.ClassName</span> syntax. You won’t see all the classes used at the top of the file, but you’ll see clearly where the module is used in the program. You’ll also avoid the potential naming conflicts that can arise when you import every class in a module.
</p></div><div class="sect" id="ch09lev2sec16"><h4>Importing a Module into a Module</h4>
<p class="noindent">
Sometimes you’ll want to spread out your classes over several modules to keep any one file from growing too large and avoid storing unrelated classes in the same module. When you store your classes in several modules, you may find that a class in one module depends on a class in another module. When this happens, you can import the required class into the first module.</p><p>
For example, let’s store the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> class in one module and the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> and <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Battery</span><span class="rlm">‏</span> classes in a separate module. We’ll make a new module called <span class="emphasis">electric_car.py</span> —replacing the <span class="emphasis">electric_car.py</span> file we created earlier—and copy just the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Battery</span><span class="rlm">‏</span> and <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> classes into this file:
</p><div class="snippet-title" dir="ltr">electric_car.py</div><pre class="snippet" dir="ltr">"""A set of classes that can be used to represent electric cars."""

<span class="n" dir="ltr">1</span>from car import Car

<span class="ash">class Battery:</span>
    <span class="ash">--<span class="it">snip</span>--</span>

<span class="ash">class ElectricCar(Car):</span>
    <span class="ash">--<span class="it">snip</span>--</span></pre><p>
The class <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> needs access to its parent class <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span>, so we import <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> directly into the module at <span class="n" dir="ltr">1</span>. If we forget this line, Python will raise an error when we try to import the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">electric_car</span><span class="rlm">‏</span> module. We also need to update the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> module so it contains only the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> class:
</p><div class="snippet-title" dir="ltr">car.py</div><pre class="snippet" dir="ltr">"""A class that can be used to represent a car."""

<span class="ash">class Car:</span>
    <span class="ash">--<span class="it">snip</span>--</span></pre><a id="p179"></a><p>
Now we can import from each module separately and create whatever kind of car we need:
</p><div class="snippet-title" dir="ltr">my_cars.py</div><pre class="snippet" dir="ltr"><span class="n" dir="ltr">1</span>from car import Car
from electric_car import ElectricCar

my_beetle = Car('volkswagen', 'beetle', 2019)
print(my_beetle.get_descriptive_name())

my_tesla = ElectricCar('tesla', 'roadster', 2019)
print(my_tesla.get_descriptive_name())</pre><p>
At <span class="n" dir="ltr">1</span> we import <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Car</span><span class="rlm">‏</span> from its module, and <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> from its module. We then create one regular car and one electric car. Both kinds of cars are created correctly:
</p><pre class="snippet" dir="ltr">2019 Volkswagen Beetle
2019 Tesla Roadster</pre></div><div class="sect" id="ch09lev2sec17"><h4>Using Aliases</h4>
<p class="noindent">
As you saw in <span class="ref"><a href="c19-ch08.xhtml">فصل ۸</a></span>, aliases can be quite helpful when using modules to organize your projects’ code. You can use aliases when importing classes as well.
</p><p>
As an example, consider a program where you want to make a bunch of electric cars. It might get tedious to type (and read) <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> over and over again. You can give <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">ElectricCar</span><span class="rlm">‏</span> an alias in the import statement:
</p><pre class="snippet" dir="ltr">from electric_car import ElectricCar as EC</pre><p>
Now you can use this alias whenever you want to make an electric car:</p><pre class="snippet" dir="ltr">my_tesla = EC('tesla', 'roadster', 2019)</pre></div><div class="sect" id="ch09lev2sec18"><h4>Finding Your Own Workflow</h4>
<p class="noindent">
As you can see, Python gives you many options for how to structure code in a large project. It’s important to know all these possibilities so you can determine the best ways to organize your projects as well as understand other people’s projects.</p><p>
When you’re starting out, keep your code structure simple. Try doing everything in one file and moving your classes to separate modules once everything is working. If you like how modules and files interact, try storing your classes in modules when you start a project. Find an approach that lets you write code that works, and go from there.</p><a id="p180"></a><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<p class="tiy1"><span class="tiy" id="ch009_tiy010"><span class="tiy-num">۹-۱۰</span>. <span class="tiy-title">۹-۱۰. Imported Restaurant:</span>: </span>
Using your latest <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Restaurant</span><span class="rlm">‏</span> class, store it in a module. Make a separate file that imports <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Restaurant</span><span class="rlm">‏</span>. Make a <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Restaurant</span><span class="rlm">‏</span> instance, and call one of <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Restaurant</span><span class="rlm">‏</span> ’s methods to show that the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">import</span><span class="rlm">‏</span> statement is working properly.
</p><p class="tiy1"><span class="tiy" id="ch009_tiy011"><span class="tiy-num">۹-۱۱</span>. <span class="tiy-title">۹-۱۱. Imported Admin:</span>: </span>
Start with your work from <span class="ref"><a href="c20-ch09.xhtml#ch009_tiy008">تمرین <span dir="ltr">۹-۸</span></a></span> (<span class="ref"><a href="c20-ch09.xhtml#p173">صفحه‌ی <span>۱۷۳</span></a></span>). Store the classes <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">User</span><span class="rlm">‏</span>, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Privileges</span><span class="rlm">‏</span>, and <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Admin</span><span class="rlm">‏</span> in one module. Create a separate file, make an <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Admin</span><span class="rlm">‏</span> instance, and call <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">show_privileges()</span><span class="rlm">‏</span> to show that everything is working correctly.
</p><p class="tiy1"><span class="tiy" id="ch009_tiy012"><span class="tiy-num">۹-۱۲</span>. <span class="tiy-title">۹-۱۲. Multiple Modules:</span>: </span>
Store the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">User</span><span class="rlm">‏</span> class in one module, and store the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Privileges</span><span class="rlm">‏</span> and <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Admin</span><span class="rlm">‏</span> classes in a separate module. In a separate file, create an <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Admin</span><span class="rlm">‏</span> instance and call <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">show_privileges()</span><span class="rlm">‏</span> to show that everything is still working correctly.
</p></div></div></div><div class="sect" id="ch09lev1sec5"><h3>The Python Standard Library</h3>
<p class="noindent">
The <span class="emphasis">Python standard library</span> is a set of modules included with every Python installation. Now that you have a basic understanding of how functions and classes work, you can start to use modules like these that other programmers have written. You can use any function or class in the standard library by including a simple <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">import</span><span class="rlm">‏</span> statement at the top of your file. Let’s look at one module, <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">random</span><span class="rlm">‏</span>, which can be useful in modeling many real-world situations.
</p><p>
One interesting function from the random module is <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">randint()</span><span class="rlm">‏</span>. This function takes two integer arguments and returns a randomly selected integer between (and including) those numbers.
</p><p>
Here’s how to generate a random number between ۱ and ۶:</p><pre class="snippet" dir="ltr">&gt;&gt;&gt; <span class="rlm">‏</span><span class="codestrong" dir="ltr">from random import randint</span><span class="rlm">‏</span>
&gt;&gt;&gt; <span class="rlm">‏</span><span class="codestrong" dir="ltr">randint(1, 6)</span><span class="rlm">‏</span>
3</pre><p>
Another useful function is <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">choice()</span><span class="rlm">‏</span>. This function takes in a list or tuple and returns a randomly chosen element:
</p><pre class="snippet" dir="ltr">&gt;&gt;&gt; <span class="rlm">‏</span><span class="codestrong" dir="ltr">from random import choice</span><span class="rlm">‏</span>
&gt;&gt;&gt; <span class="rlm">‏</span><span class="codestrong" dir="ltr">players = ['charles', 'martina', 'michael', 'florence', 'eli']</span><span class="rlm">‏</span>
&gt;&gt;&gt; <span class="rlm">‏</span><span class="codestrong" dir="ltr">first_up = choice(players)</span><span class="rlm">‏</span>
&gt;&gt;&gt; <span class="rlm">‏</span><span class="codestrong" dir="ltr">first_up</span><span class="rlm">‏</span>
'florence'</pre><a id="p181"></a><p>
The <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">random</span><span class="rlm">‏</span> module shouldn’t be used when building security-related applications, but it’s good enough for many fun and interesting projects.
</p><div class="note"><h6 class="note-title">توجه</h6>
<p class="noindent">
You can also download modules from external sources. You’ll see a number of these examples in <span class="ref"><a href="c23-p2.xhtml">بخش ۲</a></span>, where we’ll need external modules to complete each project.
</p></div><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<p class="tiy1"><span class="tiy" id="ch009_tiy013"><span class="tiy-num">۹-۱۳</span>. <span class="tiy-title">۹-۱۳. Dice:</span>: </span>
Make a class <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">Die</span><span class="rlm">‏</span> with one attribute called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">sides</span><span class="rlm">‏</span>, which has a default value of ۶. Write a method called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">roll_die()</span><span class="rlm">‏</span> that prints a random number between ۱ and the number of sides the die has. Make a ۶-sided die and roll it ۱۰ times.
</p><p>
Make a ۱۰-sided die and a ۲۰-sided die. Roll each die ۱۰ times.</p><p class="tiy1"><span class="tiy" id="ch009_tiy014"><span class="tiy-num">۹-۱۴</span>. <span class="tiy-title">۹-۱۴. Lottery:</span>: </span>
Make a list or tuple containing a series of ۱۰ numbers and five letters. Randomly select four numbers or letters from the list and print a message saying that any ticket matching these four numbers or letters wins a prize.
</p><p class="tiy1"><span class="tiy" id="ch009_tiy015"><span class="tiy-num">۹-۱۵</span>. <span class="tiy-title">۹-۱۵. Lottery Analysis:</span>: </span>
You can use a loop to see how hard it might be to win the kind of lottery you just modeled. Make a list or tuple called <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">my_ticket</span><span class="rlm">‏</span>. Write a loop that keeps pulling numbers until your ticket wins. Print a message reporting how many times the loop had to run to give you a winning ticket.
</p><p class="tiy1"><span class="tiy" id="ch009_tiy016"><span class="tiy-num">۹-۱۶</span>. <span class="tiy-title">۹-۱۶. Python Module of the Week:</span>: </span>
One excellent resource for exploring the Python standard library is a site called <span class="emphasis">Python Module of the Week</span>. Go to <span class="rlm">‏</span><a dir="ltr" target="_blank" href="https://pymotw.com/">https://pymotw.com/</a><span class="rlm">‏</span> and look at the table of contents. Find a module that looks interesting to you and read about it, perhaps starting with the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">random</span><span class="rlm">‏</span> module.
</p></div></div><div class="sect" id="ch09lev1sec6"><h3>Styling Classes</h3>
<p class="noindent">
A few styling issues related to classes are worth clarifying, especially as your programs become more complicated.</p><p>
Class names should be written in <span class="emphasis">CamelCase</span>. To do this, capitalize the first letter of each word in the name, and don’t use underscores. Instance and module names should be written in lowercase with underscores between words.
</p><p>
Every class should have a docstring immediately following the class definition. The docstring should be a brief description of what the class does, and you should follow the same formatting conventions you used for writing docstrings in functions. Each module should also have a docstring describing what the classes in a module can be used for.</p><p>
You can use blank lines to organize code, but don’t use them excessively. Within a class you can use one blank line between methods, and within a module you can use two blank lines to separate classes.</p><a id="p182"></a><p>
If you need to import a module from the standard library and a module that you wrote, place the import statement for the standard library module first. Then add a blank line and the import statement for the module you wrote. In programs with multiple import statements, this convention makes it easier to see where the different modules used in the program come from.
</p></div><div class="sect" id="ch09lev1sec7"><h3>Summary</h3>
<p class="noindent">
In this chapter you learned how to write your own classes. You learned how to store information in a class using attributes and how to write methods that give your classes the behavior they need. You learned to write <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">__init__()</span><span class="rlm">‏</span> methods that create instances from your classes with exactly the attributes you want. You saw how to modify the attributes of an instance directly and through methods. You learned that inheritance can simplify the creation of classes that are related to each other, and you learned to use instances of one class as attributes in another class to keep each class simple.
</p><p>
You saw how storing classes in modules and importing classes you need into the files where they’ll be used can keep your projects organized. You started learning about the Python standard library, and you saw an example based on the <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction: ltr;">random</span><span class="rlm">‏</span> module. Finally, you learned to style your classes using Python conventions.
</p><p>
In <span class="ref"><a href="c21-ch10.xhtml">فصل ۱۰</a></span> you’ll learn to work with files so you can save the work you’ve done in a program and the work you’ve allowed users to do. You’ll also learn about <span class="emphasis">exceptions</span>, a special Python class designed to help you respond to errors when they arise.
</p></div></article>
				<div class="row pager"><div class="col-md-5 text-center text-md-left pager-prev"><a href="c19-ch08.xhtml"><span xmlns="http://www.w3.org/1999/xhtml"><span>فصل ۸</span>: <span>تابع</span></span></a></div><div class="col-md-2 text-center pager-title"><a href="c01-cover.xhtml">آغاز</a></div><div class="col-md-5 text-center text-md-right pager-next"><a href="c21-ch10.xhtml"><span xmlns="http://www.w3.org/1999/xhtml"><span>فصل ۱۰</span>: <span>فایل‌ها و استثناها</span></span></a></div></div></main><aside class="col-md-2 order-md-first"><ul class="nav nav-pills flex-column"><li class="nav-item"><a class="nav-link" href="../">دوره‌ی فشرده‌ی پایتون</a></li><li class="nav-item"><a class="nav-link" href="c06-toc.xhtml">فهرست</a></li></ul></aside></div></div><div class="container"><div id="footer" class="row"><div class="col-sm-6"><p><span>© ۱۴۰۰، قاسم کیانی مقدم.</span></p></div><div class="col-sm-6"><p class="text-right"><span><a target="_blank" rel="me" href="https://linkedin.com/in/ghasemkiani" title="لینکدین"><span class="fab fa-linkedin"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://github.com/ghasemkiani" title="گیت‌هاب"><span class="fab fa-github"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://twitter.com/ghasemkiani" title="توئیتر"><span class="fab fa-twitter"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://facebook.com/ghasemkiani" title="فیس‌بوک"><span class="fab fa-facebook"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://telegram.me/ghasemkiani" title="تلگرام"><span class="fab fa-telegram"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://instagram.com/ghasem.kiani" title="اینستاگرام"><span class="fab fa-instagram"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://mastodon.social/@ghasemkiani" title="ماستودون"><span class="fab fa-mastodon"></span></a></span></p></div></div></div><script crossorigin="anonymous" src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"></script><script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut"></script><script crossorigin="anonymous" src="https://cdn.rtlcss.com/bootstrap/v4.0.0/js/bootstrap.min.js" integrity="sha384-54+cucJ4QbVb99v8dcttx/0JRx4FHMmhOWi4W+xrXpKcsKQodCBwAvu3xxkZAwsH"></script><script src="https://www.googletagmanager.com/gtag/js?id=UA-135468998-1"></script><script src="data:application/javascript;charset=UTF-8;base64,KCh7aWR9KSA9PiB7Cgl3aW5kb3cuZGF0YUxheWVyID0gd2luZG93LmRhdGFMYXllciB8fCBbXTsKCWZ1bmN0aW9uIGd0YWcoKXtkYXRhTGF5ZXIucHVzaChhcmd1bWVudHMpO30KCWd0YWcoImpzIiwgbmV3IERhdGUoKSk7CgoJZ3RhZygiY29uZmlnIiwgaWQpOwp9KSh7ImlkIjoiVUEtMTM1NDY4OTk4LTEifSk7Cg=="></script></body></html>