<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="fa" dir="rtl"><head><meta charset="utf-8"/><title>سفینه‌ای که گلوله شلیک می‌کند</title><meta name="description" content="وب‌سایت قاسم کیانی مقدم"/><meta name="keywords" content="قاسم کیانی مقدم, وب‌سایت, وب‌سایت قاسم کیانی مقدم, کتاب, فارسی, کتاب فارسی, ترجمه, برنامه‌نویسی, جاوا, جاوا اسکریپت, پزشکی, طب اطفال"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="stylesheet" crossorigin="anonymous" href="https://cdn.rtlcss.com/bootstrap/v4.0.0/css/bootstrap.min.css" integrity="sha384-P4uhUIGk/q1gaD/NdgkBIl3a6QywJjlsFJFk7SPRdruoGddvRVSwv5qFnvZ73cpz"/><link rel="stylesheet" crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.7.1/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr"/><link rel="icon" href="../../../favicon.ico"/><style>@import url(https://fonts.googleapis.com/css?family=Droid%20Sans);
@import url(https://fonts.googleapis.com/css?family=Droid%20Serif);
@import url(https://fonts.googleapis.com/css?family=Droid%20Arabic%20Kufi);
@import url(https://fonts.googleapis.com/css?family=Droid%20Arabic%20Naskh);
html,body,input,textarea,select,option,h1,h2,h3,h4,h5,h6{font-family:Droid Arabic Naskh,Droid Serif;}
nav,.nav{font-family:Droid Arabic Kufi,Droid Sans;}
h1,h2,h3,h4,h5,h6{font-family:Droid Arabic Naskh,Droid Serif;}
#footer{margin-top:0.5rem;padding-top:0.5rem;border-top:#eeeeee solid thick;}</style><style>@import url(https://fonts.googleapis.com/css?family=Courier+Prime);
div.row.pager{margin-top:0.5em;padding:0.5em 0;border-top:solid #cccccc 2px;background-color:#dddddd;}
div.pager-prev{}
div.pager-title{}
div.pager-next{}</style><link rel="stylesheet" type="text/css" href="styles.css"/></head><body style="min-height:75rem;"><nav class="navbar navbar-expand-md navbar-dark bg-dark mb-4"><div class="container"><a class="navbar-brand" href="../../../">وب‌سایت قاسم کیانی مقدم</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#divNavBarToggle" aria-controls="divNavBarToggle" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div id="divNavBarToggle" class="collapse navbar-collapse"><ul class="navbar-nav mr-auto"><li class="nav-item active"><a class="nav-link" href="../../">کتاب‌ها<span class="sr-only"> (current)</span></a></li><li class="nav-item"><a class="nav-link" href="../../../essays/">مقالات</a></li><li class="nav-item"><a class="nav-link" href="../../../translation/">ترجمه</a></li><li class="nav-item"><a class="nav-link" href="../../../about/">درباره</a></li><li class="nav-item"><a class="nav-link" href="../../../contact/">تماس</a></li></ul></div></div></nav><div class="container"><div class="row"><main class="col-md-10 order-md-last">
							<div class="ch" id="ch12"><h2 class="ch-title"><a class="bkmk" name="ch12"></a><a class="rtoc" href="c06-toc.xhtml"><span class="ch-title-num">۱۲</span><br/><span class="ch-title-text">سفینه‌ای که گلوله شلیک می‌کند</span></a></h2><img style="float:right;margin-left:0.5em;margin-bottom:0.25em;" alt="تصویر ابتدای فصل" src="images/ch.svg"/>
<a id="p227"></a><p class="noindent">می‌خواهیم یک بازی به نام <span class="emphasis">تهاجم بیگانگان</span> بسازیم. برای این منظور، از <span class="rlm">‏</span><span class="lr" dir="ltr">Pygame</span><span class="rlm">‏</span> استفاده می‌کنیم، که مجموعه‌ای از مدول‌های جالب و قدرتمند پایتون برای مدیریت گرافیک، انیمیشن، و حتی صدا است، به‌طوری که به آسانی می‌توانید بازی‌های پیشرفته‌ای بسازید. با توجه به اینکه پای‌گیم کارهایی مانند ترسیم تصاویر بر روی صفحه‌ی نمایش را انجام می‌دهد، شما می‌توانید بر روی منطق سطح بالاتر دینامیک بازی تمرکز کنید.</p><p>در این فصل، پای‌گیم را نصب می‌کنیم، و سپس یک سفینه‌ی فضایی درست می‌کنیم که می‌تواند در پاسخ به ورودی بازیکن، به چپ و راست حرکت کند و گلوله شلیک کند. در دو فصل بعد، ناوگانی از بیگانه‌ها درست می‌کنیم که باید نابود شوند، و سپس بازی را کامل‌تر می‌کنیم، به این صورت که برای تعداد سفینه‌هایی که می‌توانید استفاده کنید، حد تعیین می‌کنیم و یک جدول امتیازات اضافه می‌کنیم.</p><p>هنگام ساختن این بازی، با چگونگی مدیریت پروژه‌های بزرگ که شامل چندین فایل هستند، آشنا می‌شوید. مقدار زیادی از کد را بازساخت خواهیم کرد و محتویات فایل‌ها را مدیریت خواهیم کرد تا پروژه را سازمان‌دهی کنیم و کد کارآمدی داشته باشیم.</p><a id="p228"></a><p>ساختن بازی روش ایده‌آلی است که هم زبان پایتون را یاد بگیرید و هم به شما خوش بگذرد. بسی خرسند خواهید شد که بتوانید بازی‌ای را که خودتان نوشته‌اید، اجرا کنید، و با نوشتن این بازی ساده، خواهید فهمید که برنامه‌نویسان حرفه‌ای چگونه بازی‌ها را ایجاد می‌کنند. در طول این فصل، کدهای برنامه را وارد کنید و اجرا کنید، تا بفهمید که هر قطعه‌ی کد چه نقشی در ساختار کلی بازی دارد. مقادیر و تنظیمات را تغییر دهید تا نحوه‌ی تنظیم تعامل را در بازی‌ها بهتر درک کنید.</p><div class="note"><h6 class="note-title">توجه</h6>
<p class="noindent">بازی تهاجم بیگانگان شامل چندین فایل است، بنابراین، پوشه‌ی جدیدی به نام <span class="rlm">‏</span><span class="ident" dir="ltr">alien_invasion</span><span class="rlm">‏</span> روی سیستم‌تان درست کنید. دقت کنید که همه‌ی فایل‌های پروژه را در همان پوشه ذخیره کنید، تا دستورالعمل‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">import</span><span class="rlm">‏</span> درست عمل کنند.</p><p>در ضمن، اگر با کنترل ورژن آشنایی دارید، بد نیست برای این پروژه از آن استفاده کنید. در صورتی که قبلاً از کنترل ورژن استفاده نکرده‌اید، برای مرور آن به <span class="ref"><a href="c40-appd.xhtml">ضمیمه‌ی ت</a></span> مراجعه کنید.</p></div><div class="sect" id="ch12lev1sec1"><a class="bkmk" name="ch12lev1sec1"></a><h3>برنامه‌ریزی پروژه</h3>
<p class="noindent">وقتی که پروژه‌ی بزرگی می‌سازید، خیلی مهم است که قبل از آنکه شروع به کدنویسی کنید، کارتان را برنامه‌ریزی کنید. این برنامه‌ریزی به تمرکز شما کمک می‌کند و احتمال تکمیل پروژه را افزایش می‌دهد.</p><p>پس در اینجا شرحی از کلیات این بازی می‌نویسیم. با آنکه شرح زیر مشتمل بر تمام جزئیات بازی <span class="emphasis">تهاجم بیگانگان</span> نیست، ولی تا حدودی مشخص می‌کند که برای شروع ساخت بازی، چه باید بکنیم:</p><p>در بازی <span class="emphasis">تهاجم بیگانگان</span>، بازیکن یک سفینه را که در قسمت وسط پایین صفحه نمایش داده می‌شود، کنترل می‌کند. بازیکن می‌تواند سفینه را با کلیدهای پیکان به چپ و راست ببرد، و گلوله‌ها را با استفاده از کلید فاصله (اسپیس) شلیک کند. وقتی که بازی شروع می‌شود، ناوگانی از بیگانه‌ها آسمان را پر می‌کند که به چپ و راست و پایین حرکت می‌کنند. بازیکن شلیک می‌کند و بیگانه‌ها را نابود می‌کند. اگر بازیکن تمام بیگانه‌ها را ساقط کند، ناوگان جدیدی ظاهر می‌شود که با سرعت بیشتری نسبت به ناوگان قبلی حرکت می‌کند. اگر هر کدام از بیگانه‌ها به سفینه‌ی بازیکن برخورد کند یا به پایین صفحه‌ی نمایش برسد، بازیکن یک سفینه را از دست می‌دهد. اگر بازیکن سه سفینه را از دست بدهد، بازی تمام می‌شود.</p><p>در فاز اول برنامه‌نویسی، سفینه‌ای خواهیم ساخت که به چپ و راست حرکت می‌کند و زمانی که بازیکن کلید اسپیس را فشار می‌دهد، گلوله شلیک می‌کند. پس از تنظیم این رفتار، می‌توانیم بیگانه‌ها را ایجاد کنیم و بازی را تکمیل نماییم.</p></div><div class="sect" id="ch12lev1sec2"><a class="bkmk" name="ch12lev1sec2"></a><h3>نصب <span class="rlm">‏</span><span class="lr" dir="ltr">Pygame</span><span class="rlm">‏</span></h3>
<p class="noindent">قبل از شروع کدنویسی، پای‌گیم را نصب کنید. مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pip</span><span class="rlm">‏</span> امکان دانلود و نصب پکیج‌های پایتون را فراهم می‌کند. برای نصب پای‌گیم، فرمان زیر را در سطر فرمان ترمینال وارد کنید:</p><div class="snippet"><pre class="snippet" dir="ltr">$ <span class="bo">python -m pip install --user pygame</span></pre></div><p>این فرمان به پایتون می‌گوید که مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pip</span><span class="rlm">‏</span> را اجرا کند و پکیج <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame</span><span class="rlm">‏</span> را در محل مربوط به نصب پایتون کاربر کنونی، نصب کند. اگر برای اجرای برنامه‌ها یا ترمینال از فرمانی <a id="p229"></a>غیر از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">python</span><span class="rlm">‏</span> استفاده می‌کنید، مثلاً از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">python3</span><span class="rlm">‏</span>، در آن صورت فرمان فوق چیزی شبیه دستور زیر خواهد بود:</p><div class="snippet"><pre class="snippet" dir="ltr">$ <span class="bo">python3 -m pip install --user pygame</span></pre></div><div class="note"><h6 class="note-title">توجه</h6>
<p class="noindent">اگر این فرمان در <span class="rlm">‏</span><span class="lr" dir="ltr">macOS</span><span class="rlm">‏</span> کار نکرد، سعی کنید دوباره فرمان را بدون فلگ <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">--user</span><span class="rlm">‏</span> اجرا کنید.</p></div></div><div class="sect" id="ch12lev1sec3"><a class="bkmk" name="ch12lev1sec3"></a><h3>شروع پروژه‌ی بازی</h3>
<p class="noindent">برای شروع ساخت بازی، یک پنجره‌ی خالی پای‌گیم ایجاد می‌کنیم. بعداً عناصر بازی، از قبیل سفینه و بیگانه‌ها، را روی این پنجره ترسیم خواهیم کرد. هم‌چنین، کاری خواهیم کرد که بازی ما به ورودی کاربر پاسخ دهد، و رنگ زمینه را تعیین خواهیم کرد، و تصویر سفینه را بار خواهیم کرد.</p><div class="sect" id="ch12lev2sec1"><a class="bkmk" name="ch12lev2sec1"></a><h4>ایجاد پنجره‌ی پای‌گیم و پاسخ دادن به ورودی کاربر</h4>
<p class="noindent">برای ایجاد یک پنجره‌ی پای‌گیم، یک کلاس ایجاد می‌کنیم که معرف بازی است. در ویرایشگر متنی، فایل جدیدی ایجاد کنید و آن را با نام <span class="rlm">‏</span><span class="ident" dir="ltr">alien_invasion.py</span><span class="rlm">‏</span> ذخیره کنید؛ سپس کد زیر را وارد کنید:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">import sys

import pygame

class AlienInvasion:
    """Overall class to manage game assets and behavior."""

    def __init__(self):
        """Initialize the game, and create game resources."""
<span class="n" dir="ltr">1</span>        pygame.init()

<span class="n" dir="ltr">2</span>        self.screen = pygame.display.set_mode((1200, 800))
        pygame.display.set_caption("Alien Invasion")

    def run_game(self):
        """Start the main loop for the game."""
<span class="n" dir="ltr">3</span>        while True:
            # Watch for keyboard and mouse events.
<span class="n" dir="ltr">4</span>            for event in pygame.event.get():
<span class="n" dir="ltr">5</span>                if event.type == pygame.QUIT:
                    sys.exit()

            # Make the most recently drawn screen visible.
<span class="n" dir="ltr">6</span>            pygame.display.flip()

if __name__ == '__main__':
    # Make a game instance, and run the game.
    ai = AlienInvasion()
    ai.run_game()</pre></div><a id="p230"></a><p>ابتدا مدول‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">sys</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame</span><span class="rlm">‏</span> را ایمپورت می‌کنیم. مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame</span><span class="rlm">‏</span> حاوی قابلیت‌هایی است که برای ساختن بازی به آن‌ها نیاز داریم. از ابزارهای موجود در مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">sys</span><span class="rlm">‏</span> نیز برای خروج از برنامه در زمانی که کاربر خارج می‌شود، استفاده خواهیم کرد.</p><p>بازی <span class="emphasis">تهاجم بیگانگان</span> با کلاسی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AlienInvasion</span><span class="rlm">‏</span> شروع می‌شود. در متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span>، تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame.init()</span><span class="rlm">‏</span> تنظیمات زمینه‌ای را که برای عملکرد صحیح پای‌گیم لازم است، برقرار می‌کند <span class="n" dir="ltr">1</span>. در <span class="n" dir="ltr">2</span>، متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame.display.set_mode()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم تا یک پنجره‌ی نمایش درست کنیم، که تمام عناصر گرافیکی بازی را روی آن ترسیم خواهیم کرد. آرگومان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">(1200, 800)</span><span class="rlm">‏</span> یک توپل است که ابعاد پنجره‌ی بازی را مشخص می‌کند، که عرض آن ۱۲۰۰ پیکسل و ارتفاع آن ۸۰۰ پیکسل تعیین شده است. (شما می‌توانید بسته به اندازه‌ی نمایشگر خود این اعداد را تغییر دهید.) این پنجره‌ی نمایش را به صفت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.screen</span><span class="rlm">‏</span> اختصاص می‌دهیم، تا در تمام متدهای کلاس در دسترس باشد.</p><p>شیئی که به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.screen</span><span class="rlm">‏</span> اختصاص دادیم، یک <span class="emphasis">سطح</span> (<span class="emphasis"><span class="rlm">‏</span><span class="lr" dir="ltr">surface</span><span class="rlm">‏</span></span>) نامیده می‌شود. سطح در پای‌گیم بخشی از صفحه‌ی نمایش است که یک عنصر بازی را می‌توان روی آن نمایش داد. هر کدام از عناصر بازی، مثلاً بیگانه یا سفینه، خود یک سطح است. سطحی که از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">display.set_mode()</span><span class="rlm">‏</span> حاصل می‌شود، نماینده‌ی تمام پنجره‌ی بازی است. وقتی که حلقه‌ی انیمیشن بازی را فعال می‌کنیم، این سطح در هر دور حلقه دوباره ترسیم می‌شود، به‌طوری که می‌توان تغییرات ناشی از ورودی کاربر را در آن اعمال کرد.</p><p>بازی با استفاده از متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">run_game()</span><span class="rlm">‏</span> کنترل می‌شود. این متد یک حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">while</span><span class="rlm">‏</span> دارد <span class="n" dir="ltr">3</span> که به‌طور پیوسته اجرا می‌شود. حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">while</span><span class="rlm">‏</span> حاوی یک حلقه‌ی رویداد است و کدی که به‌روزرسانی نمایشگر را مدیریت می‌کند. <span class="emphasis">رویداد</span> عملی است که کاربر هنگام استفاده از بازی انجام می‌دهد، مثلاً فشار دادن یک کلید یا حرکت دادن ماوس. برای اینکه برنامه‌ی ما به رویدادها پاسخ دهد، این <span class="emphasis">حلقه‌ی رویداد</span> را می‌نویسیم تا به رویدادها <span class="emphasis">گوش کند</span> و بسته به نوع رویدادهایی که بروز می‌کند، کارهای مناسب را انجام دهد. حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">for</span><span class="rlm">‏</span> در <span class="n" dir="ltr">4</span> یک حلقه‌ی رویداد است.</p><p>برای دسترسی به رویدادهایی که پای‌گیم تشخیص می‌دهد، از تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame.event.get()</span><span class="rlm">‏</span> استفاده خواهیم کرد. این تابع لیستی برمی‌گرداند از رویدادهایی که از آخرین دفعه‌ای که این تابع فراخوانی شده، رخ داده است. هرگونه رویداد صفحه‌کلید یا ماوس موجب اجرای این حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">for</span><span class="rlm">‏</span> خواهد شد. در داخل حلقه، یک سری دستورالعمل <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">if</span><span class="rlm">‏</span> می‌نویسیم تا رویدادهای خاصی را شناسایی کنیم و به آن‌ها پاسخ دهیم. مثلاً وقتی که کاربر روی دکمه‌ی بستن پنجره‌ی بازی کلیک می‌کند، یک رویداد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame.QUIT</span><span class="rlm">‏</span> شناسایی می‌شود و ما برای خروج از بازی، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">sys.exit()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم <span class="n" dir="ltr">5</span>.</p><p>فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame.display.flip()</span><span class="rlm">‏</span> در <span class="n" dir="ltr">6</span> به پایتون می‌گوید که جدیدترین صفحه‌ای را که ترسیم شده است، نمایش دهد. در این مورد، در هر دور حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">while</span><span class="rlm">‏</span>، صرفاً یک صفحه‌ی خالی ترسیم می‌شود. وقتی که عناصر بازی را حرکت می‌دهیم، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame.display.flip()</span><span class="rlm">‏</span> به‌طور پیوسته صفحه‌ی نمایش را روزآمد می‌کند تا موقعیت جدید عناصر بازی را نمایش دهد، و موارد قدیمی را مخفی می‌کند، به‌طوری که توهم حرکتی هموار ایجاد می‌شود.</p><p>در پایان فایل، یک نمونه از بازی ایجاد می‌کنیم، و سپس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">run_game()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم. فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">run_game()</span><span class="rlm">‏</span> را در یک بلوک <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">if</span><span class="rlm">‏</span> قرار می‌دهیم که فقط در صورتی اجرا می‌شود که فایل مستقیماً اجرا شده باشد. وقتی که این فایل <span class="rlm">‏</span><span class="ident" dir="ltr">alien_invasion.py</span><span class="rlm">‏</span> را اجرا کنید، باید یک پنجره‌ی خالی پای‌گیم ببینید.</p></div><div class="sect" id="ch12lev2sec2"><a class="bkmk" name="ch12lev2sec2"></a><h4>تعیین رنگ پس‌زمینه</h4>
<p class="noindent">پای‌گیم به‌طور پیش‌فرض یک صفحه‌ی سیاه ایجاد می‌کند، ولی این رنگ زیاد جالب نیست. پس بیایید رنگ پس‌زمینه‌ی دیگری انتخاب کنیم. این کار را در پایان متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> انجام خواهیم داد.</p><a id="p231"></a><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def __init__(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash">pygame.display.set_caption("Alien Invasion")</span>

        # Set the background color.
<span class="n" dir="ltr">1</span>        self.bg_color = (230, 230, 230)

    <span class="ash">def run_game(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
            <span class="ash">for event in pygame.event.get():</span>
                <span class="ash">if event.type == pygame.QUIT:</span>
                    <span class="ash">sys.exit()</span>

            # Redraw the screen during each pass through the loop.
<span class="n" dir="ltr">2</span>            self.screen.fill(self.bg_color)

            <span class="ash"># Make the most recently drawn screen visible.</span>
            <span class="ash">pygame.display.flip()</span></pre></div><p>رنگ در پای‌گیم به‌صورت <span class="rlm">‏</span><span class="lr" dir="ltr">RGB</span><span class="rlm">‏</span> تعیین می‌شود: یعنی به‌صورت ترکیبی از قرمز، سبز، و آبی. هر مقدار رنگ می‌تواند از ۰ تا ۲۵۵ باشد. مثلاً رنگ <span class="rlm">‏</span><span class="lr" dir="ltr">(255, 0, 0)</span><span class="rlm">‏</span> قرمز است، <span class="rlm">‏</span><span class="lr" dir="ltr">(0, 255, 0)</span><span class="rlm">‏</span> سبز است، و <span class="rlm">‏</span><span class="lr" dir="ltr">(0, 0, 255)</span><span class="rlm">‏</span> آبی است. با ترکیب مقادیر مختلف <span class="rlm">‏</span><span class="lr" dir="ltr">RGB</span><span class="rlm">‏</span>، ۱۶ میلیون رنگ حاصل می‌شود. رنگ <span class="rlm">‏</span><span class="lr" dir="ltr">(230, 230, 230)</span><span class="rlm">‏</span> حاوی مقادیر برابر از قرمز، سبز، و آبی است، و لذا رنگ پس‌زمینه، خاکستری روشن است. این رنگ را به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.bg_color</span><span class="rlm">‏</span> اختصاص می‌دهیم <span class="n" dir="ltr">1</span>.</p><p>در <span class="n" dir="ltr">2</span>، صفحه‌ی نمایش را با استفاده از متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">fill()</span><span class="rlm">‏</span>، با رنگ پس‌زمینه پر می‌کنیم. این متد روی یک سطح عمل می‌کند و یک آرگومان می‌گیرد که رنگ مورد نظر است.</p></div><div class="sect" id="ch12lev2sec3"><a class="bkmk" name="ch12lev2sec3"></a><h4>ایجاد کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Settings</span><span class="rlm">‏</span></h4>
<p class="noindent">هر بار که قابلیت جدیدی را به بازی اضافه می‌کنیم، عموماً لازم است که تنظیمات جدیدی نیز ایجاد کنیم. به جای اینکه تنظیمات مختلف را در لابلای کد قرار دهیم، می‌توانیم یک مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">settings</span><span class="rlm">‏</span> ایجاد کنیم که حاوی کلاسی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Settings</span><span class="rlm">‏</span> است که تمام این مقادیر را در یک جا ذخیره می‌کند. این رویکرد به ما امکان می‌دهد که وقتی نیاز به دسترسی به هر کدام از تنظیمات داریم، فقط با یک شیء تنظیمات سر و کار داشته باشیم. به‌علاوه، تغییر دادن منظره‌ی بازی را در زمانی که پروژه‌ی ما بزرگ‌تر شده باشد، آسان‌تر خواهد کرد: برای تغییر دادن بازی، کافی است که برخی مقادیر را در فایل <span class="rlm">‏</span><span class="ident" dir="ltr">settings.py</span><span class="rlm">‏</span> که بعداً ایجاد خواهیم کرد، تغییر دهیم، به جای اینکه بخواهیم تنظیمات مختلف را در سرتاسر پروژه تغییر دهیم.</p><p>فایل جدیدی به نام <span class="rlm">‏</span><span class="ident" dir="ltr">settings.py</span><span class="rlm">‏</span> در داخل پوشه‌ی <span class="rlm">‏</span><span class="ident" dir="ltr">alien_invasion</span><span class="rlm">‏</span> ایجاد کنید، و این کلاس اولیه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Settings</span><span class="rlm">‏</span> را در آن قرار دهید:</p><div class="snippet"><div class="snippet-title" dir="ltr">settings.py</div><pre class="snippet" dir="ltr">class Settings:
    """A class to store all settings for Alien Invasion."""

    def __init__(self):
        """Initialize the game's settings."""
        # Screen settings
        self.screen_width = 1200
        self.screen_height = 800
        self.bg_color = (230, 230, 230)</pre></div><a id="p232"></a><p>برای اینکه یک نمونه از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Settings</span><span class="rlm">‏</span> در پروژه ایجاد کنیم و با استفاده از آن به تنظیمات خود دسترسی برقرار کنیم، باید فایل <span class="rlm">‏</span><span class="ident" dir="ltr">alien_invasion.py</span><span class="rlm">‏</span> را به‌صورت زیر تغییر دهیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">
<span class="ash">--<span class="it">snip</span>--</span>
<span class="ash">import pygame</span>

from settings import Settings

<span class="ash">class AlienInvasion:</span>
    <span class="ash">"""Overall class to manage game assets and behavior."""</span>

    <span class="ash">def __init__(self):</span>
        <span class="ash">"""Initialize the game, and create game resources."""</span>
        <span class="ash">pygame.init()</span>
<span class="n" dir="ltr">1</span>        self.settings = Settings()

<span class="n" dir="ltr">2</span>        self.screen = pygame.display.set_mode(
            (self.settings.screen_width, self.settings.screen_height))
        <span class="ash">pygame.display.set_caption("Alien Invasion")</span>

    <span class="ash">def run_game(self):</span>
            <span class="ash">--<span class="it">snip</span>--</span>
            <span class="ash"># Redraw the screen during each pass through the loop.</span>
<span class="n" dir="ltr">3</span>            self.screen.fill(self.settings.bg_color)

            <span class="ash"># Make the most recently drawn screen visible.</span>
            <span class="ash">pygame.display.flip()</span>
<span class="ash">--<span class="it">snip</span>--</span>
</pre></div><p>کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Settings</span><span class="rlm">‏</span> را به فایل اصلی برنامه ایمپورت می‌کنیم. آنگاه، پس از آنکه <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame.init()</span><span class="rlm">‏</span> را فراخوانی کردیم، یک نمونه از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Settings</span><span class="rlm">‏</span> ایجاد می‌کنیم و آن را به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.settings</span><span class="rlm">‏</span> اختصاص می‌دهیم <span class="n" dir="ltr">1</span>. برای ایجاد یک صفحه‌ی نمایش (<span class="rlm">‏</span><span class="lr" dir="ltr">screen</span><span class="rlm">‏</span>) در <span class="n" dir="ltr">2</span>، از صفت‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">screen_width</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">screen_height</span><span class="rlm">‏</span> متعلق به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.settings</span><span class="rlm">‏</span> استفاده می‌کنیم. زمانی هم که در <span class="n" dir="ltr">3</span> رنگ این صفحه‌ی نمایش را مشخص می‌کنیم، از رنگ پس‌زمینه‌ی ذخیره شده در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.settings</span><span class="rlm">‏</span> استفاده می‌کنیم.</p><p>اگر حالا <span class="rlm">‏</span><span class="ident" dir="ltr">alien_invasion.py</span><span class="rlm">‏</span> را اجرا کنید، تغییری مشاهده نخواهید کرد، زیرا تمام کاری که کرده‌ایم، این است که همان تنظیماتی را که از قبل استفاده می‌شد، به جای دیگری منتقل کرده‌ایم. اکنون آماده‌ایم که عناصر جدیدی را به صفحه‌ی نمایش اضافه کنیم.</p></div></div><div class="sect" id="ch12lev1sec4"><a class="bkmk" name="ch12lev1sec4"></a><h3>اضافه کردن تصویر سفینه</h3>
<p class="noindent">می‌خواهیم سفینه را به بازی‌مان اضافه کنیم. برای ترسیم سفینه‌ی بازیکن روی صفحه‌ی نمایش، یک تصویر را می‌خوانیم و آنگاه با استفاده از متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">blit()</span><span class="rlm">‏</span> مربوط به پای‌گیم، این تصویر را ترسیم می‌کنیم.</p><p>وقتی که برای بازی‌هایتان آثار هنری از اینترنت دانلود می‌کنید، باید به مجوز استفاده‌ی آن‌ها توجه کنید. ایمن‌ترین و ارزان‌ترین راه در ابتدای کار این است که از تصاویر رایگان که مجوز استفاده و تغییر دارند، مثلاً از وب‌سایتی مانند <span class="rlm">‏</span><a dir="ltr" target="_blank" href="https://pixabay.com/">pixabay.com</a><span class="rlm">‏</span>، استفاده کنید.</p><p>تقریباً از هر نوع فایل تصویری می‌توانید در برنامه‌ی بازی استفاده کنید، ولی راحت‌تر از همه این است که از یک فایل بیت‌مپ (<span class="rlm">‏</span><span class="ident" dir="ltr">.bmp</span><span class="rlm">‏</span>) استفاده کنید، چرا که پایتون به‌صورت پیش‌فرض، فایل‌های بیت‌مپ را می‌خواند. گرچه می‌توانید پای‌گیم را پیکربندی کنید تا از انواع دیگر فایل استفاده کند، ولی خواندن برخی انواع فایل <a id="p233"></a>وابسته به کتابخانه‌های تصویری خاصی است که باید روی کامپیوتر شما نصب شوند. اکثر تصاویری که در اینترنت پیدا می‌کنید، از نوع <span class="rlm">‏</span><span class="ident" dir="ltr">.jpg</span><span class="rlm">‏</span> یا <span class="rlm">‏</span><span class="ident" dir="ltr">.png</span><span class="rlm">‏</span> هستند، ولی می‌توانید با برنامه‌هایی مانند فتوشاپ، <span class="rlm">‏</span><span class="lr" dir="ltr">GIMP</span><span class="rlm">‏</span>، یا <span class="rlm">‏</span><span class="lr" dir="ltr">Paint</span><span class="rlm">‏</span> آن‌ها را به بیت‌مپ تبدیل کنید.</p><p>لازم است که به رنگ پس‌زمینه در تصویر انتخاب شده به‌طور خاص توجه کنید. سعی کنید فایلی پیدا کنید که پس‌زمینه‌ی آن شفاف یا یک‌رنگ باشد، تا بتوانید آن را در یک برنامه‌ی ویرایش تصویر با رنگ پس‌زمینه‌ی مورد نظر خودتان جایگزین کنید. بهتر است رنگ پس‌زمینه‌ی تصویر با رنگ پس‌زمینه‌ی بازی مطابقت داشته باشد. یا اینکه می‌توانید رنگ پس‌زمینه‌ی بازی را مطابق با رنگ پس‌زمینه‌ی تصویر انتخاب کنید.</p><p>برای <span class="emphasis">Alien Invasion</span>، می‌توانید از فایل <span class="rlm">‏</span><span class="ident" dir="ltr">ship.bmp</span><span class="rlm">‏</span> استفاده کنید (<refFig xmlns="urn:dox:pycc">۱۲-۱</refFig>)، که در منابع کتاب در نشانی <span class="rlm">‏</span><a dir="ltr" target="_blank" href="https://nostarch.com/pythoncrashcourse2e/">nostarch.com/pythoncrashcourse2e/</a><span class="rlm">‏</span> در دسترس است. تصویر پس‌زمینه‌ی این فایل منطبق با تنظیماتی است که ما در این پروژه استفاده می‌کنیم. پوشه‌ای به نام <span class="rlm">‏</span><span class="ident" dir="ltr">images</span><span class="rlm">‏</span> در داخل پوشه‌ی اصلی پروژه، <span class="rlm">‏</span><span class="ident" dir="ltr">alien_invasion</span><span class="rlm">‏</span>، بسازید. فایل <span class="rlm">‏</span><span class="ident" dir="ltr">ship.bmp</span><span class="rlm">‏</span> را در پوشه‌ی <span class="rlm">‏</span><span class="ident" dir="ltr">images</span><span class="rlm">‏</span> قرار دهید.</p><figure class="fig" id="ch12_fig01"><img class="fig" src="images/ch12_fig01.jpg"/><figcaption class="fig">شکل ۱۲-۱: تصویر سفینه برای بازی تهاجم بیگانگان</figcaption></figure><div class="sect" id="ch12lev2sec4"><a class="bkmk" name="ch12lev2sec4"></a><h4>ایجاد کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span></h4>
<p class="noindent">پس از انتخاب تصویر برای سفینه، باید آن را روی صفحه نمایش دهیم. برای استفاده از این سفینه، مدول جدیدی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">ship</span><span class="rlm">‏</span> ایجاد می‌کنیم که حاوی کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> خواهد بود. این کلاس اکثر رفتار سفینه‌ی بازیکن را مدیریت خواهد کرد:</p><div class="snippet"><div class="snippet-title" dir="ltr">ship.py</div><pre class="snippet" dir="ltr">import pygame

class Ship:
    """A class to manage the ship."""

    def __init__(self, ai_game):
        """Initialize the ship and set its starting position."""
<span class="n" dir="ltr">1</span>        self.screen = ai_game.screen
<span class="n" dir="ltr">2</span>        self.screen_rect = ai_game.screen.get_rect()

        # Load the ship image and get its rect.
<span class="n" dir="ltr">3</span>        self.image = pygame.image.load('images/ship.bmp')
        self.rect = self.image.get_rect()
<a id="p234"></a>        # Start each new ship at the bottom center of the screen.
<span class="n" dir="ltr">4</span>        self.rect.midbottom = self.screen_rect.midbottom

<span class="n" dir="ltr">5</span>    def blitme(self):
        """Draw the ship at its current location."""
        self.screen.blit(self.image, self.rect)</pre></div><p>یکی از دلایل کارآمدی پای‌گیم آن است که شما تمام عناصر بازی را به‌عنوان مستطیل (<span class="emphasis"><span class="rlm">‏</span><span class="lr" dir="ltr">rect</span><span class="rlm">‏</span></span>) در نظر می‌گیرید، ولو آنکه شکل آن‌ها دقیقاً به‌صورت مستطیل نباشد. در نظر گرفتن عنصر به‌عنوان مستطیل موجب افزایش کارایی می‌شود، چرا که مستطیل یک شکل ساده‌ی هندسی است. مثلاً وقتی که پای‌گیم می‌خواهد ببیند که دو عنصر بازی با هم برخورد کرده‌اند یا نه، در صورتی که عنصرها را به‌عنوان مستطیل در نظر بگیرد، این کار راحت‌تر انجام می‌شود. معمولاً عملکرد این روش به حدی است که بازیکن متوجه نمی‌شود که ما شکل دقیق هر عنصر بازی را در نظر نگرفته‌ایم. بنابراین، ما در این کلاس، سفینه و صفحه‌ی نمایش را به‌عنوان مستطیل در نظر می‌گیریم.</p><p>قبل از تعریف کلاس، مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame</span><span class="rlm">‏</span> را ایمپورت می‌کنیم. متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> دو پارامتر می‌گیرد: یک اشاره به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self</span><span class="rlm">‏</span> و یک اشاره به نمونه‌ی کنونی کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AlienInvasion</span><span class="rlm">‏</span>. به این ترتیب، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> به تمام منابع بازی که در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AlienInvasion</span><span class="rlm">‏</span> تعریف شده است، دسترسی خواهد داشت. در <span class="n" dir="ltr">1</span>، صفحه‌ی نمایش را به یک صفت از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> اختصاص می‌دهیم، به‌طوری که در تمام متدهای این کلاس بتوانیم به آسانی به آن دسترسی داشته باشیم. در <span class="n" dir="ltr">2</span>، صفت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> صفحه‌ی نمایش را با استفاده از متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_rect()</span><span class="rlm">‏</span> می‌گیریم و آن را به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.screen_rect</span><span class="rlm">‏</span> اختصاص می‌دهیم. انجام این کار به ما امکان می‌دهد که سفینه را در موقعیت صحیح روی صفحه‌ی نمایش قرار دهیم.</p><p>برای خواندن تصویر، متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame.image.load()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم <span class="n" dir="ltr">3</span>، و محل فایل تصویر را به آن می‌دهیم. این تابع یک سطح برای سفینه برمی‌گرداند که آن را به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.image</span><span class="rlm">‏</span> اختصاص می‌دهیم. وقتی که تصویر خوانده شد، با استفاده از متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">get_rect()</span><span class="rlm">‏</span>، به صفت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> سطح سفینه دسترسی پیدا می‌کنیم، تا بعداً بتوانیم با استفاده از آن، سفینه را در آن قرار دهیم.</p><p>وقتی که با یک شیء <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> کار می‌کنید، می‌توانید برای قرار دادن شیء از مختصات <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> لبه‌های بالا، پایین، چپ، و راست مستطیل و نیز مرکز آن استفاده کنید. می‌توانید به هر کدام از این‌ها مقدار بدهید تا مکان کنونی مستطیل را تعیین کنید. وقتی که می‌خواهید یک عنصر بازی را در وسط قرار دهید، از صفت‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">center</span><span class="rlm">‏</span>، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">centerx</span><span class="rlm">‏</span>، و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">centery</span><span class="rlm">‏</span> مستطیل استفاده کنید. وقتی که در یک لبه‌ی صفحه کار می‌کنید، از صفت‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">top</span><span class="rlm">‏</span>، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">bottom</span><span class="rlm">‏</span>، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">left</span><span class="rlm">‏</span>، یا <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">right</span><span class="rlm">‏</span> استفاده کنید. صفت‌هایی نیز هستند که این خصلت‌ها را با هم ترکیب می‌کنند، از قبیل <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">midbottom</span><span class="rlm">‏</span>، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">midtop</span><span class="rlm">‏</span>، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">midleft</span><span class="rlm">‏</span>، و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">midright</span><span class="rlm">‏</span>. وقتی که قرارگیری افقی یا عمودی مستطیل را تنظیم می‌کنید، می‌توانید از خود صفت‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">x</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">y</span><span class="rlm">‏</span> استفاده کنید، که مختصات <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> گوشه‌ی بالای چپ آن هستند. با استفاده از این صفت‌ها دیگر نیازی به انجام محاسبه که در گذشته در برنامه‌نویسی بازی لازم بود، ندارید، و لذا به کرات از آن‌ها استفاده خواهید کرد.</p><div class="note"><h6 class="note-title">توجه</h6>
<p class="noindent">در پای‌گیم، نقطه‌ی مبدأ <span class="rlm">‏</span><span class="lr" dir="ltr">(0, 0)</span><span class="rlm">‏</span> در گوشه‌ی بالای چپ صفحه‌ی نمایش است، و مختصات به طرف پایین و راست اضافه می‌شود. در یک صفحه‌ی نمایش ۱۴۰۰ در ۸۰۰، مبدأ در گوشه‌ی بالای چپ است، و مختصات گوشه‌ی پایین راست <span class="rlm">‏</span><span class="lr" dir="ltr">(1200, 800)</span><span class="rlm">‏</span> است.این مختصات نسبت به پنجره‌ی بازی است، نه خود صفحه‌ی نمایش فیزیکی کامپیوتر.</p></div><a id="p235"></a><p>ما سفینه را در وسط پایین صفحه‌ی نمایش قرار می‌دهیم. برای این منظور، مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.rect.midbottom</span><span class="rlm">‏</span> را مطابق با مقدار صفت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">midbottom</span><span class="rlm">‏</span> از مستطیل صفحه قرار می‌دهیم <span class="n" dir="ltr">4</span>. پای‌گیم با استفاده از این صفت‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span>، تصویر سفینه را به‌گونه‌ای قرار می‌دهد که از نظر افقی در وسط باشد و در امتداد پایین صفحه قرار گرفته باشد.</p><p>در <span class="n" dir="ltr">5</span>، متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">blitme()</span><span class="rlm">‏</span> را تعریف می‌کنیم، که تصویر را روی صفحه‌ی نمایش در موقعیتی که به‌وسیله‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.rect</span><span class="rlm">‏</span> مشص شده است، ترسیم می‌کند.</p></div><div class="sect" id="ch12lev2sec5"><a class="bkmk" name="ch12lev2sec5"></a><h4>ترسیم سفینه روی صفحه‌ی نمایش</h4>
<p class="noindent">اکنون <span class="rlm">‏</span><span class="ident" dir="ltr">alien_invasion.py</span><span class="rlm">‏</span> را تغییر می‌دهیم تا یک سفینه ایجاد کند و متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">blitme()</span><span class="rlm">‏</span> سفینه را فراخوانی کند:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr"><span class="ash">--<span class="it">snip</span>--</span>
<span class="ash">from settings import Settings</span>
from ship import Ship

<span class="ash">class AlienInvasion:</span>
    <span class="ash">"""Overall class to manage game assets and behavior."""</span>

    <span class="ash">def __init__(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash">pygame.display.set_caption("Alien Invasion")</span>

<span class="n" dir="ltr">1</span>        self.ship = Ship(self)

    <span class="ash">def run_game(self):</span>
            <span class="ash">--<span class="it">snip</span>--</span>
            <span class="ash"># Redraw the screen during each pass through the loop.</span>
            <span class="ash">self.screen.fill(self.settings.bg_color)</span>
<span class="n" dir="ltr">2</span>            self.ship.blitme()

            <span class="ash"># Make the most recently drawn screen visible.</span>
            <span class="ash">pygame.display.flip()</span>
<span class="ash">--<span class="it">snip</span>--</span></pre></div><p>کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> را ایمپورت می‌کنیم و آنگاه پس از ایجاد صفحه، یک نمونه از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> ایجاد می‌کنیم <span class="n" dir="ltr">1</span>. فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship()</span><span class="rlm">‏</span> نیاز به یک آرگومان دارد، که باید نمونه‌ای از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AlienInvasion</span><span class="rlm">‏</span> باشد. آرگومان <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self</span><span class="rlm">‏</span> در اینجا اشاره به نمونه‌ی کنونی از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AlienInvasion</span><span class="rlm">‏</span> دارد. این همان پارامتری است که سبب می‌شود که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> به منابع بازی، از قبیل شیء <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">screen</span><span class="rlm">‏</span>، دسترسی داشته باشد. این نمونه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> را به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.ship</span><span class="rlm">‏</span> اختصاص می‌دهیم.</p><p>پس از رنگ کردن پس‌زمینه، سفینه را با فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">ship.blitme()</span><span class="rlm">‏</span> روی اسکرین ترسیم می‌کنیم، به‌طوری که سفینه روی پس‌زمینه نمایش داده شود <span class="n" dir="ltr">2</span>.</p><p>حال وقتی که <span class="rlm">‏</span><span class="ident" dir="ltr">alien_invasion.py</span><span class="rlm">‏</span> را اجرا می‌کنید، یک صفحه‌ی بازی خالی خواهید دید که سفینه در وسط پایین قرار گرفته است، مانند <refFig xmlns="urn:dox:pycc">۱۲-۲</refFig>.</p><a id="p236"></a><figure class="fig" id="ch12_fig02"><img class="fig" src="images/ch12_fig02.jpg"/><figcaption class="fig">شکل ۱۲-۲: بازی تهاجم بیگانگان، که سفینه در وسط پایین صفحه قرار گرفته است.</figcaption></figure></div></div><div class="sect" id="ch12lev1sec5"><a class="bkmk" name="ch12lev1sec5"></a><h3>بازساخت: متدهای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_events()</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_update_screen()</span><span class="rlm">‏</span></h3>
<p class="noindent">در پروژه‌های بزرگ، خیلی وقت‌ها لازم می‌شود که کدی را که نوشته‌اید، قبل از افزودن کد بیشتر، بازساخت کنید. بازساخت سبب می‌شود که کد شما ساختار ساده‌تری داشته باشد و توسعه‌ی آن آسان‌تر شود. در این قسمت، متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">run_game()</span><span class="rlm">‏</span> را که تا حدودی طولانی شده است، به دو متد کمکی تقسیم می‌کنیم. <span class="emphasis">متد کمکی</span> کار خود را در داخل یک کلاس انجام می‌دهد، ولی قرار نیست که از طریق یک نمونه فراخوانی شود. در پایتون، نام متدهای کمکی با یک زیرخط شروع می‌شود.</p><div class="sect" id="ch12lev2sec6"><a class="bkmk" name="ch12lev2sec6"></a><h4>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_events()</span><span class="rlm">‏</span></h4>
<p class="noindent">کدی را که مسئول مدیریت رویدادها است، به متدی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_events()</span><span class="rlm">‏</span> منتقل می‌کنیم. با این کار، متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">run_game()</span><span class="rlm">‏</span> ساده‌تر می‌شود و حلقه‌ی مدیریت رویداد از بقیه‌ی کد جدا می‌شود. جدا کردن حلقه‌ی رویداد شما را قادر می‌سازد که رویدادها را جدا از سایر جنبه‌های بازی، مانند نوسازی صفحه‌ی نمایش، مدیریت کنید.</p><p>در اینجا، کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AlienInvasion</span><span class="rlm">‏</span> را با متد جدید <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_events()</span><span class="rlm">‏</span> می‌بینید، که تنها تأثیر آن در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">run_game()</span><span class="rlm">‏</span> است:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def run_game(self):</span>
        <span class="ash">"""Start the main loop for the game."""</span>
        <span class="ash">while True:</span>
<span class="n" dir="ltr">1</span>            self._check_events()

<a id="p237"></a>            <span class="ash"># Redraw the screen during each pass through the loop.</span>
            <span class="ash">--<span class="it">snip</span>--</span>

<span class="n" dir="ltr">2</span>    def _check_events(self):
        """Respond to keypresses and mouse events."""
        <span class="ash">for event in pygame.event.get():</span>
            <span class="ash">if event.type == pygame.QUIT:</span>
                <span class="ash">sys.exit()</span></pre></div><p>در <span class="n" dir="ltr">2</span>، یک متد جدید <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_events()</span><span class="rlm">‏</span> ایجاد می‌کنیم، و سطرهایی را که وارسی می‌کند که بازیکن برای بستن پنجره کلیک کرده است، به این متد جدید منتقل می‌کنیم.</p><p>برای فراخوانی یک متد از داخل یک کلاس، از نماد نقطه به همراه متغیر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self</span><span class="rlm">‏</span> و نام متد استفاده کنید <span class="n" dir="ltr">1</span>. این متد را در متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">run_game()</span><span class="rlm">‏</span>، در داخل یک حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">while</span><span class="rlm">‏</span> فراخوانی می‌کنیم.</p></div><div class="sect" id="ch12lev2sec7"><a class="bkmk" name="ch12lev2sec7"></a><h4>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_update_screen()</span><span class="rlm">‏</span></h4>
<p class="noindent">برای اینکه <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">run_game()</span><span class="rlm">‏</span> را باز هم ساده‌تر کنیم، کد مربوط به نوسازی صفحه‌ی نمایش را به متد جداگانه‌ای به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_update_screen()</span><span class="rlm">‏</span> منتقل می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def run_game(self):</span>
        <span class="ash">"""Start the main loop for the game."""</span>
        <span class="ash">while True:</span>
            <span class="ash">self._check_events()</span>
            self._update_screen()

    <span class="ash">def _check_events(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>

    def _update_screen(self):
        """Update images on the screen, and flip to the new screen."""
        <span class="ash">self.screen.fill(self.settings.bg_color)</span>
        <span class="ash">self.ship.blitme()</span>

        <span class="ash">pygame.display.flip()</span></pre></div><p>کدی را که پس‌زمینه و سفینه را ترسیم کرده و صفحه‌ی نمایش را ظاهر می‌نماید، به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_update_screen()</span><span class="rlm">‏</span> منتقل کردیم. حال بدنه‌ی حلقه‌ی اصلی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">run_game()</span><span class="rlm">‏</span> بسیار ساده‌تر شده است. به آسانی می‌توان دید که ما در هر دور حلقه، رویدادهای جدید را بررسی می‌کنیم و صفحه‌ی نمایش را نوسازی می‌نماییم.</p><p>اگر قبلاً چند بازی ساخته باشید، احتمالاً می‌دانید که در ابتدا باید کد را به این‌گونه متدها تقسیم کنید. ولی اگر تا کنون روی پروژه‌ای از این قبیل کار نکرده باشید، احتمالاً نمی‌دانید که برای کد خود چه ساختاری در نظر بگیرید. این رویکرد که ابتدا کد را به‌صورتی که قابل استفاده باشد، می‌نویسید، و بعد که پروژه بزرگ‌تر و پیچیده‌تر می‌شود، آن را بازساخت می‌کنید، فرایند واقعی برنامه‌نویسی را تا حدودی به شما نشان می‌دهد: در ابتدا کد را تا حد امکان ساده می‌نویسید، و بعد با پیچیده‌تر شدن پروژه، آن را بازساخت می‌کنید.</p><p>حالا که کد را به‌گونه‌ای بازساخت کرده‌ایم که توسعه‌ی آن آسان‌تر است، می‌توانیم روی جنبه‌های پویای بازی کار کنیم!</p><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<a id="p238"></a><p class="tiy1"><span class="tiy" id="ch12_tiy01"><span class="tiy-num">۱۲-۱</span>. <span class="tiy-title">آسمان آبی</span>: </span> یک پنجره‌ی پای‌گیم با پس‌زمینه‌ی آبی بسازید.</p><p class="tiy1"><span class="tiy" id="ch12_tiy02"><span class="tiy-num">۱۲-۲</span>. <span class="tiy-title">کاراکتر بازی</span>: </span> تصویر بیت‌مپی از یک کاراکتر بازی که به آن علاقه دارید، پیدا کنید، یا تصویری با فرمت دیگر را به بیت‌مپ تبدیل کنید. کلاسی بنویسید که این کاراکتر را در مرکز صفحه ترسیم می‌کند، و رنگ پس‌زمینه‌ی تصویر را مطابق با رنگ پس‌زمینه‌ی صفحه، یا بر عکس، تغییر دهید.</p></div></div></div><div class="sect" id="ch12lev1sec6"><a class="bkmk" name="ch12lev1sec6"></a><h3>هدایت سفینه</h3>
<p class="noindent">حالا می‌خواهیم به بازیکن این توانایی را بدهیم که سفینه را به چپ و راست حرکت دهد. کدی می‌نویسیم که وقتی بازیکن کلید پیکانی راست یا چپ را فشار می‌دهد، پاسخ دهد. ابتدا حرکت به سمت راست را درست می‌کنیم و سپس امکان حرکت به طرف چپ را هم بر همان اساس ایجاد می‌نماییم. با افزودن این کد، نحوه‌ی کنترل حرکت تصاویر روی صفحه‌ی نمایش و پاسخ دادن به ورودی کاربر را یاد خواهید گرفت.</p><div class="sect" id="ch12lev2sec8"><a class="bkmk" name="ch12lev2sec8"></a><h4>پاسخ دادن به فشار دادن شدن کلید</h4>
<p class="noindent">هر گاه بازیکن کلیدی را فشار می‌دهد، این فشار دادن شدن در پای‌گیم به‌صورت یک رویداد ثبت می‌شود. هر کدام از رویدادها به‌وسیله‌ی متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame.event.get()</span><span class="rlm">‏</span> دریافت می‌شود. باید در متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_events()</span><span class="rlm">‏</span> مشخص کنیم که بازی ما چه نوع رویدادهایی را باید وارسی کند. هر مورد فشار دادن شدن کلید به‌عنوان یک رویداد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">KEYDOWN</span><span class="rlm">‏</span> ثبت می‌شود.</p><p>هر گاه پای‌گیم یک رویداد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">KEYDOWN</span><span class="rlm">‏</span> را شناسایی کرد، باید بررسی کنیم ببینیم آیا کلید فشار داده‌شده کلیدی است که نیاز به عمل خاصی دارد یا خیر. مثلاً اگر بازیکن کلید پیکانی راست را فشار دهد، می‌خواهیم که مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect.x</span><span class="rlm">‏</span> سفینه را افزایش دهیم تا سفینه را به سمت راست جابه‌جا کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _check_events(self):</span>
        <span class="ash">"""Respond to keypresses and mouse events."""</span>
        <span class="ash">for event in pygame.event.get():</span>
            <span class="ash">if event.type == pygame.QUIT:</span>
                <span class="ash">sys.exit()</span>
<span class="n" dir="ltr">1</span>            elif event.type == pygame.KEYDOWN:
<span class="n" dir="ltr">2</span>                if event.key == pygame.K_RIGHT:
                    # Move the ship to the right.
<span class="n" dir="ltr">3</span>                    self.ship.rect.x += 1</pre></div><p>در داخل متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_events()</span><span class="rlm">‏</span>، یک بلوک <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">elif</span><span class="rlm">‏</span> در حلقه‌ی رویداد اضافه می‌کنیم تا به شناسایی رویداد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">KEYDOWN</span><span class="rlm">‏</span> پاسخ دهد <span class="n" dir="ltr">1</span>. وارسی می‌کنیم ببینیم که کلید فشار داده‌شده، یعنی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">event.key</span><span class="rlm">‏</span>، کلید پیکانی راست است یا نه <span class="n" dir="ltr">2</span>. کلید پیکانی راست با <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame.K_RIGHT</span><span class="rlm">‏</span> مشخص می‌شود. اگر کلید پیکانی راست فشار داده شده باشد، به مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.ship.rect.x</span><span class="rlm">‏</span> عدد ۱ اضافه می‌کنیم، تا سفینه را به طرف راست جابه‌جا کنیم <span class="n" dir="ltr">3</span>.</p><p>حالا وقتی که <span class="rlm">‏</span><span class="ident" dir="ltr">alien_invasion.py</span><span class="rlm">‏</span> را اجرا می‌کنید، سفینه باید هر بار که کلید پیکانی راست را فشار می‌دهید، یک پیکسل به طرف راست حرکت کند. برای شروع خوب است، ولی این روش کارآمدی برای کنترل سفینه نیست. برای اینکه این کنترل را بهبود بخشیم، می‌توانیم امکان حرکت پیوسته را فراهم کنیم.</p></div><div class="sect" id="ch12lev2sec9"><a class="bkmk" name="ch12lev2sec9"></a><h4>امکان حرکت پیوسته</h4>
<a id="p239"></a><p class="noindent">وقتی که بازیکن کلید پیکانی راست را پایین نگه می‌دارد، می‌خواهیم که کشتی همچنان به حرکت به طرف راست ادامه دهد تا آنکه بازیکن کلید را رها کند. باید بازی رویداد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame.KEYUP</span><span class="rlm">‏</span> را شناسایی کند تا معلوم شود که چه زمانی کلید پیکانی رها می‌شود؛ بعد با استفاده از رویدادهای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">KEYDOWN</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">KEYUP</span><span class="rlm">‏</span> به همراه فلگی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">moving_right</span><span class="rlm">‏</span>، حرکت پیوسته را پیاده‌سازی می‌کنیم.</p><p>وقتی که فلگ <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">moving_right</span><span class="rlm">‏</span> مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">False</span><span class="rlm">‏</span> دارد، سفینه بدون حرکت خواهد بود. وقتی که بازیکن کلید پیکانی راست را فشار می‌دهد، مقدار فلگ را <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">True</span><span class="rlm">‏</span> قرار می‌دهیم، و وقتی که بازیکن کلید را رها می‌کند، مقدار فلگ را دوباره <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">False</span><span class="rlm">‏</span> می‌کنیم.</p><p>کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> تمام صفات سفینه را کنترل می‌کند، ازاین‌رو، یک صفت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">moving_right</span><span class="rlm">‏</span> به آن می‌دهیم و یک متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">update()</span><span class="rlm">‏</span> که وضعیت فلگ <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">moving_right</span><span class="rlm">‏</span> را وارسی می‌کند. متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">update()</span><span class="rlm">‏</span> در صورتی که مقدار فلگ <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">True</span><span class="rlm">‏</span> باشد، مکان سفینه را تغییر می‌دهد. این متد را در هر دور حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">while</span><span class="rlm">‏</span> یک بار فراخوانی می‌کنیم تا مکان سفینه را روزآمد کند.</p><p>تغییرات کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> به‌صورت زیر است:</p><div class="snippet"><div class="snippet-title" dir="ltr">ship.py</div><pre class="snippet" dir="ltr"><span class="ash">class Ship:</span>
    <span class="ash">"""A class to manage the ship."""</span>

    <span class="ash">def __init__(self, ai_game):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash"># Start each new ship at the bottom center of the screen.</span>
        <span class="ash">self.rect.midbottom = self.screen_rect.midbottom</span>

        # Movement flag
<span class="n" dir="ltr">1</span>        self.moving_right = False

<span class="n" dir="ltr">2</span>    def update(self):
        """Update the ship's position based on the movement flag."""
        if self.moving_right:
            self.rect.x += 1

    <span class="ash">def blitme(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span></pre></div><p>صفت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.moving_right</span><span class="rlm">‏</span> را در متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> اضافه می‌کنیم، و در ابتدا به آن مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">False</span><span class="rlm">‏</span> می‌دهیم <span class="n" dir="ltr">1</span>. سپس متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">update()</span><span class="rlm">‏</span> را اضافه می‌کنیم که اگر مقدار فلگ <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">True</span><span class="rlm">‏</span> باشد، سفینه را به راست حرکت می‌دهد <span class="n" dir="ltr">2</span>. متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">update()</span><span class="rlm">‏</span> از طریق یک نمونه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> فراخوانی خواهد شد، بنابراین، یک متد کمکی محسوب نمی‌شود.</p><p>حالا باید <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_events()</span><span class="rlm">‏</span> را تغییر دهیم، به‌طوری که هر گاه کلید پیکانی راست فشار داده می‌شود، مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">moving_right</span><span class="rlm">‏</span> برابر با <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">True</span><span class="rlm">‏</span> شود، و هر گاه رها می‌شود، مقدار آن <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">False</span><span class="rlm">‏</span> شود:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _check_events(self):</span>
        <span class="ash">"""Respond to keypresses and mouse events."""</span>
        <span class="ash">for event in pygame.event.get():</span>
            <span class="ash">--<span class="it">snip</span>--</span>
            <span class="ash">elif event.type == pygame.KEYDOWN:</span>
                <span class="ash">if event.key == pygame.K_RIGHT:</span>
<span class="n" dir="ltr">1</span>                    self.ship.moving_right = True
<span class="n" dir="ltr">2</span>            elif event.type == pygame.KEYUP:
<a id="p240"></a>                if event.key == pygame.K_RIGHT:
                    self.ship.moving_right = False</pre></div><p>در <span class="n" dir="ltr">1</span>، چگونگی پاسخ‌دهی بازی به فشار داده شدن کلید پیکانی راست را تغییر می‌دهیم: به جای اینکه مستقیماً مکان سفینه را تغییر دهیم، صرفاً به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">moving_right</span><span class="rlm">‏</span> مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">True</span><span class="rlm">‏</span> می‌دهیم. در ‎<span class="n" dir="ltr">2</span>، یک بلوک <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">elif</span><span class="rlm">‏</span> جدید اضافه می‌کنیم، که به رویدادهای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">KEYUP</span><span class="rlm">‏</span> پاسخ می‌دهد. وقتی که بازیکن کلید پیکانی راست (<span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">K_RIGHT</span><span class="rlm">‏</span>) را رها می‌کند، به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">moving_right</span><span class="rlm">‏</span> مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">False</span><span class="rlm">‏</span> اختصاص می‌دهیم.</p><p>سپس، حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">while</span><span class="rlm">‏</span> را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">run_game()</span><span class="rlm">‏</span> تغییر می‌دهیم، به‌طوری که در هر دور حلقه، متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">update()</span><span class="rlm">‏</span> را فراخوانی کند:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def run_game(self):</span>
        <span class="ash">"""Start the main loop for the game."""</span>
        <span class="ash">while True:</span>
            <span class="ash">self._check_events()</span>
            self.ship.update()
            <span class="ash">self._update_screen()</span></pre></div><p>پس از آنکه وارسی از نظر رویدادهای صفحه‌کلید انجام شد، و قبل از نوسازی صفحه‌ی نمایش، مکان سفینه روزآمد می‌شود. به این ترتیب، مکان سفینه در پاسخ به ورودی کاربر روزآمد می‌شود، و مکان جدید روی صفحه نمایش داده می‌شود.</p><p>وقتی که <span class="rlm">‏</span><span class="ident" dir="ltr">alien_invasion.py</span><span class="rlm">‏</span> را اجرا کنید و کلید پیکانی راست را پایین نگه دارید، سفینه به‌طور پیوسته به طرف راست حرکت خواهد کرد تا زمانی که کلید را رها کنید.</p></div><div class="sect" id="ch12lev2sec10"><a class="bkmk" name="ch12lev2sec10"></a><h4>حرکت به چپ و راست</h4>
<p class="noindent">حالا که سفینه می‌تواند به‌طور پیوسته به طرف راست حرکت کند، اضافه کردن حرکت به طرف چپ کار راحتی است. دوباره کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> و متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_events()</span><span class="rlm">‏</span> را تغییر می‌دهیم. در اینجا تغییرات انجام شده در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">update()</span><span class="rlm">‏</span> را در کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> می‌بینید:</p><div class="snippet"><div class="snippet-title" dir="ltr">ship.py</div><pre class="snippet" dir="ltr">    <span class="ash">def __init__(self, ai_game):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        # Movement flags
        <span class="ash">self.moving_right = False</span>
        self.moving_left = False

    <span class="ash">def update(self):</span>
        """Update the ship's position based on movement flags."""
        <span class="ash">if self.moving_right:</span>
            <span class="ash">self.rect.x += 1</span>
        if self.moving_left:
            self.rect.x -= 1</pre></div><p>در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span>، یک فلگ <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.moving_left</span><span class="rlm">‏</span> اضافه می‌کنیم. در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">update()</span><span class="rlm">‏</span>، از دو بلوک <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">if</span><span class="rlm">‏</span> جداگانه استفاده می‌کنیم، نه یک بلوک <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">elif</span><span class="rlm">‏</span>، تا اگر هر دو کلید پیکانی پایین نگه داشته شوند، مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect.x</span><span class="rlm">‏</span> سفینه افزایش و سپس کاهش داده شود. این سبب می‌شود که سفینه سر جای خود بی‌حرکت بماند. اگر برای حرکت به چپ از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">elif</span><span class="rlm">‏</span> استفاده می‌کردیم، <a id="p241"></a>کلید پیکانی راست همیشه اولویت می‌داشت. انجام کار به روشی که گفتیم، سبب می‌شود که حرکت دقیق‌تر باشد، چرا که در حین حرکت از راست به چپ ممکن است بازیکن چند لحظه هر دو کلید را پایین نگه دارد.</p><p>باید دو تغییر در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_events()</span><span class="rlm">‏</span> ایجاد کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _check_events(self):</span>
        <span class="ash">"""Respond to keypresses and mouse events."""</span>
        <span class="ash">for event in pygame.event.get():</span>
            <span class="ash">--<span class="it">snip</span>--</span>
            <span class="ash">elif event.type == pygame.KEYDOWN:</span>
                <span class="ash">if event.key == pygame.K_RIGHT:</span>
                    <span class="ash">self.ship.moving_right = True</span>
                elif event.key == pygame.K_LEFT:
                    self.ship.moving_left = True

            <span class="ash">elif event.type == pygame.KEYUP:</span>
                <span class="ash">if event.key == pygame.K_RIGHT:</span>
                    <span class="ash">self.ship.moving_right = False</span>
                elif event.key == pygame.K_LEFT:
                    self.ship.moving_left = False</pre></div><p>اگر یک رویداد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">KEYDOWN</span><span class="rlm">‏</span> برای کلید <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">K_LEFT</span><span class="rlm">‏</span> بروز کند، مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">moving_left</span><span class="rlm">‏</span> را <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">True</span><span class="rlm">‏</span> قرار می‌دهیم. اگر رویداد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">KEYUP</span><span class="rlm">‏</span> برای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">K_LEFT</span><span class="rlm">‏</span> رخ دهد، مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">moving_left</span><span class="rlm">‏</span> را <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">False</span><span class="rlm">‏</span> قرار می‌دهیم. در اینجا می‌توانیم از بلوک‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">elif</span><span class="rlm">‏</span> استفاده کنیم، زیرا هر رویداد فقط با یک کلید در ارتباط است. اگر بازیکن هر دو کلید را هم‌زمان با هم فشار دهد، دو رویداد جداگانه شناسایی خواهد شد.</p><p>اکنون وقتی که <span class="rlm">‏</span><span class="ident" dir="ltr">alien_invasion.py</span><span class="rlm">‏</span> را اجرا می‌کنید، قادر خواهید بود سفینه را به‌طور پیوسته به طرف راست و چپ حرکت دهید. اگر هر دو کلید را پایین نگه دارید، سفینه بی‌حرکت می‌ماند.</p><p>بعد می‌خواهیم حرکات سفینه را دقیق‌تر کنیم. بهتر است سرعت سفینه را تنظیم کنیم و حدی برای حرکت آن تعیین کنیم تا از کناره‌های صفحه خارج نشود.</p></div><div class="sect" id="ch12lev2sec11"><a class="bkmk" name="ch12lev2sec11"></a><h4>تنظیم سرعت سفینه</h4>
<p class="noindent">در حال حاضر، سفینه در هر دور حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">while</span><span class="rlm">‏</span> فقط یک پیکسل حرکت می‌کند، ولی می‌توانیم با افزودن یک صفت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">ship_speed</span><span class="rlm">‏</span> به کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Settings</span><span class="rlm">‏</span>، کنترل دقیق‌تری بر سرعت سفینه به دست آوریم. با استفاده از این صفت، معلوم خواهد شد که در هر دور حلقه سفینه چقدر باید جابه‌جا شود. در اینجا صفت جدید را به <span class="rlm">‏</span><span class="ident" dir="ltr">settings.py</span><span class="rlm">‏</span> اضافه کرده‌ایم:</p><div class="snippet"><div class="snippet-title" dir="ltr">settings.py</div><pre class="snippet" dir="ltr"><span class="ash">class Settings:</span>
    <span class="ash">"""A class to store all settings for Alien Invasion."""</span>

    <span class="ash">def __init__(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>

        # Ship settings
        self.ship_speed = 1.5</pre></div><a id="p242"></a><p>مقدار اولیه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">ship_speed</span><span class="rlm">‏</span> را <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">1.5</span><span class="rlm">‏</span> تعیین می‌کنیم. اکنون وقتی که سفینه حرکت می‌کند، مکان آن در هر دور حلقه، به جای ۱ پیکسل، ۱٫۵ پیکسل جابه‌جا می‌شود.</p><p>برای تنظیم سرعت از عدد اعشاری استفاده کرده‌ایم تا بعداً که بخواهیم آهنگ حرکت سفینه را افزایش دهیم، کنترل دقیق‌تری بر روی سرعت سفنیه داشته باشیم. اما صفت‌های مستطیل، مانند <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">x</span><span class="rlm">‏</span>، فقط مقادیر صحیح را ذخیره می‌کنند، بنابراین، لازم است که تغییراتی در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> اعمال کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">ship.py</div><pre class="snippet" dir="ltr"><span class="ash">class Ship:</span>
    <span class="ash">"""A class to manage the ship."""</span>

<span class="n" dir="ltr">1</span>    <span class="ash">def __init__(self, ai_game):</span>
        <span class="ash">"""Initialize the ship and set its starting position."""</span>
        <span class="ash">self.screen = ai_game.screen</span>
        self.settings = ai_game.settings
        <span class="ash">--<span class="it">snip</span>--</span>

        <span class="ash"># Start each new ship at the bottom center of the screen.</span>
        <span class="ash">--<span class="it">snip</span>--</span>

        # Store a decimal value for the ship's horizontal position.
<span class="n" dir="ltr">2</span>        self.x = float(self.rect.x)

        <span class="ash"># Movement flags</span>
        <span class="ash">self.moving_right = False</span>
        <span class="ash">self.moving_left = False</span>

    <span class="ash">def update(self):</span>
        <span class="ash">"""Update the ship's position based on movement flags."""</span>
        # Update the ship's x value, not the rect.
        <span class="ash">if self.moving_right:</span>
<span class="n" dir="ltr">3</span>            self.x += self.settings.ship_speed
        <span class="ash">if self.moving_left:</span>
            self.x -= self.settings.ship_speed

        # Update rect object from self.x.
<span class="n" dir="ltr">4</span>        self.rect.x = self.x

    <span class="ash">def blitme(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span></pre></div><p>صفت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">settings</span><span class="rlm">‏</span> را برای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> ایجاد می‌کنیم، تا بتوانیم در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">update()</span><span class="rlm">‏</span> از آن استفاده کنیم <span class="n" dir="ltr">1</span>. از آنجا که می‌خواهیم مکان سفینه را بر حسب اعشار پیکسل تغییر دهیم، لازم است که مکان را به متغیری اختصاص دهیم که بتواند مقادیر اعشاری را ذخیره کند. شما می‌توانید مقادیر اعشاری را به صفت‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> اختصاص دهید، ولی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> فقط جزء صحیح آن مقدار را حفظ می‌کند. برای اینکه مکان دقیق سفینه را داشته باشیم، یک صفت جدید <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.x</span><span class="rlm">‏</span> را تعریف می‌کنیم که می‌تواند مقادیر اشعاری را ذخیره کند <span class="n" dir="ltr">2</span>. از تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">float()</span><span class="rlm">‏</span> برای تبدیل کردن مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.rect.x</span><span class="rlm">‏</span> به اعشاری استفاده می‌کنیم و این مقدار را به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.x</span><span class="rlm">‏</span> اختصاص می‌دهیم.</p><p>حالا وقتی که مکان سفینه را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">update()</span><span class="rlm">‏</span> تغییر می‌دهیم، مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.x</span><span class="rlm">‏</span> بر اساس مقدار ذخیره شده در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">settings.ship_speed</span><span class="rlm">‏</span> تغییر می‌کند <span class="n" dir="ltr">3</span>. پس از تغییر دادن <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.x</span><span class="rlm">‏</span>، با استفاده از مقدار جدید، مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.rect.x</span><span class="rlm">‏</span> را به‌روز می‌کنیم، که <a id="p243"></a>مکان سفینه را کنترل می‌کند <span class="n" dir="ltr">4</span>. تنها بخش صحیح <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.x</span><span class="rlm">‏</span> در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.rect.x</span><span class="rlm">‏</span> ذخیره خواهد شد، ولی این از نظر نمایش سفینه مشکلی ایجاد نمی‌کند.</p><p>حالا می‌توانیم مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">ship_speed</span><span class="rlm">‏</span> را تغییر دهیم، و هر مقدار بزرگ‌تر از یک سبب خواهد شد که سفینه تندتر حرکت کند. به این ترتیب، سرعت سفینه آن‌قدر خواهد بود که بتوان بیگانه‌ها را ساقط کرد، و خواهیم توانست با پیشرفت کار بازیکن، آهنگ بازی را تغییر دهیم.</p><div class="note"><h6 class="note-title">توجه</h6>
<p class="noindent">اگر از <span class="rlm">‏</span><span class="lr" dir="ltr">macOS</span><span class="rlm">‏</span> استفاده می‌کنید، شاید مشاهده کنید که سفینه، حتی با تنظیم سرعت بالا، خیلی کند حرکت می‌کند. برای حل این مشکل، می‌توانید بازی را در حالت تمام‌صفحه اجرا کنید، که بعداً آن را پیاده‌سازی خواهیم کرد.</p></div></div><div class="sect" id="ch12lev2sec12"><a class="bkmk" name="ch12lev2sec12"></a><h4>محدود کردن دامنه‌ی حرکت سفینه</h4>
<p class="noindent">در حال حاضر، اگر مقدار زیادی به سمت راست یا چپ حرکت کنید، سفینه از کنار صفحه خارج می‌شود. می‌خواهیم این وضعیت را اصلاح کنیم، تا وقتی سفینه به کنار صفحه رسید، توقف کند. برای این منظور، متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">update()</span><span class="rlm">‏</span> را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> تغییر می‌دهیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">ship.py</div><pre class="snippet" dir="ltr">    <span class="ash">def update(self):</span>
        <span class="ash">"""Update the ship's position based on movement flags."""</span>
        <span class="ash"># Update the ship's x value, not the rect.</span>
<span class="n" dir="ltr">1</span>        if self.moving_right and self.rect.right &lt; self.screen_rect.right:
            <span class="ash">self.x += self.settings.ship_speed</span>
<span class="n" dir="ltr">2</span>        if self.moving_left and self.rect.left &gt; 0:
            <span class="ash">self.x -= self.settings.ship_speed</span>

        <span class="ash"># Update rect object from self.x.</span>
        <span class="ash">self.rect.x = self.x</span></pre></div><p>این کد مکان سفینه را قبل از تغییر دادن مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.x</span><span class="rlm">‏</span> وارسی می‌کند. کد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.rect.right</span><span class="rlm">‏</span> مختصه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> لبه‌ی راست <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> مربوط به سفینه را به دست می‌دهد. اگر این مقدار کوچک‌تر از مقدار حاصل از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.screen_rect.right</span><span class="rlm">‏</span> باشد، هنوز سفینه به لبه‌ی راست صفحه نرسیده است <span class="n" dir="ltr">1</span>. در مورد لبه‌ی چپ نیز همین طور است: اگر مقدار لبه‌ی چپ <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> بزرگ‌تر از صفر باشد، یعنی سفینه هنوز به لبه‌ی چپ صفحه نرسیده است <span class="n" dir="ltr">2</span>. این بدان معنا است که سفینه قبل از تغییر دادن مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.x</span><span class="rlm">‏</span>، در داخل این کران‌ها است.</p><p>اکنون وقتی <span class="rlm">‏</span><span class="ident" dir="ltr">alien_invasion.py</span><span class="rlm">‏</span> را اجرا می‌کنید، سفینه باید  در لبه‌ی راست یا چپ صفحه توقف کند. این خیلی باحال است؛ تنها کاری که کردیم، این است که یک شرط دیگر در یک دستورالعمل <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">if</span><span class="rlm">‏</span> اضافه کردیم، ولی حالا حس می‌شود که سفینه در لبه‌ی صفحه به یک دیوار یا میدان نیرو برخورد می‌کند!</p></div><div class="sect" id="ch12lev2sec13"><a class="bkmk" name="ch12lev2sec13"></a><h4>بازساخت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_events()</span><span class="rlm">‏</span></h4>
<p class="noindent">به تدریج که به برنامه‌نویسی بازی ادامه می‌دهیم، طول متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_events()</span><span class="rlm">‏</span> بیشتر می‌شود، بنابراین، بد نیست که در اینجا متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_events()</span><span class="rlm">‏</span> را به دو متد دیگر تقسیم کنیم: یک متد برای رسیدگی به رویدادهای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">KEYDOWN</span><span class="rlm">‏</span> و متد دیگر برای رسیدگی به رویدادهای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">KEYUP</span><span class="rlm">‏</span>:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _check_events(self):</span>
        <span class="ash">"""Respond to keypresses and mouse events."""</span>
        <span class="ash">for event in pygame.event.get():</span>
<a id="p244"></a>            <span class="ash">if event.type == pygame.QUIT:</span>
                <span class="ash">sys.exit()</span>
            <span class="ash">elif event.type == pygame.KEYDOWN:</span>
                self._check_keydown_events(event)
            <span class="ash">elif event.type == pygame.KEYUP:</span>
                self._check_keyup_events(event)

    def _check_keydown_events(self, event):
        """Respond to keypresses."""
        <span class="ash">if event.key == pygame.K_RIGHT:</span>
            <span class="ash">self.ship.moving_right = True</span>
        <span class="ash">elif event.key == pygame.K_LEFT:</span>
            <span class="ash">self.ship.moving_left = True</span>

    def _check_keyup_events(self, event):
        """Respond to key releases."""
        <span class="ash">if event.key == pygame.K_RIGHT:</span>
            <span class="ash">self.ship.moving_right = False</span>
        <span class="ash">elif event.key == pygame.K_LEFT:</span>
            <span class="ash">self.ship.moving_left = False</span></pre></div><p>دو متد کمکی دیگر ایجاد کردیم: <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_keydown_events()</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_keyup_events()</span><span class="rlm">‏</span>. هر کدام از این‌ها نیاز به یک پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self</span><span class="rlm">‏</span> دارد و یک پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">event</span><span class="rlm">‏</span>. بدنه‌ی این دو متد از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_events()</span><span class="rlm">‏</span> کپی شده است، و به جای کد قبلی، فراخوانی این دو متد گذاشته می‌شود. اکنون متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_events()</span><span class="rlm">‏</span> با این ساختار ساده‌تر، پاکیزه‌تر شده است، و توسعه‌ی پاسخ‌گویی به سایر ورودی‌های بازیکن آسان‌تر خواهد بود.</p></div><div class="sect" id="ch12lev2sec14"><a class="bkmk" name="ch12lev2sec14"></a><h4>فشار دادن کلید <span class="rlm">‏</span><span class="key" dir="ltr">q</span><span class="rlm">‏</span> برای خروج</h4>
<p class="noindent">اکنون که می‌توانیم به‌صورت کارآمدی به فشار داده شدن کلیدها پاسخ دهیم، می‌توانیم راه دیگری نیز برای خروج از برنامه اضافه کنیم. اینکه هر بار می‌خواهید ویژگی جدیدی را آزمایش کنید، لازم باشد که روی <span class="rlm">‏</span><span class="lr" dir="ltr">X</span><span class="rlm">‏</span> در گوشه‌ی پنجره‌ی بازی کلیک کنید، کار پرزحمتی است، بنابراین، یک میان‌بر صفحه‌کلید اضافه می‌کنیم که هر وقت کلید <span class="rlm">‏</span><span class="key" dir="ltr">q</span><span class="rlm">‏</span> را فشار دهید، بازی تمام شود:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _check_keydown_events(self, event):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash">elif event.key == pygame.K_LEFT:</span>
            <span class="ash">self.ship.moving_left = True</span>
        elif event.key == pygame.K_q:
            sys.exit()</pre></div><p>در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_keydown_events()</span><span class="rlm">‏</span>، یک بلوک جدید اضافه می‌کنیم که وقتی بازیکن کلید <span class="rlm">‏</span><span class="key" dir="ltr">q</span><span class="rlm">‏</span> را فشار دهد، بازی را تمام می‌کند. حالا می‌توانید موقع آزمایش کردن بازی، به جای اینکه پنجره را با نشانگر ماوس ببندید، کلید <span class="rlm">‏</span><span class="key" dir="ltr">q</span><span class="rlm">‏</span> را فشار دهید.</p></div><div class="sect" id="ch12lev2sec15"><a class="bkmk" name="ch12lev2sec15"></a><h4>اجرا کردن بازی در حالت تمام‌صفحه</h4>
<p class="noindent">پای‌گیم یک حالت تمام‌صفحه دارد که شاید برای شما مناسب‌تر از اجرا کردن بازی در پنجره‌ی معمولی باشد. بعضی از بازی‌ها در حالت تمام‌صفحه منظره‌ی بهتری دارند، و کاربران <span class="rlm">‏</span><span class="lr" dir="ltr">macOS</span><span class="rlm">‏</span> ممکن است در حالت تمام‌صفحه شاهد عملکرد بهتری باشند.</p><a id="p245"></a><p>برای اجرای بازی در حالت تمام‌صفحه، تغییرات زیر را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> اعمال کنید:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def __init__(self):</span>
        <span class="ash">"""Initialize the game, and create game resources."""</span>
        <span class="ash">pygame.init()</span>
        <span class="ash">self.settings = Settings()</span>

<span class="n" dir="ltr">1</span>        self.screen = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)
<span class="n" dir="ltr">2</span>        self.settings.screen_width = self.screen.get_rect().width
        self.settings.screen_height = self.screen.get_rect().height
        <span class="ash">pygame.display.set_caption("Alien Invasion")</span></pre></div><p>هنگام ایجاد سطح صفحه، انداز‌ه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">(0, 0)</span><span class="rlm">‏</span> و پارامتر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame.FULLSCREEN</span><span class="rlm">‏</span> را به آن می‌دهیم <span class="n" dir="ltr">1</span>. این به پای‌گیم می‌گوید که اندازه‌ی پنجره را به‌گونه‌ای تعیین کند که تمام‌صفحه‌ی نمایش را پر کند. از آنجا که عرض و طول صفحه‌ی نمایش را از قبل نمی‌دانیم، این اطلاعات را پس از ایجاد صفحه می‌گیریم <span class="n" dir="ltr">2</span>. از صفت‌های <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">width</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">height</span><span class="rlm">‏</span> مستطیل صفحه‌ی نمایش استفاده می‌کنیم و این اطلاعات را به شیء <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">settings</span><span class="rlm">‏</span> می‌دهیم.</p><p>اگر منظره و رفتار بازی در حالت تمام‌صفحه بهتر بود، می‌توانید این تنظیمات را حفظ کنید. ولی اگر فکر می‌کنید اجرای بازی در داخل پنجره بهتر است، می‌توانید به همان رویکرد اولیه برگردید که در آن انداز‌ه‌ی مشخصی را برای پنجره‌ی بازی تعیین کردیم.</p><div class="note"><h6 class="note-title">توجه</h6>
<p class="noindent">قبل از آنکه بازی را در حالت تمام‌صفحه اجرا کنید، مطمئن شوید که می‌توانید با فشار دادن <span class="rlm">‏</span><span class="key" dir="ltr">q</span><span class="rlm">‏</span> از بازی خارج شوید؛ پای‌گیم راه پیش‌فرضی برای خارج شدن از بازی در حالت تمام‌صفحه ندارد.</p></div></div></div><div class="sect" id="ch12lev1sec7"><a class="bkmk" name="ch12lev1sec7"></a><h3>مرور سریع</h3>
<p class="noindent">در قسمت بعد، امکان شلیک گلوله را اضافه خواهیم کرد، که شامل افزودن فایل جدیدی به نام <span class="rlm">‏</span><span class="ident" dir="ltr">bullet.py</span><span class="rlm">‏</span>، و انجام تغییراتی در برخی از فایل‌های موجود است. در حال حاضر، سه فایل داریم که حاوی تعدادی کلاس و متد هستند. برای اینکه سازمان‌دهی پروژه مشخص باشد، قبل از افزودن قابلیت‌های جدید، هر کدام از این فایل‌ها را مرور می‌کنیم.</p><div class="sect" id="ch12lev2sec16"><a class="bkmk" name="ch12lev2sec16"></a><h4><span class="rlm">‏</span><span class="ident" dir="ltr">alien_invasion.py</span><span class="rlm">‏</span></h4>
<p class="noindent">فایل اصلی، <span class="rlm">‏</span><span class="ident" dir="ltr">alien_invasion.py</span><span class="rlm">‏</span>، حاوی کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AlienInvasion</span><span class="rlm">‏</span> است. این کلاس چند صفت مهم را ایجاد می‌کند که در سرتاسر بازی استفاده می‌شود: شیء تنظیمات به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">settings</span><span class="rlm">‏</span> اختصاص داده می‌شود، سطح نمایش اصلی به صفت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">screen</span><span class="rlm">‏</span> اختصاص داده می‌شود، و یک نمونه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> نیز در این فایل ایجاد می‌شود. حلقه‌ی اصلی بازی، حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">while</span><span class="rlm">‏</span>، نیز در این مدول ذخیره می‌شود. حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">while</span><span class="rlm">‏</span> متدهای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_events()</span><span class="rlm">‏</span>، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">ship.update()</span><span class="rlm">‏</span>، و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_update_screen()</span><span class="rlm">‏</span> را فراخوانی می‌کند.</p><p>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_events()</span><span class="rlm">‏</span> رویدادهای مرتبط، از قبیل فشار داده شدن و رها شدن کلیدها، را شناسایی می‌کند و هر نوع از این رویدادها را از طریق متدهای <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_keydown_events()</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_keyup_events()</span><span class="rlm">‏</span> پردازش می‌کند. در حال حاضر، <a id="p246"></a>این متدها حرکت سفینه را مدیریت می‌کنند. کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AlienInvasion</span><span class="rlm">‏</span> حاوی متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_update_screen()</span><span class="rlm">‏</span> نیز هست که در هر دور حلقه‌ی اصلی، صفحه‌ی نمایش را بازترسیم می‌کند.</p><p>فایل <span class="rlm">‏</span><span class="ident" dir="ltr">alien_invasion.py</span><span class="rlm">‏</span> تنها فایلی است که برای اجرای بازی <span class="emphasis">تهاجم بیگانگان</span>  باید اجرا شود. بقیه‌ی فایل‌ها—<span class="rlm">‏</span><span class="ident" dir="ltr">settings.py</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="ident" dir="ltr">ship.py</span><span class="rlm">‏</span>—حاوی کدی هستند که به داخل این فایل ایمپورت می‌شود.</p></div><div class="sect" id="ch12lev2sec17"><a class="bkmk" name="ch12lev2sec17"></a><h4><span class="rlm">‏</span><span class="ident" dir="ltr">settings.py</span><span class="rlm">‏</span></h4>
<p class="noindent">فایل <span class="rlm">‏</span><span class="ident" dir="ltr">settings.py</span><span class="rlm">‏</span> حاوی کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Settings</span><span class="rlm">‏</span> است. این کلاس یک متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> دارد که مقدار اولیه‌ی لازم را به صفت‌های کنترل کننده‌ی منظره‌ی بازی و سرعت سفینه می‌دهد.</p></div><div class="sect" id="ch12lev2sec18"><a class="bkmk" name="ch12lev2sec18"></a><h4><span class="rlm">‏</span><span class="ident" dir="ltr">ship.py</span><span class="rlm">‏</span></h4>
<p class="noindent">فایل <span class="rlm">‏</span><span class="ident" dir="ltr">ship.py</span><span class="rlm">‏</span> حاوی کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> است. کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Ship</span><span class="rlm">‏</span> یک متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span>، یک متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">update()</span><span class="rlm">‏</span> برای مدیریت موقعیت سفینه، و یک متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">blitme()</span><span class="rlm">‏</span> برای ترسیم سفینه روی صفحه دارد. تصویر سفینه در فایل <span class="rlm">‏</span><span class="ident" dir="ltr">ship.bmp</span><span class="rlm">‏</span> ذخیره شده است که در پوشه‌ی <span class="rlm">‏</span><span class="ident" dir="ltr">images</span><span class="rlm">‏</span> قرار دارد.</p><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<p class="tiy1"><span class="tiy" id="ch12_tiy03"><span class="tiy-num">۱۲-۳</span>. <span class="tiy-title">مستندات پای‌گیم</span>: </span> اکنون به قدری در بازی جلو رفته‌ایم که شاید بد نباشد نگاهی به مستندات پای‌گیم بیندازید. وب‌سایت پای‌گیم در نشانی <span class="rlm">‏</span><a dir="ltr" target="_blank" href="https://www.pygame.org/">pygame.org</a><span class="rlm">‏</span> قرار دارد، و مستندات آن در نشانی <span class="rlm">‏</span><a dir="ltr" target="_blank" href="https://www.pygame.org/docs/">pygame.org/docs/</a><span class="rlm">‏</span> است. فعلاً نگاهی به مستندات بیندازید. برای تکمیل پروژه نیازی به آن ندارید، ولی اگر بخواهید تغییری در بازی <span class="emphasis">تهاجم بیگانگان</span> بدهید یا بعداً بخواهید بازی دیگری بسازید، برایتان مفید خواهد بود.</p><p class="tiy1"><span class="tiy" id="ch12_tiy04"><span class="tiy-num">۱۲-۴</span>. <span class="tiy-title">راکت</span>: </span> یک بازی بسازید که با یک راکت در وسط صفحه شروع می‌شود. کاری کنید که بازیکن بتواند با استفاده از چهار کلید پیکانی، راکت را به بالا، پایین، چپ، یا راست حرکت دهد. دقت کنید که راکت هیچ‌گاه از لبه‌های صفحه خارج نشود.</p><p class="tiy1"><span class="tiy" id="ch12_tiy05"><span class="tiy-num">۱۲-۵</span>. <span class="tiy-title">کلیدها</span>: </span> یک بازی پای‌گیم بسازید که یک صفحه‌ی خالی ایجاد می‌کند. در حلقه‌ی رویداد، هر گاه رویداد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame.KEYDOWN</span><span class="rlm">‏</span> شناسایی می‌شود، صفت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">event.key</span><span class="rlm">‏</span> را نمایش دهید. برنامه را اجرا کنید و کلیدهای مختلف را بزنید تا ببینید پای‌گیم چگونه پاسخ می‌دهد.</p></div></div></div><div class="sect" id="ch12lev1sec8"><a class="bkmk" name="ch12lev1sec8"></a><h3>شلیک گلوله</h3>
<p class="noindent">حالا می‌خواهیم قابلیت شلیک گلوله را اضافه کنیم. کدی می‌نویسیم که وقتی بازیکن کلید اسپیس را فشار می‌دهد، یک گلوله شلیک می‌کند که با یک مستطیل کوچک نمایش داده می‌شود. سپس گلوله در صفحه مستقیم به سمت بالا حرکت می‌کند تا آنکه در بالای صفحه ناپدید می‌شود.</p><div class="sect" id="ch12lev2sec19"><a class="bkmk" name="ch12lev2sec19"></a><h4>اضافه کردن تنظیمات گلوله</h4>
<a id="p247"></a><p class="noindent">در انتهای متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> در فایل <span class="rlm">‏</span><span class="ident" dir="ltr">settings.py</span><span class="rlm">‏</span>، مقادیری را که برای کلاس جدید <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Bullet</span><span class="rlm">‏</span> لازم داریم، اضافه می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">settings.py</div><pre class="snippet" dir="ltr">    <span class="ash">def __init__(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        # Bullet settings
        self.bullet_speed = 1.0
        self.bullet_width = 3
        self.bullet_height = 15
        self.bullet_color = (60, 60, 60)</pre></div><p>این تنظیمات گلوله‌های خاکستری تیره‌ای را به عرض ۳ پیکسل و ارتفاع ۱۵ پیکسل ایجاد می‌کنند. این گلوله‌ها کمی آهسته‌تر از سفینه حرکت خواهند کرد.</p></div><div class="sect" id="ch12lev2sec20"><a class="bkmk" name="ch12lev2sec20"></a><h4>ایجاد کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Bullet</span><span class="rlm">‏</span></h4>
<p class="noindent">حالا فایلی به نام <span class="rlm">‏</span><span class="ident" dir="ltr">bullet.py</span><span class="rlm">‏</span> برای کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Bullet</span><span class="rlm">‏</span> ایجاد می‌کنیم. بخش اول <span class="rlm">‏</span><span class="ident" dir="ltr">bullet.py</span><span class="rlm">‏</span> به‌صورت زیر است:</p><div class="snippet"><div class="snippet-title" dir="ltr">bullet.py</div><pre class="snippet" dir="ltr">import pygame
from pygame.sprite import Sprite

class Bullet(Sprite):
    """A class to manage bullets fired from the ship"""

    def __init__(self, ai_game):
        """Create a bullet object at the ship's current position."""
        super().__init__()
        self.screen = ai_game.screen
        self.settings = ai_game.settings
        self.color = self.settings.bullet_color

        # Create a bullet rect at (0, 0) and then set correct position.
<span class="n" dir="ltr">1</span>        self.rect = pygame.Rect(0, 0, self.settings.bullet_width,
            self.settings.bullet_height)
<span class="n" dir="ltr">2</span>        self.rect.midtop = ai_game.ship.rect.midtop

        # Store the bullet's position as a decimal value.
<span class="n" dir="ltr">3</span>        self.y = float(self.rect.y)</pre></div><p>کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Bullet</span><span class="rlm">‏</span> از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Sprite</span><span class="rlm">‏</span> مشتق می‌شود، که آن را از مدول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame.sprite</span><span class="rlm">‏</span> ایمپورت می‌کنیم. وقتی که از اسپرایت استفاده می‌کنید، می‌توانید عناصر مرتبط را در بازی گروه‌بندی کنید و روی همه‌ی آن‌ها با هم کار کنید. برای ایجاد نمونه‌ی گلوله، متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> نیاز به نمونه‌ی فعلی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AlienInvasion</span><span class="rlm">‏</span> دارد، و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">super()</span><span class="rlm">‏</span> را هم فراخوانی می‌کنیم تا توارث از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Sprite</span><span class="rlm">‏</span> به درستی صورت گیرد. هم‌چنین، صفت‌های مربوط به شیء صفحه‌ی نمایش و تنظیمات، و نیز صفت مربوط به رنگ گلوله را تعیین می‌کنیم.</p><p>در <span class="n" dir="ltr">1</span>، صفت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> گلوله را ایجاد می‌کنیم. گلوله از عکس استفاده نمی‌کند، بنابراین، باید مستطیل را خودمان با استفاده از کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame.Rect()</span><span class="rlm">‏</span> بسازیم. این کلاس نیاز به مختصات <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> گوشه‌ی بالای چپ <a id="p248"></a><span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> و طول و عرض <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> دارد. در ابتدا، <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> را در <span class="rlm">‏</span><span class="lr" dir="ltr">(0, 0)</span><span class="rlm">‏</span> قرار می‌دهیم، ولی در سطر بعد آن را به مکان صحیح انتقال خواهیم داد، زیرا موقعیت گلوله بستگی به موقعیت سفینه دارد. طول و عرض گلوله را از مقادیر ذخیره شده در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.settings</span><span class="rlm">‏</span> می‌گیریم.</p><p>در <span class="n" dir="ltr">2</span>، مقدار صفت <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">midtop</span><span class="rlm">‏</span> گلوله را مطابق با <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">midtop</span><span class="rlm">‏</span> سفینه تعیین می‌کنیم. این سبب می‌شود که گلوله از بالای سفینه ظاهر شود، انگار که گلوله از سفینه شلیک می‌شود. برای مختصه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> گلوله یک مقدار اعشاری ذخیره می‌کنیم، تا بتوانیم سرعت گلوله را دقیق تنظیم کنیم <span class="n" dir="ltr">3</span>.</p><p>بخش دوم <span class="rlm">‏</span><span class="ident" dir="ltr">bullet.py</span><span class="rlm">‏</span>، شامل <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">update()</span><span class="rlm">‏</span> و <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">draw_bullet()</span><span class="rlm">‏</span>، به‌صورت زیر است:</p><div class="snippet"><div class="snippet-title" dir="ltr">bullet.py</div><pre class="snippet" dir="ltr">    def update(self):
        """Move the bullet up the screen."""
        # Update the decimal position of the bullet.
<span class="n" dir="ltr">1</span>        self.y -= self.settings.bullet_speed
        # Update the rect position.
<span class="n" dir="ltr">2</span>        self.rect.y = self.y

    def draw_bullet(self):
        """Draw the bullet to the screen."""
<span class="n" dir="ltr">3</span>        pygame.draw.rect(self.screen, self.color, self.rect)</pre></div><p>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">update()</span><span class="rlm">‏</span> موقعیت گلوله را مدیریت می‌کند. وقتی که گلوله‌ای شلیک می‌شود، به طرف بالای صفحه حرکت می‌کند، که به معنای کاهش یافتن مقدار مختصه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> است. برای به‌روز کردن موقعیت گلوله، مقدار ذخیره شده در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">settings.bullet_speed</span><span class="rlm">‏</span> را از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.y</span><span class="rlm">‏</span> کم می‌کنیم <span class="n" dir="ltr">1</span>. سپس با استفاده از مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.y</span><span class="rlm">‏</span>، مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.rect.y</span><span class="rlm">‏</span> را تعیین می‌کنیم <span class="n" dir="ltr">2</span>.</p><p>تنظیم <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">bullet_speed</span><span class="rlm">‏</span> به ما امکان می‌دهد که سرعت گلوله را مطابق با شرایط بازی افزایش دهیم. وقتی که گلوله شلیک می‌شود، مقدار مختصه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">x</span><span class="rlm">‏</span> را هرگز تغییر نمی‌دهیم، بنابراین، گلوله به‌طور عمودی در خط مستقیم حرکت می‌کند، ولو آنکه سفینه جابه‌جا شود.</p><p>وقتی که می‌خواهیم یک گلوله را ترسیم کنیم، متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">draw_bullet()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم. تابع <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">draw.rect()</span><span class="rlm">‏</span> بخشی از صفحه را که با <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> گلوله مشخص شده است، با رنگ ذخیره شده در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.color</span><span class="rlm">‏</span> پر می‌کند <span class="n" dir="ltr">3</span>.</p></div><div class="sect" id="ch12lev2sec21"><a class="bkmk" name="ch12lev2sec21"></a><h4>ذخیره کردن گلوله‌ها به‌صورت گروه</h4>
<p class="noindent">حالا که کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Bullet</span><span class="rlm">‏</span> را داریم و تنظمیات مربوط به آن را تعریف کرده‌ایم، می‌توانیم کدی بنویسیم که هر بار بازیکن دکمه‌ی اسپیس را فشار می‌دهد، یک گلوله شلیک کند. گروهی در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AlienInvasion</span><span class="rlm">‏</span> برای ذخیره کردن گلوله‌ها ایجاد می‌کنیم تا بتوانیم تعداد گلوله‌های شلیک شده را مدیریت کنیم. این گروه نمونه‌ای از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">pygame.sprite.Group</span><span class="rlm">‏</span> خواهد بود و قابلیت‌هایی را به آن خواهیم افزود که در ساختن بازی مفید واقع می‌شود. از این گروه برای ترسیم گلوله‌ها روی صفحه‌ی نمایش در هر دور حلقه‌ی اصلی و برای به‌روز کردن موقعیت هر گلوله استفاده خواهیم کرد.</p><p>گروه را در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">__init__()</span><span class="rlm">‏</span> ایجاد می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def __init__(self):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash">self.ship = Ship(self)</span>
        self.bullets = pygame.sprite.Group()</pre></div><a id="p249"></a><p>سپس باید در هر دور حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">while</span><span class="rlm">‏</span>، موقعیت گلوله‌ها را به‌روز کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def run_game(self):</span>
        <span class="ash">"""Start the main loop for the game."""</span>
        <span class="ash">while True:</span>
            <span class="ash">self._check_events()</span>
            <span class="ash">self.ship.update()</span>
<span class="n" dir="ltr">1</span>            self.bullets.update()
            <span class="ash">self._update_screen()</span></pre></div><p>وقتی که <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">update()</span><span class="rlm">‏</span> را روی یک گروه فراخوانی می‌کنید <span class="n" dir="ltr">1</span>، گروه به‌طور خودکار متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">update()</span><span class="rlm">‏</span> هر کدام از اسپرایت‌های گروه را فراخوانی می‌کند. سطر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">self.bullets.update()</span><span class="rlm">‏</span> متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">bullet.update()</span><span class="rlm">‏</span> را برای هر کدام از گلوله‌های موجود در گروه <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">bullets</span><span class="rlm">‏</span> فراخوانی می‌کند.</p></div><div class="sect" id="ch12lev2sec22"><a class="bkmk" name="ch12lev2sec22"></a><h4>شلیک کردن گلوله</h4>
<p class="noindent">در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AlienInvasion</span><span class="rlm">‏</span>، باید <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_keydown_events()</span><span class="rlm">‏</span> را تغییر دهیم تا هر 
گاه بازیکن کلید اسپیس را فشار می‌دهد، یک گلوله شلیک کند. نیازی به تغییر دادن <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_check_keyup_events()</span><span class="rlm">‏</span> نیست، زیرا وقتی کلید اسپیس رها می‌شود، هیچ اتفاق خاصی نمی‌افتد. در ضمن، باید <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_update_screen()</span><span class="rlm">‏</span> را هم تغییر دهیم تا گلوله روی صفحه ترسیم شود و سپس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">flip()</span><span class="rlm">‏</span> فراخوانده شود.</p><p>از آنجا که هنگام شلیک گلوله یک سری کارها باید انجام شود، بهتر است متد جدید، به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_fire_bullet()</span><span class="rlm">‏</span>، برای انجام این کارها بنویسیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr"><span class="ash">--<span class="it">snip</span>--</span>
<span class="ash">from ship import Ship</span>
<span class="n" dir="ltr">1</span>from bullet import Bullet

<span class="ash">class AlienInvasion:</span>
    <span class="ash">--<span class="it">snip</span>--</span>
    <span class="ash">def _check_keydown_events(self, event):</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash">elif event.key == pygame.K_q:</span>
            <span class="ash">sys.exit()</span>
<span class="n" dir="ltr">2</span>        elif event.key == pygame.K_SPACE:
            self._fire_bullet()

    <span class="ash">def _check_keyup_events(self, event):</span>
        <span class="ash">--<span class="it">snip</span>--</span>

    def _fire_bullet(self):
        """Create a new bullet and add it to the bullets group."""
<span class="n" dir="ltr">3</span>        new_bullet = Bullet(self)
<span class="n" dir="ltr">4</span>        self.bullets.add(new_bullet)

    <span class="ash">def _update_screen(self):</span>
        <span class="ash">"""Update images on the screen, and flip to the new screen."""</span>
        <span class="ash">self.screen.fill(self.settings.bg_color)</span>
        
<span class="ash">self.ship.blitme()</span>
<span class="n" dir="ltr">5</span>        for bullet in self.bullets.sprites():
            bullet.draw_bullet()

<a id="p250"></a>        <span class="ash">pygame.display.flip()</span>

<span class="ash">--<span class="it">snip</span>--</span></pre></div><p>ابتدا، کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Bullet</span><span class="rlm">‏</span> را ایمپورت می‌کنیم <span class="n" dir="ltr">1</span>. سپس وقتی که کلید اسپیس فشار داده می‌شود، متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_fire_bullet()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم <span class="n" dir="ltr">2</span>. در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_fire_bullet()</span><span class="rlm">‏</span>، یک نمونه از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">Bullet</span><span class="rlm">‏</span> می‌سازیم و نام آن را <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">new_bullet</span><span class="rlm">‏</span> می‌گذاریم <span class="n" dir="ltr">3</span>. سپس آن را با استفاده از متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">add()</span><span class="rlm">‏</span> به گروه <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">bullets</span><span class="rlm">‏</span> اضافه می‌کنیم <span class="n" dir="ltr">4</span>. متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">add()</span><span class="rlm">‏</span> مشابه با متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">append()</span><span class="rlm">‏</span> است، ولی متدی است که اختصاصاً برای گروه‌های پای‌گیم نوشته شده است.</p><p>متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">bullets.sprites()</span><span class="rlm">‏</span> لیستی از تمام اسپرایت‌های موجود در گروه <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">bullets</span><span class="rlm">‏</span> را برمی‌گرداند. برای ترسیم تمام گلوله‌های شلیک شده روی صفحه‌ی نمایش، یک حلقه روی اسپرایت‌های موجود در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">bullets</span><span class="rlm">‏</span> تشکیل می‌دهیم، و برای هر کدام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">draw_bullet()</span><span class="rlm">‏</span> را فراخوانی می‌کنیم <span class="n" dir="ltr">5</span>.</p><p>حالا وقتی که <span class="rlm">‏</span><span class="ident" dir="ltr">alien_invasion.py</span><span class="rlm">‏</span> را اجرا می‌کنید، خواهید توانست سفینه را به راست و چپ حرکت دهید، و هر تعداد گلوله که خواستید، شلیک کنید. گلوله‌ها به طرف بالای صفحه می‌روند و وقتی که به بالا رسیدند، از نظر ناپدید می‌شوند، همان‌گونه که در <refFig xmlns="urn:dox:pycc">۱۲-۳</refFig> نشان داده شده است. می‌توانید اندازه، رنگ، و سرعت گلوله‌ها را در <span class="rlm">‏</span><span class="ident" dir="ltr">settings.py</span><span class="rlm">‏</span> تغییر دهید.</p><figure class="fig" id="ch12_fig03"><img class="fig" src="images/ch12_fig03.jpg"/><figcaption class="fig">شکل ۱۲-۳: سفینه پس از شلیک کردن یک سری گلوله</figcaption></figure></div><div class="sect" id="ch12lev2sec23"><a class="bkmk" name="ch12lev2sec23"></a><h4>حذف کردن گلوله‌های قدیمی</h4>
<p class="noindent">در حال حاضر، درست است که گلوله‌ها وقتی به بالای صفحه می‌رسند، ناپدید می‌شوند، ولی این فقط بدان خاطر است که پای‌گیم نمی‌تواند آن‌ها را در بالای صفحه ترسیم کند. در واقع، گلوله‌ها هنوز هم وجود دارند؛ فقط مقدار مختصه‌ی <span class="rlm">‏</span><span class="lr" dir="ltr">y</span><span class="rlm">‏</span> آن‌ها بیش از حد منفی شده است. این یک مشکل است، چرا که آن‌ها همچنان حافظه و توان پردازشی را مصرف می‌کنند.</p><a id="p251"></a><p>باید از شر این گلوله‌های قدیمی خلاص شویم، وگرنه بازی به علت انجام این کارهای غیرضروری کُند خواهد شد. برای انجام این کار، باید ببینیم که مقدار <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">bottom</span><span class="rlm">‏</span> مربوط به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">rect</span><span class="rlm">‏</span> یک گلوله کِی ۰ می‌شود، که نشان‌دهنده‌ی آن است که گلوله از بالای صفحه خارج شده است.</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def run_game(self):</span>
        <span class="ash">"""Start the main loop for the game."""</span>
        <span class="ash">while True:</span>
            <span class="ash">self._check_events()</span>
            <span class="ash">self.ship.update()</span>
            <span class="ash">self.bullets.update()</span>

            # Get rid of bullets that have disappeared.
<span class="n" dir="ltr">1</span>            for bullet in self.bullets.copy():
<span class="n" dir="ltr">2</span>                if bullet.rect.bottom &lt;= 0:
<span class="n" dir="ltr">3</span>                    self.bullets.remove(bullet)
<span class="n" dir="ltr">4</span>            print(len(self.bullets))

            <span class="ash">self._update_screen()</span></pre></div><p>وقتی که از یک حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">for</span><span class="rlm">‏</span> بر روی یک لیست (یا یک گروه در پای‌گیم) استفاده می‌کنید، پایتون انتظار دارد که تا زمانی که حلقه در حال اجرا است، لیست ثابت بماند. از آنجا که در داخل حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">for</span><span class="rlm">‏</span> نمی‌توانیم آیتم‌ها را از یک لیست یا گروه حذف کنیم، باید روی یک کپی از گروه حلقه تشکیل دهیم. از متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">copy()</span><span class="rlm">‏</span> برای تشکیل حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">for</span><span class="rlm">‏</span> استفاده می‌کنیم <span class="n" dir="ltr">1</span>، و لذا می‌توانیم <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">bullets</span><span class="rlm">‏</span> را در داخل حلقه تغییر دهیم. در <span class="n" dir="ltr">2</span>، هر کدام از گلوله‌ها را وارسی می‌کنیم تا ببینیم از بالای صفحه خارج شده است یا خیر. اگر خارج شده باشد، آن را از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">bullets</span><span class="rlm">‏</span> حذف می‌کنیم <span class="n" dir="ltr">3</span>. در <span class="n" dir="ltr">4</span>، یک فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">print()</span><span class="rlm">‏</span> قرار می‌دهیم تا نشان دهد که چه تعداد گلوله در حال حاضر در بازی هست، و مشخص شود که گلوله‌هایی که به بالای صفحه رسیده‌اند، حذف شده‌اند.</p><p>اگر این کد درست کار کند، می‌توانیم هنگام شلیک کردن گلوله‌ها به خروجی ترمینال نگاه کنیم و ببینیم که هر بار با خارج شدن تمام گلوله‌ها از بالای صفحه، تعداد گلوله‌ها به صفر می‌رسد. پس از اجرای بازی و مطمئن شدن از اینکه گلوله‌ها به درستی حذف می‌شوند، این فراخوانی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">print()</span><span class="rlm">‏</span> را حذف کنید. اگر این سطر را حذف نکنید، بازی به‌طور قابل‌توجهی کندتر اجرا خواهد شد، چرا که نوشتن در ترمینال بیشتر از ترسیم کردن عناصر گرافیکی پنجره‌ی بازی وقت می‌برد.</p></div><div class="sect" id="ch12lev2sec24"><a class="bkmk" name="ch12lev2sec24"></a><h4>محدود کردن تعداد گلوله‌ها</h4>
<p class="noindent">خیلی از بازی‌های تیراندازی تعداد گلوله‌هایی را که بازیکن می‌تواند هم‌زمان روی صفحه داشته باشد، محدود می‌کنند؛ این سبب می‌شود که بازیکن تلاش کند که دقیق‌تر شلیک کند. ما هم در بازی <span class="emphasis">تهاجم بیگانگان</span> همین کار را خواهیم کرد.</p><p>ابتدا، تعداد گلوله‌های مجاز را در <span class="rlm">‏</span><span class="ident" dir="ltr">settings.py</span><span class="rlm">‏</span> ذخیره می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">settings.py</div><pre class="snippet" dir="ltr">        <span class="ash"># Bullet settings</span>
        <span class="ash">--<span class="it">snip</span>--</span>
        <span class="ash">self.bullet_color = (60, 60, 60)</span>
        self.bullets_allowed = 3</pre></div><a id="p252"></a><p>به این ترتیب، بازیکن هر زمان حداکثر سه گلوله می‌تواند داشته باشد. از این تنظیم در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AlienInvasion</span><span class="rlm">‏</span> استفاده خواهیم کرد تا قبل از ایجاد گلوله‌ی جدید در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_fire_bullet()</span><span class="rlm">‏</span>، ببینیم بازیکن چند گلوله دارد:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    <span class="ash">def _fire_bullet(self):</span>
        <span class="ash">"""Create a new bullet and add it to the bullets group."""</span>
        if len(self.bullets) &lt; self.settings.bullets_allowed:
            <span class="ash">new_bullet = Bullet(self)</span>
            <span class="ash">self.bullets.add(new_bullet)</span></pre></div><p>وقتی که بازیکن کلید اسپیس را می‌زند، طول <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">bullets</span><span class="rlm">‏</span> را وارسی می‌کنیم. اگر <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">len(self.bullets)</span><span class="rlm">‏</span> کوچک‌تر از سه باشد، گلوله‌ی جدید ایجاد می‌کنیم. ولی اگر از قبل سه گلوله‌ی فعال داشته باشیم، با فشار دادن کلید اسپیس هیچ اتفاقی نمی‌افتد. حالا وقتی که بازی را اجرا می‌کنید، خواهید توانست گلوله‌ها را فقط در گروه‌های سه‌تایی شلیک کنید.</p></div><div class="sect" id="ch12lev2sec25"><a class="bkmk" name="ch12lev2sec25"></a><h4>ایجاد متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_update_bullets()</span><span class="rlm">‏</span></h4>
<p class="noindent">می‌خواهیم که کلاس <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">AlienInvasion</span><span class="rlm">‏</span> حتی‌الامکان سازمان‌دهی خوبی داشته باشد، ازاین‌رو، حالا که کد مدیریت گلوله را نوشته و وارسی کرده‌ایم، می‌توانیم آن را به متد جدیدی منتقل کنیم. متد جدیدی به نام <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_update_bullets()</span><span class="rlm">‏</span> ایجاد می‌کنیم و آن را درست قبل از <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_update_screen()</span><span class="rlm">‏</span> اضافه می‌کنیم:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">    def _update_bullets(self):
        """Update position of bullets and get rid of old bullets."""
        # Update bullet positions.
        <span class="ash">self.bullets.update()</span>

        <span class="ash"># Get rid of bullets that have disappeared.</span>
        <span class="ash">for bullet in self.bullets.copy():</span>
            <span class="ash">if bullet.rect.bottom &lt;= 0:</span>
                <span class="ash">self.bullets.remove(bullet)</span></pre></div><p>کد مربوط به <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">_update_bullets()</span><span class="rlm">‏</span> از متد <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">run_game()</span><span class="rlm">‏</span> بریده و الصاق شده است؛ تنها کاری که کرده‌ایم، روشن‌تر کردن توضیحات است.</p><p>حلقه‌ی <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">while</span><span class="rlm">‏</span> در <span class="rlm">‏</span><span class="literal" dir="ltr" style="direction:ltr;">run_game()</span><span class="rlm">‏</span> دوباره ساده شده است:</p><div class="snippet"><div class="snippet-title" dir="ltr">alien_invasion.py</div><pre class="snippet" dir="ltr">        <span class="ash">while True:</span>
            <span class="ash">self._check_events()</span>
            <span class="ash">self.ship.update()</span>
            self._update_bullets()
            <span class="ash">self._update_screen()</span></pre></div><p>حالا حلقه‌ی اصلی ما حاوی کد بسیار کوتاهی است، ازاین‌رو به سرعت می‌توانیم نام متدها را بخوانیم و بفهمیم که در بازی چه اتفاقی می‌افتد. حلقه‌ی اصلی ورودی بازیکن را وارسی می‌کند، و سپس مکان سفینه و گلوله‌های شلیک‌شده را به‌روز می‌نماید. سپس با استفاده از مکان‌های جدید، صفحه‌ی جدیدی را ترسیم می‌کنیم.</p><p>یک بار دیگر <span class="rlm">‏</span><span class="ident" dir="ltr">alien_invasion.py</span><span class="rlm">‏</span> را اجرا کنید و مطمئن شوید که باز هم می‌توانید بدون هر گونه خطایی گلوله‌ها را شلیک کند.</p><div class="sidebar"><h6 class="sidebar-title">خودتان امتحان کنید</h6>
<a id="p253"></a><p class="tiy1"><span class="tiy" id="ch12_tiy06"><span class="tiy-num">۱۲-۶</span>. <span class="tiy-title">شلیک جانبی</span>: </span> یک بازی بنویسید که یک سفینه در طرف چپ صفحه دارد و بازیکن می‌تواند سفینه را به بالا و پایین حرکت دهد. وقتی که بازیکن کلید اسپیس را فشار می‌دهد، سفینه گلوله‌ای شلیک می‌کند که به طرف راست صفحه حرکت می‌کند. در ضمن، وقتی گلوله از صفحه ناپدید شد، آن را حذف کنید.</p></div></div></div><div class="sect" id="ch12lev1sec9"><a class="bkmk" name="ch12lev1sec9"></a><h3>خلاصه</h3>
<p class="noindent">در این فصل، یاد گرفتید که چگونه برای ساخت یک بازی، برنامه‌ریزی کنید، و با ساختار پایه‌ی بازی نوشته شده با پای‌گیم آشنا شدید. یاد گرفتید که رنگ پس‌زمینه را تعیین کنید و تنظیمات را در کلاس جداگانه‌ای ذخیره کنید تا بتوانید آسان‌تر به آن دسترسی داشته باشید. فراگرفتید که عکسی را روی صفحه‌ی نمایش ترسیم کنید، و کنترل حرکت عناصر بازی را در اختیار بازیکن قرار دهید. عناصری ایجاد کردید که خودبه‌خود حرکت می‌کنند، مانند گلوله‌هایی که به طرف بالای صفحه شلیک می‌شوند، و اشیایی را که دیگر مورد نیاز نیستند، حذف کردید. هم‌چنین، یاد گرفتید که کد پروژه را مرتب بازساخت کنید تا ادامه‌ی برنامه‌نویسی آسان باشد.</p><p>در <span class="ref"><a href="c26-ch13.xhtml">فصل ۱۳</a></span>، بیگانه‌ها را به بازی <span class="emphasis">تهاجم بیگانگان</span> اضافه خواهیم کرد. در پایان فصل، خواهید توانست بیگانه‌ها را با شلیک گلوله ساقط کنید، و چه بهتر که این کار را قبل از رسیدن آن‌ها به سفینه‌تان انجام دهید!</p><a id="p254"></a></div></div>
						<div class="row pager"><div class="col-md-5 text-center text-md-left pager-prev"><a href="c24-prj1.xhtml"><span xmlns="http://www.w3.org/1999/xhtml"><span>پروژه‌ی ۱</span>: <span>تهاجم بیگانگان</span></span></a></div><div class="col-md-2 text-center pager-title"><a href="c01-cover.xhtml">آغاز</a></div><div class="col-md-5 text-center text-md-right pager-next"><a href="c26-ch13.xhtml"><span xmlns="http://www.w3.org/1999/xhtml"><span>فصل ۱۳</span>: <span>بیگانه‌ها!</span></span></a></div></div></main><aside class="col-md-2 order-md-first"><ul class="nav nav-pills flex-column"><li class="nav-item"><a class="nav-link" href="../">دوره‌ی فشرده‌ی پایتون</a></li><li class="nav-item"><a class="nav-link" href="c06-toc.xhtml">فهرست</a></li></ul></aside></div></div><div class="container"><div id="footer" class="row"><div class="col-sm-6"><p><span>© ۱۴۰۰، قاسم کیانی مقدم.</span></p></div><div class="col-sm-6"><p class="text-right"><span><a target="_blank" rel="me" href="https://linkedin.com/in/ghasemkiani" title="لینکدین"><span class="fab fa-linkedin"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://github.com/ghasemkiani" title="گیت‌هاب"><span class="fab fa-github"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://twitter.com/ghasemkiani" title="توئیتر"><span class="fab fa-twitter"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://facebook.com/ghasemkiani" title="فیس‌بوک"><span class="fab fa-facebook"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://telegram.me/ghasemkiani" title="تلگرام"><span class="fab fa-telegram"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://instagram.com/ghasem.kiani" title="اینستاگرام"><span class="fab fa-instagram"></span></a></span><span> </span><span><a target="_blank" rel="me" href="https://mastodon.social/@ghasemkiani" title="ماستودون"><span class="fab fa-mastodon"></span></a></span></p></div></div></div><script crossorigin="anonymous" src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"></script><script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut"></script><script crossorigin="anonymous" src="https://cdn.rtlcss.com/bootstrap/v4.0.0/js/bootstrap.min.js" integrity="sha384-54+cucJ4QbVb99v8dcttx/0JRx4FHMmhOWi4W+xrXpKcsKQodCBwAvu3xxkZAwsH"></script><script src="https://www.googletagmanager.com/gtag/js?id=undefined"></script><script src="data:application/javascript;charset=UTF-8;base64,KCh7aWR9KSA9PiB7DQoJd2luZG93LmRhdGFMYXllciA9IHdpbmRvdy5kYXRhTGF5ZXIgfHwgW107DQoJZnVuY3Rpb24gZ3RhZygpe2RhdGFMYXllci5wdXNoKGFyZ3VtZW50cyk7fQ0KCWd0YWcoImpzIiwgbmV3IERhdGUoKSk7DQoNCglndGFnKCJjb25maWciLCBpZCk7DQp9KSh7fSk7Cg=="></script></body></html>